; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\wmtouch.o --depend=.\rvmdk\wmtouch.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\wmtouch.crf ..\..\..\..\..\uCGUI\GUI\WM\WMTouch.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  WM__IsInModalArea PROC
;;;48     */
;;;49     int WM__IsInModalArea(WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;50       if ((WM__CHWinModal.hWin == 0) || WM__IsAncestor(hWin, WM__CHWinModal.hWin) || (hWin == WM__CHWinModal.hWin)) {
000004  4c97              LDR      r4,|L1.612|
000006  88a0              LDRH     r0,[r4,#4]  ; WM__CHWinModal
000008  b148              CBZ      r0,|L1.30|
00000a  f9b41004          LDRSH    r1,[r4,#4]  ; WM__CHWinModal
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       WM__IsAncestor
000014  b918              CBNZ     r0,|L1.30|
000016  f9b40004          LDRSH    r0,[r4,#4]  ; WM__CHWinModal
00001a  42a8              CMP      r0,r5
00001c  d101              BNE      |L1.34|
                  |L1.30|
;;;51         return 1;
00001e  2001              MOVS     r0,#1
;;;52       }
;;;53       return 0;
;;;54     }
000020  bd70              POP      {r4-r6,pc}
                  |L1.34|
000022  2000              MOVS     r0,#0                 ;53
000024  bd70              POP      {r4-r6,pc}
;;;55     
                          ENDP

                  WM__SendPIDMessage PROC
;;;65     */
;;;66     void WM__SendPIDMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000026  b570              PUSH     {r4-r6,lr}
000028  b084              SUB      sp,sp,#0x10
00002a  4606              MOV      r6,r0
00002c  460d              MOV      r5,r1
;;;67       #if 1
;;;68       WM_HWIN iWin;
;;;69       WM_MESSAGE Msg;
;;;70       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
00002e  68a9              LDR      r1,[r5,#8]
000030  6868              LDR      r0,[r5,#4]
000032  9103              STR      r1,[sp,#0xc]
000034  9002              STR      r0,[sp,#8]
;;;71       /* Send notification to all ancestors.
;;;72          We need to check if the window which has received the last message still exists,
;;;73          since it may have deleted itself and its parent as result of the message.
;;;74       */
;;;75       Msg.hWinSrc = hWin;
000036  f8ad600a          STRH     r6,[sp,#0xa]
;;;76       Msg.MsgId   = WM_TOUCH_CHILD;
00003a  200d              MOVS     r0,#0xd
00003c  9001              STR      r0,[sp,#4]
;;;77       iWin = hWin;
00003e  4634              MOV      r4,r6
;;;78       while (WM_IsWindow(iWin)) {
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       WM_IsWindow
000046  b170              CBZ      r0,|L1.102|
                  |L1.72|
;;;79         iWin = WM_GetParent(iWin);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       WM_GetParent
00004e  4604              MOV      r4,r0
;;;80         if (iWin) {
000050  b124              CBZ      r4,|L1.92|
;;;81           Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
000052  9503              STR      r5,[sp,#0xc]
;;;82           WM__SendMessageIfEnabled(iWin, &Msg);    /* Send message to the ancestors */
000054  a901              ADD      r1,sp,#4
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       WM__SendMessageIfEnabled
                  |L1.92|
00005c  4620              MOV      r0,r4                 ;78
00005e  f7fffffe          BL       WM_IsWindow
000062  2800              CMP      r0,#0                 ;78
000064  d1f0              BNE      |L1.72|
                  |L1.102|
;;;83         }
;;;84       }
;;;85       /* Send message to the affected window */
;;;86       WM__SendMessageIfEnabled(hWin, pMsg);
000066  4629              MOV      r1,r5
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       WM__SendMessageIfEnabled
;;;87       #else
;;;88       WM_MESSAGE Msg;
;;;89       /* Send message to the affected window */
;;;90       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
;;;91       WM__SendMessageIfEnabled(hWin, &Msg);
;;;92       /* Send notification to all ancestors.
;;;93          We need to check if the window which has received the last message still exists,
;;;94          since it may have deleted itself and its parent as result of the message.
;;;95       */
;;;96       Msg.hWinSrc = hWin;
;;;97       Msg.MsgId   = WM_TOUCH_CHILD;
;;;98       while (WM_IsWindow(hWin)) {
;;;99         hWin = WM_GetParent(hWin);
;;;100        if (hWin) {
;;;101          Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
;;;102          WM__SendMessageIfEnabled(hWin, &Msg);    /* Send message to the ancestors */
;;;103        }
;;;104      }
;;;105      #endif
;;;106    }
00006e  b004              ADD      sp,sp,#0x10
000070  bd70              POP      {r4-r6,pc}
;;;107    
                          ENDP

                  WM__SendTouchMessage PROC
;;;111    */
;;;112    void WM__SendTouchMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000072  b570              PUSH     {r4-r6,lr}
000074  4606              MOV      r6,r0
000076  460d              MOV      r5,r1
;;;113      GUI_PID_STATE* pState;
;;;114      pState     = (GUI_PID_STATE*)pMsg->Data.p;
000078  68ac              LDR      r4,[r5,#8]
;;;115      if (pState) {
00007a  b164              CBZ      r4,|L1.150|
;;;116        WM_Obj* pWin;
;;;117        pWin       = WM_H2P(hWin);
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       GUI_ALLOC_h2p
;;;118        pState->x -= pWin->Rect.x0;
000082  f9b02000          LDRSH    r2,[r0,#0]
000086  6821              LDR      r1,[r4,#0]
000088  1a89              SUBS     r1,r1,r2
00008a  6021              STR      r1,[r4,#0]
;;;119        pState->y -= pWin->Rect.y0;
00008c  f9b00002          LDRSH    r0,[r0,#2]
000090  6861              LDR      r1,[r4,#4]
000092  1a08              SUBS     r0,r1,r0
000094  6060              STR      r0,[r4,#4]
                  |L1.150|
;;;120      }
;;;121      WM__SendPIDMessage(hWin, pMsg);
000096  4629              MOV      r1,r5
000098  4630              MOV      r0,r6
00009a  e8bd4070          POP      {r4-r6,lr}
00009e  e7fe              B        WM__SendPIDMessage
;;;122    }
;;;123    
                          ENDP

                  _Screen2Win PROC
;;;133    */
;;;134    static WM_HWIN _Screen2Win(GUI_PID_STATE* pState) {
0000a0  4602              MOV      r2,r0
;;;135      if (WM__hCapture == 0) {
0000a2  4871              LDR      r0,|L1.616|
0000a4  f9b00000          LDRSH    r0,[r0,#0]  ; WM__hCapture
0000a8  2800              CMP      r0,#0
0000aa  d103              BNE      |L1.180|
;;;136        return WM_Screen2hWin(pState->x, pState->y);
0000ac  6851              LDR      r1,[r2,#4]
0000ae  6810              LDR      r0,[r2,#0]
0000b0  f7ffbffe          B.W      WM_Screen2hWin
                  |L1.180|
;;;137      } 
;;;138      return WM__hCapture;
;;;139    }
0000b4  4770              BX       lr
;;;140    
                          ENDP

                  WM_HandlePID PROC
;;;157    */
;;;158    int WM_HandlePID(void) {
0000b6  e92d41f0          PUSH     {r4-r8,lr}
0000ba  b092              SUB      sp,sp,#0x48
;;;159      int r = 0;
0000bc  2700              MOVS     r7,#0
;;;160      WM_MESSAGE Msg;
;;;161      WM_CRITICAL_HANDLE CHWin;
;;;162      GUI_PID_STATE State = {0}, StateNew;
0000be  2600              MOVS     r6,#0
0000c0  9609              STR      r6,[sp,#0x24]
0000c2  960a              STR      r6,[sp,#0x28]
0000c4  960b              STR      r6,[sp,#0x2c]
;;;163      GUI_PID_GetState(&StateNew);
0000c6  a806              ADD      r0,sp,#0x18
0000c8  f7fffffe          BL       GUI_PID_GetState
;;;164      WM_LOCK();
0000cc  f7fffffe          BL       GUI_Lock
;;;165      StateNew.x += GUI_OrgX;
0000d0  4966              LDR      r1,|L1.620|
0000d2  9806              LDR      r0,[sp,#0x18]
0000d4  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgX
0000d8  4408              ADD      r0,r0,r1
0000da  9006              STR      r0,[sp,#0x18]
;;;166      StateNew.y += GUI_OrgY;
0000dc  4964              LDR      r1,|L1.624|
0000de  9807              LDR      r0,[sp,#0x1c]
0000e0  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgY
0000e4  4408              ADD      r0,r0,r1
0000e6  9007              STR      r0,[sp,#0x1c]
;;;167      WM__AddCriticalHandle(&CHWin);
0000e8  a80c              ADD      r0,sp,#0x30
0000ea  f7fffffe          BL       WM__AddCriticalHandle
;;;168      if ((WM_PID__StateLast.x != StateNew.x) || (WM_PID__StateLast.y != StateNew.y) || (WM_PID__StateLast.Pressed != StateNew.Pressed)) {
0000ee  4d61              LDR      r5,|L1.628|
0000f0  9906              LDR      r1,[sp,#0x18]
0000f2  6828              LDR      r0,[r5,#0]  ; WM_PID__StateLast
0000f4  4288              CMP      r0,r1
0000f6  d108              BNE      |L1.266|
0000f8  6868              LDR      r0,[r5,#4]  ; WM_PID__StateLast
0000fa  9907              LDR      r1,[sp,#0x1c]
0000fc  4288              CMP      r0,r1
0000fe  d104              BNE      |L1.266|
000100  7a28              LDRB     r0,[r5,#8]  ; WM_PID__StateLast
000102  f89d1020          LDRB     r1,[sp,#0x20]
000106  4288              CMP      r0,r1
000108  d07e              BEQ      |L1.520|
                  |L1.266|
;;;169        #if GUI_SUPPORT_CURSOR
;;;170          GUI_CURSOR_SetPosition(StateNew.x, StateNew.y);
;;;171        #endif
;;;172        CHWin.hWin = _Screen2Win(&StateNew);
00010a  a806              ADD      r0,sp,#0x18
00010c  f7fffffe          BL       _Screen2Win
000110  f8ad0034          STRH     r0,[sp,#0x34]
;;;173        #if GUI_SUPPORT_MOUSE
;;;174        /* Send WM_MOUSEOVER_END Message */
;;;175        if (WM__CHWinMouseOver.hWin && (WM__CHWinMouseOver.hWin != CHWin.hWin)) {
;;;176          if (WM__IsInModalArea(WM__CHWinMouseOver.hWin)) {
;;;177            /* Do not send messages to disabled windows */
;;;178            if (WM__IsEnabled(WM__CHWinMouseOver.hWin)) {
;;;179              State      = StateNew;
;;;180              Msg.MsgId  = WM_MOUSEOVER_END;
;;;181              Msg.Data.p = (void*)&State;
;;;182              WM__SendTouchMessage(WM__CHWinMouseOver.hWin, &Msg);
;;;183              WM__CHWinMouseOver.hWin = 0;
;;;184            }
;;;185          }
;;;186        }
;;;187        #endif
;;;188        if (WM__IsInModalArea(CHWin.hWin)) {
000114  f9bd0034          LDRSH    r0,[sp,#0x34]
000118  f7fffffe          BL       WM__IsInModalArea
00011c  b3a0              CBZ      r0,|L1.392|
;;;189          #if GUI_SUPPORT_MOUSE
;;;190            WM__CHWinMouseOver.hWin = CHWin.hWin;
;;;191          #endif
;;;192          /*
;;;193           * Send WM_PID_STATE_CHANGED message if state has changed (just pressed or just released)
;;;194           */
;;;195          if ((WM_PID__StateLast.Pressed != StateNew.Pressed) && CHWin.hWin) {
00011e  7a28              LDRB     r0,[r5,#8]  ; WM_PID__StateLast
000120  f89d1020          LDRB     r1,[sp,#0x20]
;;;196            GUI_PID_STATE PID_StateOld;
;;;197            WM_HWIN hWinOld;
;;;198            WM_PID_STATE_CHANGED_INFO Info;
;;;199            WM_Obj* pWin;
;;;200            pWin = WM_H2P(CHWin.hWin);
;;;201            Info.State     = StateNew.Pressed;
;;;202            Info.StatePrev = WM_PID__StateLast.Pressed;
;;;203            Info.x         = StateNew.x - pWin->Rect.x0;
;;;204            Info.y         = StateNew.y - pWin->Rect.y0;
;;;205            Msg.Data.p = &Info;
;;;206            Msg.MsgId  = WM_PID_STATE_CHANGED;
;;;207            /* Make sure that this routine does not react a second time on the same press event.
;;;208             * This could happen if for example a dialog is executed during the WM_PID_STATE_CHANGED message processing
;;;209             */
;;;210            PID_StateOld = WM_PID__StateLast;
;;;211            /* Make sure that in case of creating a new window over the current PID position
;;;212             * during the WM_PID_STATE_CHANGED message processing the old window
;;;213             * will be informed that it is no longer pressed.
;;;214             */
;;;215            WM_PID__StateLast.Pressed = StateNew.Pressed;
;;;216            if (State.Pressed) {
;;;217              hWinOld            = WM__CHWinLast.hWin;
000124  f8df8150          LDR      r8,|L1.632|
000128  4288              CMP      r0,r1                 ;195
00012a  d042              BEQ      |L1.434|
00012c  f8bd0034          LDRH     r0,[sp,#0x34]         ;195
000130  b358              CBZ      r0,|L1.394|
000132  f9bd0034          LDRSH    r0,[sp,#0x34]         ;200
000136  f7fffffe          BL       GUI_ALLOC_h2p
00013a  4601              MOV      r1,r0                 ;200
00013c  f89d0020          LDRB     r0,[sp,#0x20]         ;201
000140  f88d0008          STRB     r0,[sp,#8]            ;201
000144  7a2a              LDRB     r2,[r5,#8]            ;202  ; WM_PID__StateLast
000146  f88d2009          STRB     r2,[sp,#9]            ;202
00014a  f9b13000          LDRSH    r3,[r1,#0]            ;203
00014e  9a06              LDR      r2,[sp,#0x18]         ;203
000150  1ad2              SUBS     r2,r2,r3              ;203
000152  9200              STR      r2,[sp,#0]            ;203
000154  f9b11002          LDRSH    r1,[r1,#2]            ;204
000158  9a07              LDR      r2,[sp,#0x1c]         ;204
00015a  1a51              SUBS     r1,r2,r1              ;204
00015c  9101              STR      r1,[sp,#4]            ;204
00015e  f8cdd040          STR      sp,[sp,#0x40]         ;205
000162  2111              MOVS     r1,#0x11              ;206
000164  910e              STR      r1,[sp,#0x38]         ;206
000166  68ab              LDR      r3,[r5,#8]            ;210  ; WM_PID__StateLast
000168  686a              LDR      r2,[r5,#4]            ;210  ; WM_PID__StateLast
00016a  6829              LDR      r1,[r5,#0]            ;210  ; WM_PID__StateLast
00016c  9305              STR      r3,[sp,#0x14]         ;210
00016e  9204              STR      r2,[sp,#0x10]         ;210
000170  9103              STR      r1,[sp,#0xc]          ;210
000172  7228              STRB     r0,[r5,#8]            ;215
000174  f89d002c          LDRB     r0,[sp,#0x2c]         ;216
000178  b140              CBZ      r0,|L1.396|
00017a  f9b84004          LDRSH    r4,[r8,#4]  ; WM__CHWinLast
;;;218              WM__CHWinLast.hWin = CHWin.hWin;
00017e  f8bd0034          LDRH     r0,[sp,#0x34]
000182  f8a80004          STRH     r0,[r8,#4]
000186  e002              B        |L1.398|
                  |L1.392|
000188  e059              B        |L1.574|
                  |L1.394|
00018a  e012              B        |L1.434|
                  |L1.396|
;;;219            } else {
;;;220              hWinOld            = 0;
00018c  2400              MOVS     r4,#0
                  |L1.398|
;;;221            }
;;;222            WM__SendMessageIfEnabled(CHWin.hWin, &Msg);
00018e  f9bd0034          LDRSH    r0,[sp,#0x34]
000192  a90e              ADD      r1,sp,#0x38
000194  f7fffffe          BL       WM__SendMessageIfEnabled
;;;223            /* Restore state for further processing */
;;;224            WM_PID__StateLast = PID_StateOld;
000198  9a05              LDR      r2,[sp,#0x14]
00019a  9904              LDR      r1,[sp,#0x10]
00019c  9803              LDR      r0,[sp,#0xc]
00019e  60aa              STR      r2,[r5,#8]  ; WM_PID__StateLast
0001a0  6069              STR      r1,[r5,#4]  ; WM_PID__StateLast
0001a2  6028              STR      r0,[r5,#0]  ; WM_PID__StateLast
;;;225            if (hWinOld) {
0001a4  b12c              CBZ      r4,|L1.434|
;;;226              /* hWinOld could be deleted during message processing. So check if it is a Window
;;;227               * before using it.
;;;228               */
;;;229              if (WM_IsWindow(hWinOld)) {
0001a6  4620              MOV      r0,r4
0001a8  f7fffffe          BL       WM_IsWindow
0001ac  b108              CBZ      r0,|L1.434|
;;;230                WM__CHWinLast.hWin        = hWinOld;
0001ae  f8a84004          STRH     r4,[r8,#4]
                  |L1.434|
;;;231              }
;;;232            }
;;;233          }
;;;234          /*
;;;235           * Send WM_TOUCH message(s)
;;;236           * Note that we may have to send 2 touch messages.
;;;237           */
;;;238          if (WM_PID__StateLast.Pressed | StateNew.Pressed) {    /* Only if pressed or just released */
0001b2  7a29              LDRB     r1,[r5,#8]  ; WM_PID__StateLast
0001b4  f89d0020          LDRB     r0,[sp,#0x20]
0001b8  4301              ORRS     r1,r1,r0
0001ba  d040              BEQ      |L1.574|
;;;239            Msg.MsgId = WM_TOUCH;
0001bc  210c              MOVS     r1,#0xc
0001be  910e              STR      r1,[sp,#0x38]
;;;240            r = 1;
0001c0  2701              MOVS     r7,#1
;;;241            /*
;;;242             * Tell window if it is no longer pressed
;;;243             * This happens for 2 possible reasons:
;;;244             * a) PID is released
;;;245             * b) PID is moved out
;;;246             */
;;;247            if (WM__CHWinLast.hWin != CHWin.hWin) {
0001c2  f9b81004          LDRSH    r1,[r8,#4]  ; WM__CHWinLast
0001c6  f9bd2034          LDRSH    r2,[sp,#0x34]
0001ca  ac09              ADD      r4,sp,#0x24           ;162
0001cc  4291              CMP      r1,r2
0001ce  d013              BEQ      |L1.504|
;;;248              if (WM__CHWinLast.hWin != 0) {
0001d0  f8b81004          LDRH     r1,[r8,#4]  ; WM__CHWinLast
0001d4  b181              CBZ      r1,|L1.504|
;;;249                if (StateNew.Pressed) {
0001d6  b108              CBZ      r0,|L1.476|
;;;250                  /* Moved out -> no longer in this window
;;;251                   * Send a NULL pointer as data
;;;252                   */
;;;253                  Msg.Data.p = NULL;
0001d8  9610              STR      r6,[sp,#0x40]
0001da  e006              B        |L1.490|
                  |L1.476|
;;;254                } else {
;;;255                  /* Last window needs to know that it has been "Released"
;;;256                   * Send last coordinates 
;;;257                   */
;;;258                  State.x       = WM_PID__StateLast.x;
0001dc  6828              LDR      r0,[r5,#0]  ; WM_PID__StateLast
0001de  9009              STR      r0,[sp,#0x24]
;;;259                  State.y       = WM_PID__StateLast.y;
0001e0  6868              LDR      r0,[r5,#4]  ; WM_PID__StateLast
0001e2  900a              STR      r0,[sp,#0x28]
;;;260                  State.Pressed = 0;
0001e4  f88d602c          STRB     r6,[sp,#0x2c]
;;;261                  Msg.Data.p = (void*)&State;
0001e8  9410              STR      r4,[sp,#0x40]
                  |L1.490|
;;;262                }
;;;263                GUI_DEBUG_LOG1 ("\nSending WM_Touch to LastWindow %d (out of area)", WM__CHWinLast.hWin);
;;;264                WM__SendTouchMessage(WM__CHWinLast.hWin, &Msg);
0001ea  f9b80004          LDRSH    r0,[r8,#4]  ; WM__CHWinLast
0001ee  a90e              ADD      r1,sp,#0x38
0001f0  f7fffffe          BL       WM__SendTouchMessage
;;;265                WM__CHWinLast.hWin = 0;
0001f4  f8a86004          STRH     r6,[r8,#4]
                  |L1.504|
;;;266              }
;;;267            }
;;;268            /* Make sure that this routine does not react a second time on the same event.
;;;269             * This could happen if for example a dialog is executed during the WM_TOUCH message processing
;;;270             */
;;;271            WM_PID__StateLast.Pressed = StateNew.Pressed;
0001f8  f89d0020          LDRB     r0,[sp,#0x20]
0001fc  7228              STRB     r0,[r5,#8]
;;;272            /* Sending WM_Touch to current window */
;;;273            if (CHWin.hWin) {
0001fe  f8bd0034          LDRH     r0,[sp,#0x34]
000202  b1e0              CBZ      r0,|L1.574|
;;;274              /* convert screen into window coordinates */
;;;275              State = StateNew;
000204  9a08              LDR      r2,[sp,#0x20]
000206  e000              B        |L1.522|
                  |L1.520|
000208  e022              B        |L1.592|
                  |L1.522|
00020a  9806              LDR      r0,[sp,#0x18]
00020c  9907              LDR      r1,[sp,#0x1c]
00020e  920b              STR      r2,[sp,#0x2c]
000210  910a              STR      r1,[sp,#0x28]
000212  9009              STR      r0,[sp,#0x24]
;;;276              /* Remember window */
;;;277              if (State.Pressed) {
000214  f89d002c          LDRB     r0,[sp,#0x2c]
000218  b120              CBZ      r0,|L1.548|
;;;278                WM__CHWinLast.hWin = CHWin.hWin;
00021a  f8bd0034          LDRH     r0,[sp,#0x34]
00021e  f8a80004          STRH     r0,[r8,#4]
000222  e006              B        |L1.562|
                  |L1.548|
;;;279              } else {
;;;280                /* Handle automatic capture release */
;;;281                if (WM__CaptureReleaseAuto) {
000224  4815              LDR      r0,|L1.636|
000226  7800              LDRB     r0,[r0,#0]  ; WM__CaptureReleaseAuto
000228  b108              CBZ      r0,|L1.558|
;;;282                  WM_ReleaseCapture();
00022a  f7fffffe          BL       WM_ReleaseCapture
                  |L1.558|
;;;283                }
;;;284                WM__CHWinLast.hWin = 0;
00022e  f8a86004          STRH     r6,[r8,#4]
                  |L1.562|
;;;285              }
;;;286              Msg.Data.p = (void*)&State;
000232  9410              STR      r4,[sp,#0x40]
;;;287              WM__SendTouchMessage(CHWin.hWin, &Msg);
000234  f9bd0034          LDRSH    r0,[sp,#0x34]
000238  a90e              ADD      r1,sp,#0x38
00023a  f7fffffe          BL       WM__SendTouchMessage
                  |L1.574|
;;;288            }
;;;289          }
;;;290          /*
;;;291           * Send WM_MOUSEOVER message
;;;292           */
;;;293          #if GUI_SUPPORT_MOUSE
;;;294          else {
;;;295            /* Send WM_MOUSEOVER Message */
;;;296            if (CHWin.hWin) {
;;;297              /* Do not send messages to disabled windows */
;;;298              if (WM__IsEnabled(CHWin.hWin)) {
;;;299                State      = StateNew;
;;;300                Msg.MsgId  = WM_MOUSEOVER;
;;;301                Msg.Data.p = (void*)&State;
;;;302                WM__SendTouchMessage(CHWin.hWin, &Msg);
;;;303              }
;;;304            }
;;;305          }
;;;306          #endif
;;;307        }
;;;308        /* Store the new state */
;;;309        WM_PID__StateLast = StateNew;
00023e  9a08              LDR      r2,[sp,#0x20]
000240  9907              LDR      r1,[sp,#0x1c]
000242  9806              LDR      r0,[sp,#0x18]
000244  60aa              STR      r2,[r5,#8]  ; WM_PID__StateLast
000246  6069              STR      r1,[r5,#4]  ; WM_PID__StateLast
000248  6028              STR      r0,[r5,#0]  ; WM_PID__StateLast
;;;310        WM_PID__SetPrevState(&StateNew);
00024a  a806              ADD      r0,sp,#0x18
00024c  f7fffffe          BL       WM_PID__SetPrevState
                  |L1.592|
;;;311      }
;;;312      WM__RemoveCriticalHandle(&CHWin);
000250  a80c              ADD      r0,sp,#0x30
000252  f7fffffe          BL       WM__RemoveCriticalHandle
;;;313      WM_UNLOCK();
000256  f7fffffe          BL       GUI_Unlock
;;;314      return r;
;;;315    }
00025a  b012              ADD      sp,sp,#0x48
00025c  4638              MOV      r0,r7                 ;314
00025e  e8bd81f0          POP      {r4-r8,pc}
;;;316    
                          ENDP

000262  0000              DCW      0x0000
                  |L1.612|
                          DCD      ||.data||
                  |L1.616|
                          DCD      WM__hCapture
                  |L1.620|
                          DCD      GUI_OrgX
                  |L1.624|
                          DCD      GUI_OrgY
                  |L1.628|
                          DCD      WM_PID__StateLast
                  |L1.632|
                          DCD      ||.data||+0x8
                  |L1.636|
                          DCD      WM__CaptureReleaseAuto

                          AREA ||.data||, DATA, ALIGN=2

                  WM__CHWinModal
                          %        8
                  WM__CHWinLast
                          %        8
