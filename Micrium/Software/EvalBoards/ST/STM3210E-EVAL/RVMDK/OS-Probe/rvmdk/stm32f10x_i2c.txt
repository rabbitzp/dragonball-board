; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\stm32f10x_i2c.o --depend=.\rvmdk\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\stm32f10x_i2c.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;110    *******************************************************************************/
;;;111    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113      /* Check the parameters */
;;;114      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;115    
;;;116      switch (*(u32*)&I2Cx)
000002  f1a04080          SUB      r0,r0,#0x40000000
000006  f5b040a8          SUBS     r0,r0,#0x5400
00000a  d00d              BEQ      |L1.40|
00000c  f5b06f80          CMP      r0,#0x400
000010  d115              BNE      |L1.62|
;;;117      {
;;;118        case I2C1_BASE:
;;;119          /* Enable I2C1 reset state */
;;;120          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;121          /* Release I2C1 from reset state */
;;;122          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
;;;123          break;
;;;124    
;;;125        case I2C2_BASE:
;;;126          /* Enable I2C2 reset state */
;;;127          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000012  2101              MOVS     r1,#1
000014  0588              LSLS     r0,r1,#22
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;128          /* Release I2C2 from reset state */
;;;129          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00001a  e8bd4010          POP      {r4,lr}
00001e  2100              MOVS     r1,#0
000020  f44f0080          MOV      r0,#0x400000
000024  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.40|
000028  2101              MOVS     r1,#1                 ;120
00002a  0548              LSLS     r0,r1,#21             ;120
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000030  e8bd4010          POP      {r4,lr}               ;122
000034  2100              MOVS     r1,#0                 ;122
000036  f44f1000          MOV      r0,#0x200000          ;122
00003a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.62|
;;;130          break;
;;;131    
;;;132        default:
;;;133          break;
;;;134      }
;;;135    }
00003e  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  I2C_Init PROC
;;;147    ******************************************************************************/
;;;148    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000040  b570              PUSH     {r4-r6,lr}
;;;149    {
000042  b086              SUB      sp,sp,#0x18
000044  4604              MOV      r4,r0
000046  460d              MOV      r5,r1
;;;150      u16 tmpreg = 0, freqrange = 0;
;;;151      u16 result = 0x04;
;;;152      u32 pclk1 = 8000000;
;;;153      RCC_ClocksTypeDef  rcc_clocks;
;;;154    
;;;155      /* Check the parameters */
;;;156      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;157      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;158      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;159      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;160      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;161      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;162      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;163    
;;;164    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;165      /* Get the I2Cx CR2 value */
;;;166      tmpreg = I2Cx->CR2;
000048  88a0              LDRH     r0,[r4,#4]
;;;167      /* Clear frequency FREQ[5:0] bits */
;;;168      tmpreg &= CR2_FREQ_Reset;
00004a  f020063f          BIC      r6,r0,#0x3f
;;;169      /* Get pclk1 frequency value */
;;;170      RCC_GetClocksFreq(&rcc_clocks);
00004e  a801              ADD      r0,sp,#4
000050  f7fffffe          BL       RCC_GetClocksFreq
;;;171      pclk1 = rcc_clocks.PCLK1_Frequency;
000054  9803              LDR      r0,[sp,#0xc]
;;;172      /* Set frequency bits depending on pclk1 value */
;;;173      freqrange = (u16)(pclk1 / 1000000);
000056  49ca              LDR      r1,|L1.896|
000058  fbb0f1f1          UDIV     r1,r0,r1
00005c  b289              UXTH     r1,r1
;;;174      tmpreg |= freqrange;
00005e  ea460201          ORR      r2,r6,r1
;;;175      /* Write to I2Cx CR2 */
;;;176      I2Cx->CR2 = tmpreg;
000062  80a2              STRH     r2,[r4,#4]
;;;177    
;;;178    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;179      /* Disable the selected I2C peripheral to configure TRISE */
;;;180      I2Cx->CR1 &= CR1_PE_Reset;
000064  8822              LDRH     r2,[r4,#0]
000066  f0220201          BIC      r2,r2,#1
00006a  8022              STRH     r2,[r4,#0]
;;;181    
;;;182      /* Reset tmpreg value */
;;;183      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;184      tmpreg = 0;
;;;185    
;;;186      /* Configure speed in standard mode */
;;;187      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
00006c  4bc5              LDR      r3,|L1.900|
00006e  68ea              LDR      r2,[r5,#0xc]
000070  429a              CMP      r2,r3
000072  d809              BHI      |L1.136|
;;;188      {
;;;189        /* Standard mode speed calculate */
;;;190        result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000074  0052              LSLS     r2,r2,#1
000076  fbb0f0f2          UDIV     r0,r0,r2
00007a  b280              UXTH     r0,r0
;;;191        /* Test if CCR value is under 0x4*/
;;;192        if (result < 0x04)
00007c  2804              CMP      r0,#4
00007e  d200              BCS      |L1.130|
;;;193        {
;;;194          /* Set minimum allowed value */
;;;195          result = 0x04;  
000080  2004              MOVS     r0,#4
                  |L1.130|
;;;196        }
;;;197        /* Set speed value for standard mode */
;;;198        tmpreg |= result;	  
;;;199        /* Set Maximum Rise Time for standard mode */
;;;200        I2Cx->TRISE = freqrange + 1; 
000082  1c49              ADDS     r1,r1,#1
000084  8421              STRH     r1,[r4,#0x20]
000086  e024              B        |L1.210|
                  |L1.136|
;;;201      }
;;;202      /* Configure speed in fast mode */
;;;203      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;204      {
;;;205        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000088  886b              LDRH     r3,[r5,#2]
00008a  f5a34c3f          SUB      r12,r3,#0xbf00
00008e  f1bc0cff          SUBS     r12,r12,#0xff
000092  d105              BNE      |L1.160|
;;;206        {
;;;207          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;208          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
000094  eb020242          ADD      r2,r2,r2,LSL #1
000098  fbb0f0f2          UDIV     r0,r0,r2
00009c  b280              UXTH     r0,r0
00009e  e008              B        |L1.178|
                  |L1.160|
;;;209        }
;;;210        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;211        {
;;;212          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;213          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
0000a0  eb0203c2          ADD      r3,r2,r2,LSL #3
0000a4  eb031202          ADD      r2,r3,r2,LSL #4
0000a8  fbb0f0f2          UDIV     r0,r0,r2
0000ac  b280              UXTH     r0,r0
;;;214          /* Set DUTY bit */
;;;215          result |= I2C_DutyCycle_16_9;
0000ae  f4404080          ORR      r0,r0,#0x4000
                  |L1.178|
;;;216        }
;;;217        /* Test if CCR value is under 0x1*/
;;;218        if ((result & CCR_CCR_Set) == 0)
0000b2  0502              LSLS     r2,r0,#20
0000b4  0d12              LSRS     r2,r2,#20
0000b6  d101              BNE      |L1.188|
;;;219        {
;;;220          /* Set minimum allowed value */
;;;221          result |= (u16)0x0001;  
0000b8  f0400001          ORR      r0,r0,#1
                  |L1.188|
;;;222        }
;;;223        /* Set speed value and set F/S bit for fast mode */
;;;224        tmpreg |= result | CCR_FS_Set;
0000bc  f4404000          ORR      r0,r0,#0x8000
;;;225        /* Set Maximum Rise Time for fast mode */
;;;226        I2Cx->TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
0000c0  f44f7296          MOV      r2,#0x12c
0000c4  4351              MULS     r1,r2,r1
0000c6  f44f727a          MOV      r2,#0x3e8
0000ca  fbb1f1f2          UDIV     r1,r1,r2
0000ce  1c49              ADDS     r1,r1,#1
0000d0  8421              STRH     r1,[r4,#0x20]
                  |L1.210|
;;;227      }
;;;228      /* Write to I2Cx CCR */
;;;229      I2Cx->CCR = tmpreg;
0000d2  83a0              STRH     r0,[r4,#0x1c]
;;;230    
;;;231      /* Enable the selected I2C peripheral */
;;;232      I2Cx->CR1 |= CR1_PE_Set;
0000d4  8820              LDRH     r0,[r4,#0]
0000d6  f0400001          ORR      r0,r0,#1
0000da  8020              STRH     r0,[r4,#0]
;;;233    
;;;234    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;235      /* Get the I2Cx CR1 value */
;;;236      tmpreg = I2Cx->CR1;
0000dc  8820              LDRH     r0,[r4,#0]
;;;237      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;238      tmpreg &= CR1_CLEAR_Mask;
0000de  f020000a          BIC      r0,r0,#0xa
0000e2  f4206080          BIC      r0,r0,#0x400
;;;239      /* Configure I2Cx: mode and acknowledgement */
;;;240      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;241      /* Set ACK bit according to I2C_Ack value */
;;;242      tmpreg |= (u16)((u32)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000e6  8829              LDRH     r1,[r5,#0]
0000e8  88ea              LDRH     r2,[r5,#6]
0000ea  4311              ORRS     r1,r1,r2
0000ec  4308              ORRS     r0,r0,r1
;;;243      /* Write to I2Cx CR1 */
;;;244      I2Cx->CR1 = tmpreg;
0000ee  8020              STRH     r0,[r4,#0]
;;;245    
;;;246    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;247      /* Set I2Cx Own Address1 and acknowledged address */
;;;248      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000f0  8928              LDRH     r0,[r5,#8]
0000f2  88a9              LDRH     r1,[r5,#4]
0000f4  4308              ORRS     r0,r0,r1
0000f6  8120              STRH     r0,[r4,#8]
;;;249    }
0000f8  b006              ADD      sp,sp,#0x18
0000fa  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP

                  I2C_StructInit PROC
;;;258    *******************************************************************************/
;;;259    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
0000fc  2100              MOVS     r1,#0
;;;260    {
;;;261    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;262      /* Initialize the I2C_Mode member */
;;;263      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
0000fe  8001              STRH     r1,[r0,#0]
;;;264    
;;;265      /* Initialize the I2C_DutyCycle member */
;;;266      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
000100  f64b72ff          MOV      r2,#0xbfff
000104  8042              STRH     r2,[r0,#2]
;;;267    
;;;268      /* Initialize the I2C_OwnAddress1 member */
;;;269      I2C_InitStruct->I2C_OwnAddress1 = 0;
000106  8081              STRH     r1,[r0,#4]
;;;270    
;;;271      /* Initialize the I2C_Ack member */
;;;272      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000108  80c1              STRH     r1,[r0,#6]
;;;273    
;;;274      /* Initialize the I2C_AcknowledgedAddress member */
;;;275      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00010a  f44f4180          MOV      r1,#0x4000
00010e  8101              STRH     r1,[r0,#8]
;;;276    
;;;277      /* initialize the I2C_ClockSpeed member */
;;;278      I2C_InitStruct->I2C_ClockSpeed = 5000;
000110  f2413188          MOV      r1,#0x1388
000114  60c1              STR      r1,[r0,#0xc]
;;;279    }
000116  4770              BX       lr
;;;280    
                          ENDP

                  I2C_Cmd PROC
;;;289    *******************************************************************************/
;;;290    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000118  b121              CBZ      r1,|L1.292|
;;;291    {
;;;292      /* Check the parameters */
;;;293      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;294      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;295    
;;;296      if (NewState != DISABLE)
;;;297      {
;;;298        /* Enable the selected I2C peripheral */
;;;299        I2Cx->CR1 |= CR1_PE_Set;
00011a  8801              LDRH     r1,[r0,#0]
00011c  f0410101          ORR      r1,r1,#1
000120  8001              STRH     r1,[r0,#0]
;;;300      }
;;;301      else
;;;302      {
;;;303        /* Disable the selected I2C peripheral */
;;;304        I2Cx->CR1 &= CR1_PE_Reset;
;;;305      }
;;;306    }
000122  4770              BX       lr
                  |L1.292|
000124  8801              LDRH     r1,[r0,#0]            ;304
000126  f0210101          BIC      r1,r1,#1              ;304
00012a  8001              STRH     r1,[r0,#0]            ;304
00012c  4770              BX       lr
;;;307    
                          ENDP

                  I2C_DMACmd PROC
;;;316    *******************************************************************************/
;;;317    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00012e  b121              CBZ      r1,|L1.314|
;;;318    {
;;;319      /* Check the parameters */
;;;320      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;321      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;322    
;;;323      if (NewState != DISABLE)
;;;324      {
;;;325        /* Enable the selected I2C DMA requests */
;;;326        I2Cx->CR2 |= CR2_DMAEN_Set;
000130  8881              LDRH     r1,[r0,#4]
000132  f4416100          ORR      r1,r1,#0x800
000136  8081              STRH     r1,[r0,#4]
;;;327      }
;;;328      else
;;;329      {
;;;330        /* Disable the selected I2C DMA requests */
;;;331        I2Cx->CR2 &= CR2_DMAEN_Reset;
;;;332      }
;;;333    }
000138  4770              BX       lr
                  |L1.314|
00013a  8881              LDRH     r1,[r0,#4]            ;331
00013c  f4216100          BIC      r1,r1,#0x800          ;331
000140  8081              STRH     r1,[r0,#4]            ;331
000142  4770              BX       lr
;;;334    
                          ENDP

                  I2C_DMALastTransferCmd PROC
;;;343    *******************************************************************************/
;;;344    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000144  b121              CBZ      r1,|L1.336|
;;;345    {
;;;346      /* Check the parameters */
;;;347      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;348      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;349    
;;;350      if (NewState != DISABLE)
;;;351      {
;;;352        /* Next DMA transfer is the last transfer */
;;;353        I2Cx->CR2 |= CR2_LAST_Set;
000146  8881              LDRH     r1,[r0,#4]
000148  f4415180          ORR      r1,r1,#0x1000
00014c  8081              STRH     r1,[r0,#4]
;;;354      }
;;;355      else
;;;356      {
;;;357        /* Next DMA transfer is not the last transfer */
;;;358        I2Cx->CR2 &= CR2_LAST_Reset;
;;;359      }
;;;360    }
00014e  4770              BX       lr
                  |L1.336|
000150  8881              LDRH     r1,[r0,#4]            ;358
000152  f4215180          BIC      r1,r1,#0x1000         ;358
000156  8081              STRH     r1,[r0,#4]            ;358
000158  4770              BX       lr
;;;361    
                          ENDP

                  I2C_GenerateSTART PROC
;;;370    *******************************************************************************/
;;;371    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
00015a  b121              CBZ      r1,|L1.358|
;;;372    {
;;;373      /* Check the parameters */
;;;374      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;375      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;376    
;;;377      if (NewState != DISABLE)
;;;378      {
;;;379        /* Generate a START condition */
;;;380        I2Cx->CR1 |= CR1_START_Set;
00015c  8801              LDRH     r1,[r0,#0]
00015e  f4417180          ORR      r1,r1,#0x100
000162  8001              STRH     r1,[r0,#0]
;;;381      }
;;;382      else
;;;383      {
;;;384        /* Disable the START condition generation */
;;;385        I2Cx->CR1 &= CR1_START_Reset;
;;;386      }
;;;387    }
000164  4770              BX       lr
                  |L1.358|
000166  8801              LDRH     r1,[r0,#0]            ;385
000168  f4217180          BIC      r1,r1,#0x100          ;385
00016c  8001              STRH     r1,[r0,#0]            ;385
00016e  4770              BX       lr
;;;388    
                          ENDP

                  I2C_GenerateSTOP PROC
;;;397    *******************************************************************************/
;;;398    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000170  b121              CBZ      r1,|L1.380|
;;;399    {
;;;400      /* Check the parameters */
;;;401      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;402      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;403    
;;;404      if (NewState != DISABLE)
;;;405      {
;;;406        /* Generate a STOP condition */
;;;407        I2Cx->CR1 |= CR1_STOP_Set;
000172  8801              LDRH     r1,[r0,#0]
000174  f4417100          ORR      r1,r1,#0x200
000178  8001              STRH     r1,[r0,#0]
;;;408      }
;;;409      else
;;;410      {
;;;411        /* Disable the STOP condition generation */
;;;412        I2Cx->CR1 &= CR1_STOP_Reset;
;;;413      }
;;;414    }
00017a  4770              BX       lr
                  |L1.380|
00017c  8801              LDRH     r1,[r0,#0]            ;412
00017e  f4217100          BIC      r1,r1,#0x200          ;412
000182  8001              STRH     r1,[r0,#0]            ;412
000184  4770              BX       lr
;;;415    
                          ENDP

                  I2C_AcknowledgeConfig PROC
;;;424    *******************************************************************************/
;;;425    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000186  b121              CBZ      r1,|L1.402|
;;;426    {
;;;427      /* Check the parameters */
;;;428      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;429      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;430    
;;;431      if (NewState != DISABLE)
;;;432      {
;;;433        /* Enable the acknowledgement */
;;;434        I2Cx->CR1 |= CR1_ACK_Set;
000188  8801              LDRH     r1,[r0,#0]
00018a  f4416180          ORR      r1,r1,#0x400
00018e  8001              STRH     r1,[r0,#0]
;;;435      }
;;;436      else
;;;437      {
;;;438        /* Disable the acknowledgement */
;;;439        I2Cx->CR1 &= CR1_ACK_Reset;
;;;440      }
;;;441    }
000190  4770              BX       lr
                  |L1.402|
000192  8801              LDRH     r1,[r0,#0]            ;439
000194  f4216180          BIC      r1,r1,#0x400          ;439
000198  8001              STRH     r1,[r0,#0]            ;439
00019a  4770              BX       lr
;;;442    
                          ENDP

                  I2C_OwnAddress2Config PROC
;;;450    *******************************************************************************/
;;;451    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
00019c  8982              LDRH     r2,[r0,#0xc]
;;;452    {
;;;453      u16 tmpreg = 0;
;;;454    
;;;455      /* Check the parameters */
;;;456      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;457    
;;;458      /* Get the old register value */
;;;459      tmpreg = I2Cx->OAR2;
;;;460      /* Reset I2Cx Own address2 bit [7:1] */
;;;461      tmpreg &= OAR2_ADD2_Reset;
00019e  f02202fe          BIC      r2,r2,#0xfe
;;;462      /* Set I2Cx Own address2 */
;;;463      tmpreg |= (u16)(Address & (u16)0x00FE);
0001a2  f00101fe          AND      r1,r1,#0xfe
0001a6  4311              ORRS     r1,r1,r2
;;;464      /* Store the new register value */
;;;465      I2Cx->OAR2 = tmpreg;
0001a8  8181              STRH     r1,[r0,#0xc]
;;;466    }
0001aa  4770              BX       lr
;;;467    
                          ENDP

                  I2C_DualAddressCmd PROC
;;;476    *******************************************************************************/
;;;477    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001ac  b121              CBZ      r1,|L1.440|
;;;478    {
;;;479      /* Check the parameters */
;;;480      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;481      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;482    
;;;483      if (NewState != DISABLE)
;;;484      {
;;;485        /* Enable dual addressing mode */
;;;486        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
0001ae  8981              LDRH     r1,[r0,#0xc]
0001b0  f0410101          ORR      r1,r1,#1
0001b4  8181              STRH     r1,[r0,#0xc]
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable dual addressing mode */
;;;491        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
;;;492      }
;;;493    }
0001b6  4770              BX       lr
                  |L1.440|
0001b8  8981              LDRH     r1,[r0,#0xc]          ;491
0001ba  f0210101          BIC      r1,r1,#1              ;491
0001be  8181              STRH     r1,[r0,#0xc]          ;491
0001c0  4770              BX       lr
;;;494    
                          ENDP

                  I2C_GeneralCallCmd PROC
;;;503    *******************************************************************************/
;;;504    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001c2  b121              CBZ      r1,|L1.462|
;;;505    {
;;;506      /* Check the parameters */
;;;507      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;508      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;509    
;;;510      if (NewState != DISABLE)
;;;511      {
;;;512        /* Enable generall call */
;;;513        I2Cx->CR1 |= CR1_ENGC_Set;
0001c4  8801              LDRH     r1,[r0,#0]
0001c6  f0410140          ORR      r1,r1,#0x40
0001ca  8001              STRH     r1,[r0,#0]
;;;514      }
;;;515      else
;;;516      {
;;;517        /* Disable generall call */
;;;518        I2Cx->CR1 &= CR1_ENGC_Reset;
;;;519      }
;;;520    }
0001cc  4770              BX       lr
                  |L1.462|
0001ce  8801              LDRH     r1,[r0,#0]            ;518
0001d0  f0210140          BIC      r1,r1,#0x40           ;518
0001d4  8001              STRH     r1,[r0,#0]            ;518
0001d6  4770              BX       lr
;;;521    
                          ENDP

                  I2C_ITConfig PROC
;;;536    *******************************************************************************/
;;;537    void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
0001d8  b11a              CBZ      r2,|L1.482|
;;;538    {
;;;539      /* Check the parameters */
;;;540      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;541      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;542      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;543      
;;;544      if (NewState != DISABLE)
;;;545      {
;;;546        /* Enable the selected I2C interrupts */
;;;547        I2Cx->CR2 |= I2C_IT;
0001da  8882              LDRH     r2,[r0,#4]
0001dc  4311              ORRS     r1,r1,r2
0001de  8081              STRH     r1,[r0,#4]
;;;548      }
;;;549      else
;;;550      {
;;;551        /* Disable the selected I2C interrupts */
;;;552        I2Cx->CR2 &= (u16)~I2C_IT;
;;;553      }
;;;554    }
0001e0  4770              BX       lr
                  |L1.482|
0001e2  8882              LDRH     r2,[r0,#4]            ;552
0001e4  ea220101          BIC      r1,r2,r1              ;552
0001e8  8081              STRH     r1,[r0,#4]            ;552
0001ea  4770              BX       lr
;;;555    
                          ENDP

                  I2C_SendData PROC
;;;563    *******************************************************************************/
;;;564    void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
0001ec  8201              STRH     r1,[r0,#0x10]
;;;565    {
;;;566      /* Check the parameters */
;;;567      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;568    
;;;569      /* Write in the DR register the data to be sent */
;;;570      I2Cx->DR = Data;
;;;571    }
0001ee  4770              BX       lr
;;;572    
                          ENDP

                  I2C_ReceiveData PROC
;;;579    *******************************************************************************/
;;;580    u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
0001f0  8a00              LDRH     r0,[r0,#0x10]
;;;581    {
;;;582      /* Check the parameters */
;;;583      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;584    
;;;585      /* Return the data in the DR register */
;;;586      return (u8)I2Cx->DR;
0001f2  b2c0              UXTB     r0,r0
;;;587    }
0001f4  4770              BX       lr
;;;588    
                          ENDP

                  I2C_Send7bitAddress PROC
;;;601    *******************************************************************************/
;;;602    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
0001f6  b112              CBZ      r2,|L1.510|
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;606      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;607    
;;;608      /* Test on the direction to set/reset the read/write bit */
;;;609      if (I2C_Direction != I2C_Direction_Transmitter)
;;;610      {
;;;611        /* Set the address bit0 for read */
;;;612        Address |= OAR1_ADD0_Set;
0001f8  f0410101          ORR      r1,r1,#1
0001fc  e001              B        |L1.514|
                  |L1.510|
;;;613      }
;;;614      else
;;;615      {
;;;616        /* Reset the address bit0 for write */
;;;617        Address &= OAR1_ADD0_Reset;
0001fe  f00101fe          AND      r1,r1,#0xfe
                  |L1.514|
;;;618      }
;;;619      /* Send the address */
;;;620      I2Cx->DR = Address;
000202  8201              STRH     r1,[r0,#0x10]
;;;621    }
000204  4770              BX       lr
;;;622    
                          ENDP

                  I2C_ReadRegister PROC
;;;639    *******************************************************************************/
;;;640    u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
000206  5a40              LDRH     r0,[r0,r1]
;;;641    {
;;;642      /* Check the parameters */
;;;643      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;644      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;645    
;;;646      /* Return the selected register value */
;;;647      return (*(vu16 *)(*((vu32 *)&I2Cx) + I2C_Register));
;;;648    }
000208  4770              BX       lr
;;;649    
                          ENDP

                  I2C_SoftwareResetCmd PROC
;;;658    *******************************************************************************/
;;;659    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00020a  b121              CBZ      r1,|L1.534|
;;;660    {
;;;661      /* Check the parameters */
;;;662      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;663      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;664    
;;;665      if (NewState != DISABLE)
;;;666      {
;;;667        /* Peripheral under reset */
;;;668        I2Cx->CR1 |= CR1_SWRST_Set;
00020c  8801              LDRH     r1,[r0,#0]
00020e  f4414100          ORR      r1,r1,#0x8000
000212  8001              STRH     r1,[r0,#0]
;;;669      }
;;;670      else
;;;671      {
;;;672        /* Peripheral not under reset */
;;;673        I2Cx->CR1 &= CR1_SWRST_Reset;
;;;674      }
;;;675    }
000214  4770              BX       lr
                  |L1.534|
000216  8801              LDRH     r1,[r0,#0]            ;673
000218  f3c1010e          UBFX     r1,r1,#0,#15          ;673
00021c  8001              STRH     r1,[r0,#0]            ;673
00021e  4770              BX       lr
;;;676    
                          ENDP

                  I2C_SMBusAlertConfig PROC
;;;687    *******************************************************************************/
;;;688    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
000220  f5b15f00          CMP      r1,#0x2000
;;;689    {
;;;690      /* Check the parameters */
;;;691      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;692      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;693    
;;;694      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000224  d004              BEQ      |L1.560|
;;;695      {
;;;696        /* Drive the SMBusAlert pin Low */
;;;697        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;698      }
;;;699      else
;;;700      {
;;;701        /* Drive the SMBusAlert pin High  */
;;;702        I2Cx->CR1 &= I2C_SMBusAlert_High;
000226  8801              LDRH     r1,[r0,#0]
000228  f4215100          BIC      r1,r1,#0x2000
00022c  8001              STRH     r1,[r0,#0]
;;;703      }
;;;704    }
00022e  4770              BX       lr
                  |L1.560|
000230  8801              LDRH     r1,[r0,#0]            ;697
000232  f4415100          ORR      r1,r1,#0x2000         ;697
000236  8001              STRH     r1,[r0,#0]            ;697
000238  4770              BX       lr
;;;705    
                          ENDP

                  I2C_TransmitPEC PROC
;;;714    *******************************************************************************/
;;;715    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
00023a  b121              CBZ      r1,|L1.582|
;;;716    {
;;;717      /* Check the parameters */
;;;718      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;719      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;720    
;;;721      if (NewState != DISABLE)
;;;722      {
;;;723        /* Enable the selected I2C PEC transmission */
;;;724        I2Cx->CR1 |= CR1_PEC_Set;
00023c  8801              LDRH     r1,[r0,#0]
00023e  f4415180          ORR      r1,r1,#0x1000
000242  8001              STRH     r1,[r0,#0]
;;;725      }
;;;726      else
;;;727      {
;;;728        /* Disable the selected I2C PEC transmission */
;;;729        I2Cx->CR1 &= CR1_PEC_Reset;
;;;730      }
;;;731    }
000244  4770              BX       lr
                  |L1.582|
000246  8801              LDRH     r1,[r0,#0]            ;729
000248  f4215180          BIC      r1,r1,#0x1000         ;729
00024c  8001              STRH     r1,[r0,#0]            ;729
00024e  4770              BX       lr
;;;732    
                          ENDP

                  I2C_PECPositionConfig PROC
;;;745    *******************************************************************************/
;;;746    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
000250  f5b16f00          CMP      r1,#0x800
;;;747    {
;;;748      /* Check the parameters */
;;;749      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;750      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;751    
;;;752      if (I2C_PECPosition == I2C_PECPosition_Next)
000254  d004              BEQ      |L1.608|
;;;753      {
;;;754        /* Next byte in shift register is PEC */
;;;755        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;756      }
;;;757      else
;;;758      {
;;;759        /* Current byte in shift register is PEC */
;;;760        I2Cx->CR1 &= I2C_PECPosition_Current;
000256  8801              LDRH     r1,[r0,#0]
000258  f4216100          BIC      r1,r1,#0x800
00025c  8001              STRH     r1,[r0,#0]
;;;761      }
;;;762    }
00025e  4770              BX       lr
                  |L1.608|
000260  8801              LDRH     r1,[r0,#0]            ;755
000262  f4416100          ORR      r1,r1,#0x800          ;755
000266  8001              STRH     r1,[r0,#0]            ;755
000268  4770              BX       lr
;;;763    
                          ENDP

                  I2C_CalculatePEC PROC
;;;773    *******************************************************************************/
;;;774    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
00026a  b121              CBZ      r1,|L1.630|
;;;775    {
;;;776      /* Check the parameters */
;;;777      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;778      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;779    
;;;780      if (NewState != DISABLE)
;;;781      {
;;;782        /* Enable the selected I2C PEC calculation */
;;;783        I2Cx->CR1 |= CR1_ENPEC_Set;
00026c  8801              LDRH     r1,[r0,#0]
00026e  f0410120          ORR      r1,r1,#0x20
000272  8001              STRH     r1,[r0,#0]
;;;784      }
;;;785      else
;;;786      {
;;;787        /* Disable the selected I2C PEC calculation */
;;;788        I2Cx->CR1 &= CR1_ENPEC_Reset;
;;;789      }
;;;790    }
000274  4770              BX       lr
                  |L1.630|
000276  8801              LDRH     r1,[r0,#0]            ;788
000278  f0210120          BIC      r1,r1,#0x20           ;788
00027c  8001              STRH     r1,[r0,#0]            ;788
00027e  4770              BX       lr
;;;791    
                          ENDP

                  I2C_GetPEC PROC
;;;798    *******************************************************************************/
;;;799    u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
000280  8b00              LDRH     r0,[r0,#0x18]
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;803    
;;;804      /* Return the selected I2C PEC value */
;;;805      return ((I2Cx->SR2) >> 8);
000282  0a00              LSRS     r0,r0,#8
;;;806    }
000284  4770              BX       lr
;;;807    
                          ENDP

                  I2C_ARPCmd PROC
;;;816    *******************************************************************************/
;;;817    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000286  b121              CBZ      r1,|L1.658|
;;;818    {
;;;819      /* Check the parameters */
;;;820      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;821      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;822    
;;;823      if (NewState != DISABLE)
;;;824      {
;;;825        /* Enable the selected I2C ARP */
;;;826        I2Cx->CR1 |= CR1_ENARP_Set;
000288  8801              LDRH     r1,[r0,#0]
00028a  f0410110          ORR      r1,r1,#0x10
00028e  8001              STRH     r1,[r0,#0]
;;;827      }
;;;828      else
;;;829      {
;;;830        /* Disable the selected I2C ARP */
;;;831        I2Cx->CR1 &= CR1_ENARP_Reset;
;;;832      }
;;;833    }
000290  4770              BX       lr
                  |L1.658|
000292  8801              LDRH     r1,[r0,#0]            ;831
000294  f0210110          BIC      r1,r1,#0x10           ;831
000298  8001              STRH     r1,[r0,#0]            ;831
00029a  4770              BX       lr
;;;834    
                          ENDP

                  I2C_StretchClockCmd PROC
;;;843    *******************************************************************************/
;;;844    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00029c  b121              CBZ      r1,|L1.680|
;;;845    {
;;;846      /* Check the parameters */
;;;847      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;848      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;849    
;;;850      if (NewState == DISABLE)
;;;851      {
;;;852        /* Enable the selected I2C Clock stretching */
;;;853        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
;;;854      }
;;;855      else
;;;856      {
;;;857        /* Disable the selected I2C Clock stretching */
;;;858        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
00029e  8801              LDRH     r1,[r0,#0]
0002a0  f0210180          BIC      r1,r1,#0x80
0002a4  8001              STRH     r1,[r0,#0]
;;;859      }
;;;860    }
0002a6  4770              BX       lr
                  |L1.680|
0002a8  8801              LDRH     r1,[r0,#0]            ;853
0002aa  f0410180          ORR      r1,r1,#0x80           ;853
0002ae  8001              STRH     r1,[r0,#0]            ;853
0002b0  4770              BX       lr
;;;861    
                          ENDP

                  I2C_FastModeDutyCycleConfig PROC
;;;872    *******************************************************************************/
;;;873    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
0002b2  f5b14f80          CMP      r1,#0x4000
;;;874    {
;;;875      /* Check the parameters */
;;;876      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;877      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;878    
;;;879      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
0002b6  d004              BEQ      |L1.706|
;;;880      {
;;;881        /* I2C fast mode Tlow/Thigh=2 */
;;;882        I2Cx->CCR &= I2C_DutyCycle_2;
0002b8  8b81              LDRH     r1,[r0,#0x1c]
0002ba  f4214180          BIC      r1,r1,#0x4000
0002be  8381              STRH     r1,[r0,#0x1c]
;;;883      }
;;;884      else
;;;885      {
;;;886        /* I2C fast mode Tlow/Thigh=16/9 */
;;;887        I2Cx->CCR |= I2C_DutyCycle_16_9;
;;;888      }
;;;889    }
0002c0  4770              BX       lr
                  |L1.706|
0002c2  8b81              LDRH     r1,[r0,#0x1c]         ;887
0002c4  f4414180          ORR      r1,r1,#0x4000         ;887
0002c8  8381              STRH     r1,[r0,#0x1c]         ;887
0002ca  4770              BX       lr
;;;890    
                          ENDP

                  I2C_GetLastEvent PROC
;;;897    *******************************************************************************/
;;;898    u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
0002cc  8a81              LDRH     r1,[r0,#0x14]
;;;899    {
;;;900      u32 lastevent = 0;
;;;901      u32 flag1 = 0, flag2 = 0;
;;;902    
;;;903      /* Check the parameters */
;;;904      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;905    
;;;906      /* Read the I2Cx status register */
;;;907      flag1 = I2Cx->SR1;
;;;908      flag2 = I2Cx->SR2;
0002ce  8b00              LDRH     r0,[r0,#0x18]
;;;909      flag2 = flag2 << 16;
0002d0  0400              LSLS     r0,r0,#16
;;;910    
;;;911      /* Get the last event value from I2C status register */
;;;912      lastevent = (flag1 | flag2) & FLAG_Mask;
0002d2  4308              ORRS     r0,r0,r1
0002d4  f020407f          BIC      r0,r0,#0xff000000
;;;913    
;;;914      /* Return status */
;;;915      return lastevent;
;;;916    }
0002d8  4770              BX       lr
;;;917    
                          ENDP

                  I2C_CheckEvent PROC
;;;939    *******************************************************************************/
;;;940    ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
0002da  2200              MOVS     r2,#0
;;;941    {
;;;942      u32 lastevent = 0;
;;;943      u32 flag1 = 0, flag2 = 0;
;;;944      ErrorStatus status = ERROR;
;;;945    
;;;946      /* Check the parameters */
;;;947      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;948      assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;949    
;;;950      /* Read the I2Cx status register */
;;;951      flag1 = I2Cx->SR1;
0002dc  8a83              LDRH     r3,[r0,#0x14]
;;;952      flag2 = I2Cx->SR2;
0002de  8b00              LDRH     r0,[r0,#0x18]
;;;953      flag2 = flag2 << 16;
0002e0  0400              LSLS     r0,r0,#16
;;;954    
;;;955      /* Get the last event value from I2C status register */
;;;956      lastevent = (flag1 | flag2) & FLAG_Mask;
0002e2  4318              ORRS     r0,r0,r3
0002e4  f020407f          BIC      r0,r0,#0xff000000
;;;957    
;;;958      /* Check whether the last event is equal to I2C_EVENT */
;;;959      if (lastevent == I2C_EVENT )
0002e8  4288              CMP      r0,r1
0002ea  d100              BNE      |L1.750|
;;;960      {
;;;961        /* SUCCESS: last event is equal to I2C_EVENT */
;;;962        status = SUCCESS;
0002ec  2201              MOVS     r2,#1
                  |L1.750|
;;;963      }
;;;964      else
;;;965      {
;;;966        /* ERROR: last event is different from I2C_EVENT */
;;;967        status = ERROR;
;;;968      }
;;;969    
;;;970      /* Return status */
;;;971      return status;
0002ee  4610              MOV      r0,r2
;;;972    }
0002f0  4770              BX       lr
;;;973    
                          ENDP

                  I2C_GetFlagStatus PROC
;;;1004   *******************************************************************************/
;;;1005   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
0002f2  2200              MOVS     r2,#0
;;;1006   {
;;;1007     FlagStatus bitstatus = RESET;
;;;1008     u32 i2cstatus = 0;
;;;1009     u32 flag1 = 0, flag2 = 0;
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1013     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1014   
;;;1015     /* Read the I2Cx status register */
;;;1016     flag1 = I2Cx->SR1;
0002f4  8a83              LDRH     r3,[r0,#0x14]
;;;1017     flag2 = I2Cx->SR2;
0002f6  8b00              LDRH     r0,[r0,#0x18]
;;;1018     flag2 = (flag2 & FLAG_Mask) << 16;
0002f8  0400              LSLS     r0,r0,#16
;;;1019   
;;;1020     /* Get the I2C status value */
;;;1021     i2cstatus = flag1 | flag2;
0002fa  4318              ORRS     r0,r0,r3
;;;1022   
;;;1023     /* Get bit[23:0] of the flag */
;;;1024     I2C_FLAG &= FLAG_Mask;
0002fc  f021417f          BIC      r1,r1,#0xff000000
;;;1025   
;;;1026     /* Check the status of the specified I2C flag */
;;;1027     if ((i2cstatus & I2C_FLAG) != (u32)RESET)
000300  4208              TST      r0,r1
000302  d000              BEQ      |L1.774|
;;;1028     {
;;;1029       /* I2C_FLAG is set */
;;;1030       bitstatus = SET;
000304  2201              MOVS     r2,#1
                  |L1.774|
;;;1031     }
;;;1032     else
;;;1033     {
;;;1034       /* I2C_FLAG is reset */
;;;1035       bitstatus = RESET;
;;;1036     }
;;;1037     /* Return the I2C_FLAG status */
;;;1038     return  bitstatus;
000306  4610              MOV      r0,r2
;;;1039   }
000308  4770              BX       lr
;;;1040   
                          ENDP

                  I2C_ClearFlag PROC
;;;1062   *******************************************************************************/
;;;1063   void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
00030a  f021427f          BIC      r2,r1,#0xff000000
;;;1064   {
;;;1065     u32 flagpos = 0;
;;;1066     u32 flagindex = 0;
;;;1067   
;;;1068     /* Check the parameters */
;;;1069     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1070     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1071   
;;;1072     /* Get the I2C flag position */
;;;1073     flagpos = I2C_FLAG & FLAG_Mask;
;;;1074   
;;;1075     /* Get the I2C flag index */
;;;1076     flagindex = I2C_FLAG >> 28;
00030e  0f09              LSRS     r1,r1,#28
;;;1077   
;;;1078     /* Clear the flag by writing 0 */
;;;1079     if (flagindex == 1)
000310  2901              CMP      r1,#1
000312  d006              BEQ      |L1.802|
;;;1080     {
;;;1081       /* Clear the selected I2C flag */
;;;1082       I2Cx->SR1 = (u16)~flagpos;
;;;1083     }
;;;1084     /* Flags that need a read of the SR1 register to be cleared */
;;;1085     else if (flagindex == 2)
000314  2902              CMP      r1,#2
000316  d007              BEQ      |L1.808|
;;;1086     {
;;;1087       /* Read the SR1 register */
;;;1088       (void)I2Cx->SR1;
;;;1089     }
;;;1090     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1091     else if (flagindex == 6)
000318  2906              CMP      r1,#6
00031a  d007              BEQ      |L1.812|
;;;1092     {
;;;1093       /* Read the SR1 register */
;;;1094       (void)I2Cx->SR1;
;;;1095   
;;;1096       /* Write on the CR1 register */
;;;1097       I2Cx->CR1 |= CR1_PE_Set;
;;;1098     }
;;;1099     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1100     else /*flagindex == 0xA*/
;;;1101     {
;;;1102       /* Read the SR1 register */
;;;1103       (void)I2Cx->SR1;
00031c  8a81              LDRH     r1,[r0,#0x14]
;;;1104   
;;;1105       /* Read the SR2 register */
;;;1106       (void)I2Cx->SR2;
00031e  8b00              LDRH     r0,[r0,#0x18]
;;;1107     }
;;;1108   }
000320  4770              BX       lr
                  |L1.802|
000322  43d1              MVNS     r1,r2                 ;1082
000324  8281              STRH     r1,[r0,#0x14]         ;1082
000326  4770              BX       lr
                  |L1.808|
000328  8a80              LDRH     r0,[r0,#0x14]         ;1088
00032a  4770              BX       lr
                  |L1.812|
00032c  8a81              LDRH     r1,[r0,#0x14]         ;1094
00032e  8801              LDRH     r1,[r0,#0]            ;1097
000330  f0410101          ORR      r1,r1,#1              ;1097
000334  8001              STRH     r1,[r0,#0]            ;1097
000336  4770              BX       lr
;;;1109   
                          ENDP

                  I2C_GetITStatus PROC
;;;1133   *******************************************************************************/
;;;1134   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
000338  2200              MOVS     r2,#0
;;;1135   {
;;;1136     ITStatus bitstatus = RESET;
;;;1137     u32 i2cstatus = 0;
;;;1138     u32 flag1 = 0, flag2 = 0;
;;;1139   
;;;1140     /* Check the parameters */
;;;1141     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1142     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1143   
;;;1144     /* Read the I2Cx status register */
;;;1145     flag1 = I2Cx->SR1;
00033a  8a83              LDRH     r3,[r0,#0x14]
;;;1146     flag2 = I2Cx->SR2;
00033c  8b00              LDRH     r0,[r0,#0x18]
;;;1147     flag2 = (flag2 & FLAG_Mask) << 16;
00033e  0400              LSLS     r0,r0,#16
;;;1148   
;;;1149     /* Get the I2C status value */
;;;1150     i2cstatus = flag1 | flag2;
000340  4318              ORRS     r0,r0,r3
;;;1151   
;;;1152     /* Get bit[23:0] of the flag */
;;;1153     I2C_IT &= FLAG_Mask;
000342  f021417f          BIC      r1,r1,#0xff000000
;;;1154   
;;;1155     /* Check the status of the specified I2C flag */
;;;1156     if ((i2cstatus & I2C_IT) != (u32)RESET)
000346  4208              TST      r0,r1
000348  d000              BEQ      |L1.844|
;;;1157     {
;;;1158       /* I2C_IT is set */
;;;1159       bitstatus = SET;
00034a  2201              MOVS     r2,#1
                  |L1.844|
;;;1160     }
;;;1161     else
;;;1162     {
;;;1163       /* I2C_IT is reset */
;;;1164       bitstatus = RESET;
;;;1165     }
;;;1166     /* Return the I2C_IT status */
;;;1167     return  bitstatus;
00034c  4610              MOV      r0,r2
;;;1168   }
00034e  4770              BX       lr
;;;1169   
                          ENDP

                  I2C_ClearITPendingBit PROC
;;;1191   *******************************************************************************/
;;;1192   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
000350  f021427f          BIC      r2,r1,#0xff000000
;;;1193   {
;;;1194     u32 flagpos = 0;
;;;1195     u32 flagindex = 0;
;;;1196   
;;;1197     /* Check the parameters */
;;;1198     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1199     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1200   
;;;1201     /* Get the I2C flag position */
;;;1202     flagpos = I2C_IT & FLAG_Mask;
;;;1203   
;;;1204     /* Get the I2C flag index */
;;;1205     flagindex = I2C_IT >> 28;
000354  0f09              LSRS     r1,r1,#28
;;;1206   
;;;1207     /* Clear the flag by writing 0 */
;;;1208     if (flagindex == 1)
000356  2901              CMP      r1,#1
000358  d006              BEQ      |L1.872|
;;;1209     {
;;;1210       /* Clear the selected I2C flag */
;;;1211       I2Cx->SR1 = (u16)~flagpos;
;;;1212     }
;;;1213     /* Flags that need a read of the SR1 register to be cleared */
;;;1214     else if (flagindex == 2)
00035a  2902              CMP      r1,#2
00035c  d007              BEQ      |L1.878|
;;;1215     {
;;;1216       /* Read the SR1 register */
;;;1217       (void)I2Cx->SR1;
;;;1218     }
;;;1219     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1220     else if (flagindex == 6)
00035e  2906              CMP      r1,#6
000360  d007              BEQ      |L1.882|
;;;1221     {
;;;1222       /* Read the SR1 register */
;;;1223       (void)I2Cx->SR1;
;;;1224   
;;;1225       /* Write on the CR1 register */
;;;1226       I2Cx->CR1 |= CR1_PE_Set;
;;;1227     }
;;;1228     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1229     else /*flagindex == 0xA*/
;;;1230     {
;;;1231       /* Read the SR1 register */
;;;1232       (void)I2Cx->SR1;
000362  8a81              LDRH     r1,[r0,#0x14]
;;;1233   
;;;1234       /* Read the SR2 register */
;;;1235       (void)I2Cx->SR2;
000364  8b00              LDRH     r0,[r0,#0x18]
;;;1236     }
;;;1237   }
000366  4770              BX       lr
                  |L1.872|
000368  43d1              MVNS     r1,r2                 ;1211
00036a  8281              STRH     r1,[r0,#0x14]         ;1211
00036c  4770              BX       lr
                  |L1.878|
00036e  8a80              LDRH     r0,[r0,#0x14]         ;1217
000370  4770              BX       lr
                  |L1.882|
000372  8a81              LDRH     r1,[r0,#0x14]         ;1223
000374  8801              LDRH     r1,[r0,#0]            ;1226
000376  f0410101          ORR      r1,r1,#1              ;1226
00037a  8001              STRH     r1,[r0,#0]            ;1226
00037c  4770              BX       lr
;;;1238   
                          ENDP

00037e  0000              DCW      0x0000
                  |L1.896|
                          DCD      0x000f4240
                  |L1.900|
                          DCD      0x000186a0
