; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\stm32f10x_fsmc.o --depend=.\rvmdk\stm32f10x_fsmc.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\stm32f10x_fsmc.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_fsmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMDeInit PROC
;;;54     *******************************************************************************/
;;;55     void FSMC_NORSRAMDeInit(u32 FSMC_Bank)
000000  f04f4220          MOV      r2,#0xa0000000
;;;56     {
;;;57       /* Check the parameter */
;;;58       assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;59       
;;;60       /* FSMC_Bank1_NORSRAM1 */
;;;61       if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;62       {
;;;63         FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;64       }
;;;65       /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;66       else
;;;67       {   
;;;68         FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000004  eb020180          ADD      r1,r2,r0,LSL #2
000008  b150              CBZ      r0,|L1.32|
00000a  f24303d2          MOV      r3,#0x30d2
00000e  600b              STR      r3,[r1,#0]
                  |L1.16|
;;;69       }
;;;70     
;;;71       FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
000010  1c40              ADDS     r0,r0,#1
000012  f06f4370          MVN      r3,#0xf0000000
000016  f8423020          STR      r3,[r2,r0,LSL #2]
;;;72       FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
00001a  f8c13104          STR      r3,[r1,#0x104]
;;;73     }
00001e  4770              BX       lr
                  |L1.32|
000020  f24303db          MOV      r3,#0x30db            ;63
000024  6013              STR      r3,[r2,#0]            ;63
000026  e7f3              B        |L1.16|
;;;74     
                          ENDP

                  FSMC_NANDDeInit PROC
;;;85     *******************************************************************************/
;;;86     void FSMC_NANDDeInit(u32 FSMC_Bank)
000028  2340              MOVS     r3,#0x40
;;;87     {
;;;88       /* Check the parameter */
;;;89       assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;90       
;;;91       if(FSMC_Bank == FSMC_Bank2_NAND)
;;;92       {
;;;93         /* Set the FSMC_Bank2 registers to their reset values */
;;;94         FSMC_Bank2->PCR2 = 0x00000018;
00002a  f04f0c18          MOV      r12,#0x18
00002e  f04f4120          MOV      r1,#0xa0000000
;;;95         FSMC_Bank2->SR2 = 0x00000040;
;;;96         FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
000032  f04f32fc          MOV      r2,#0xfcfcfcfc
000036  2810              CMP      r0,#0x10              ;91
000038  d008              BEQ      |L1.76|
;;;97         FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;98       }
;;;99       /* FSMC_Bank3_NAND */  
;;;100      else
;;;101      {
;;;102        /* Set the FSMC_Bank3 registers to their reset values */
;;;103        FSMC_Bank3->PCR3 = 0x00000018;
00003a  f8c1c080          STR      r12,[r1,#0x80]
;;;104        FSMC_Bank3->SR3 = 0x00000040;
00003e  f8c13084          STR      r3,[r1,#0x84]
;;;105        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000042  f8c12088          STR      r2,[r1,#0x88]
;;;106        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
000046  f8c1208c          STR      r2,[r1,#0x8c]
;;;107      }  
;;;108    }
00004a  4770              BX       lr
                  |L1.76|
00004c  f8c1c060          STR      r12,[r1,#0x60]        ;94
000050  664b              STR      r3,[r1,#0x64]         ;95
000052  668a              STR      r2,[r1,#0x68]         ;96
000054  66ca              STR      r2,[r1,#0x6c]         ;97
000056  4770              BX       lr
;;;109    
                          ENDP

                  FSMC_PCCARDDeInit PROC
;;;117    *******************************************************************************/
;;;118    void FSMC_PCCARDDeInit(void)
000058  48fd              LDR      r0,|L1.1104|
;;;119    {
;;;120      /* Set the FSMC_Bank4 registers to their reset values */
;;;121      FSMC_Bank4->PCR4 = 0x00000018; 
00005a  2118              MOVS     r1,#0x18
00005c  6001              STR      r1,[r0,#0]
;;;122      FSMC_Bank4->SR4 = 0x00000000;	
00005e  f04f0100          MOV      r1,#0
000062  6041              STR      r1,[r0,#4]
;;;123      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
000064  f04f31fc          MOV      r1,#0xfcfcfcfc
000068  6081              STR      r1,[r0,#8]
;;;124      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
00006a  60c1              STR      r1,[r0,#0xc]
;;;125      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
00006c  6101              STR      r1,[r0,#0x10]
;;;126    }
00006e  4770              BX       lr
;;;127    
                          ENDP

                  FSMC_NORSRAMInit PROC
;;;137    *******************************************************************************/
;;;138    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000070  b410              PUSH     {r4}
;;;139    { 
;;;140      /* Check the parameters */
;;;141      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;142      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;143      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;144      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;145      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;146      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;147      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;148      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;149      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;150      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;151      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;152      assert_param(IS_FSMC_ASYNC_WAIT(FSMC_NORSRAMInitStruct->FSMC_AsyncWait));
;;;153      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;154      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;155      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;156      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;157      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;158      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;159      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;160      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;161      
;;;162      /* Bank1 NOR/SRAM control register configuration */ 
;;;163      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000072  6882              LDR      r2,[r0,#8]
000074  6841              LDR      r1,[r0,#4]
000076  6903              LDR      r3,[r0,#0x10]
000078  4311              ORRS     r1,r1,r2
00007a  68c2              LDR      r2,[r0,#0xc]
00007c  431a              ORRS     r2,r2,r3
00007e  4311              ORRS     r1,r1,r2
000080  6942              LDR      r2,[r0,#0x14]
000082  6803              LDR      r3,[r0,#0]
000084  4311              ORRS     r1,r1,r2
000086  6982              LDR      r2,[r0,#0x18]
000088  4311              ORRS     r1,r1,r2
00008a  69c2              LDR      r2,[r0,#0x1c]
00008c  4311              ORRS     r1,r1,r2
00008e  6a02              LDR      r2,[r0,#0x20]
000090  4311              ORRS     r1,r1,r2
000092  6a42              LDR      r2,[r0,#0x24]
000094  4311              ORRS     r1,r1,r2
000096  6a82              LDR      r2,[r0,#0x28]
000098  4311              ORRS     r1,r1,r2
00009a  6ac2              LDR      r2,[r0,#0x2c]
00009c  4311              ORRS     r1,r1,r2
00009e  6b02              LDR      r2,[r0,#0x30]
0000a0  4311              ORRS     r1,r1,r2
0000a2  f04f4220          MOV      r2,#0xa0000000
0000a6  f8421023          STR      r1,[r2,r3,LSL #2]
;;;164                (u32)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;165                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;166                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;167                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;168                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;169                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;170                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;171                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;172                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;173                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;174                FSMC_NORSRAMInitStruct->FSMC_AsyncWait |
;;;175                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;176    
;;;177      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
0000aa  6881              LDR      r1,[r0,#8]
0000ac  2908              CMP      r1,#8
0000ae  d106              BNE      |L1.190|
;;;178      {
;;;179        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (u32)BCR_FACCEN_Set;
0000b0  6801              LDR      r1,[r0,#0]
0000b2  eb020181          ADD      r1,r2,r1,LSL #2
0000b6  680b              LDR      r3,[r1,#0]
0000b8  f0430340          ORR      r3,r3,#0x40
0000bc  600b              STR      r3,[r1,#0]
                  |L1.190|
;;;180      }
;;;181    
;;;182      /* Bank1 NOR/SRAM timing register configuration */
;;;183      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
0000be  6b41              LDR      r1,[r0,#0x34]
0000c0  f8d1c004          LDR      r12,[r1,#4]
0000c4  680b              LDR      r3,[r1,#0]
0000c6  68cc              LDR      r4,[r1,#0xc]
0000c8  ea43130c          ORR      r3,r3,r12,LSL #4
0000cc  f8d1c008          LDR      r12,[r1,#8]
0000d0  ea4f2c0c          LSL      r12,r12,#8
0000d4  ea4c4c04          ORR      r12,r12,r4,LSL #16
0000d8  ea43030c          ORR      r3,r3,r12
0000dc  f8d1c010          LDR      r12,[r1,#0x10]
0000e0  ea43530c          ORR      r3,r3,r12,LSL #20
0000e4  f8d1c014          LDR      r12,[r1,#0x14]
0000e8  6989              LDR      r1,[r1,#0x18]
0000ea  ea43630c          ORR      r3,r3,r12,LSL #24
0000ee  4319              ORRS     r1,r1,r3
0000f0  6803              LDR      r3,[r0,#0]
0000f2  1c5b              ADDS     r3,r3,#1
0000f4  f8421023          STR      r1,[r2,r3,LSL #2]
;;;184                (u32)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;185                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;186                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;187                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;188                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;189                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;190                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;191                
;;;192    
;;;193        
;;;194      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;195      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
0000f8  6a81              LDR      r1,[r0,#0x28]
0000fa  f5b14f80          CMP      r1,#0x4000
0000fe  d008              BEQ      |L1.274|
;;;196      {
;;;197        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;198        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;199        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;200        assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;201        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;202        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;203        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;204    
;;;205        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
;;;206                  (u32)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;207                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;208                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;209                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;210                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;211                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;212                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;213      }
;;;214      else
;;;215      {
;;;216        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
000100  6800              LDR      r0,[r0,#0]
000102  f06f4170          MVN      r1,#0xf0000000
000106  eb020080          ADD      r0,r2,r0,LSL #2
00010a  f8c01104          STR      r1,[r0,#0x104]
;;;217      }
;;;218    }
00010e  bc10              POP      {r4}
000110  4770              BX       lr
                  |L1.274|
000112  6b81              LDR      r1,[r0,#0x38]         ;205
000114  6800              LDR      r0,[r0,#0]            ;205
000116  f8d1c004          LDR      r12,[r1,#4]           ;205
00011a  680b              LDR      r3,[r1,#0]            ;205
00011c  68cc              LDR      r4,[r1,#0xc]          ;205
00011e  ea43130c          ORR      r3,r3,r12,LSL #4      ;205
000122  f8d1c008          LDR      r12,[r1,#8]           ;205
000126  eb020080          ADD      r0,r2,r0,LSL #2       ;205
00012a  ea4f2c0c          LSL      r12,r12,#8            ;205
00012e  ea4c4c04          ORR      r12,r12,r4,LSL #16    ;205
000132  ea43030c          ORR      r3,r3,r12             ;205
000136  f8d1c010          LDR      r12,[r1,#0x10]        ;205
00013a  ea43530c          ORR      r3,r3,r12,LSL #20     ;205
00013e  f8d1c014          LDR      r12,[r1,#0x14]        ;205
000142  6989              LDR      r1,[r1,#0x18]         ;205
000144  ea43630c          ORR      r3,r3,r12,LSL #24     ;205
000148  4319              ORRS     r1,r1,r3              ;205
00014a  f8c01104          STR      r1,[r0,#0x104]        ;205
00014e  bc10              POP      {r4}
000150  4770              BX       lr
;;;219    
                          ENDP

                  FSMC_NANDInit PROC
;;;229    *******************************************************************************/
;;;230    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000152  b410              PUSH     {r4}
;;;231    {
;;;232      u32 tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;233        
;;;234      /* Check the parameters */
;;;235      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;236      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;237      assert_param( IS_FSMC_DATA_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;238      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;239      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;240      assert_param( IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_NANDInitStruct->FSMC_AddressLowMapping));
;;;241      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;242      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;243    
;;;244      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;245      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;246      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;247      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;248    
;;;249      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;250      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;251      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;252      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;253      
;;;254      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;255      tmppcr = (u32)FSMC_NANDInitStruct->FSMC_Waitfeature |
000154  6882              LDR      r2,[r0,#8]
000156  6841              LDR      r1,[r0,#4]
000158  6903              LDR      r3,[r0,#0x10]
00015a  430a              ORRS     r2,r2,r1
00015c  68c1              LDR      r1,[r0,#0xc]
00015e  4319              ORRS     r1,r1,r3
000160  4311              ORRS     r1,r1,r2
000162  6942              LDR      r2,[r0,#0x14]
000164  4311              ORRS     r1,r1,r2
000166  6982              LDR      r2,[r0,#0x18]
000168  ea412142          ORR      r1,r1,r2,LSL #9
00016c  69c2              LDR      r2,[r0,#0x1c]
00016e  ea413142          ORR      r1,r1,r2,LSL #13
000172  f0410208          ORR      r2,r1,#8
;;;256                PCR_MemoryType_NAND |
;;;257                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;258                FSMC_NANDInitStruct->FSMC_ECC |
;;;259                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;260                FSMC_NANDInitStruct->FSMC_AddressLowMapping |
;;;261                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;262                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;263                
;;;264      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;265      tmppmem = (u32)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000176  6a01              LDR      r1,[r0,#0x20]
000178  f8d1c004          LDR      r12,[r1,#4]
00017c  680b              LDR      r3,[r1,#0]
00017e  ea43230c          ORR      r3,r3,r12,LSL #8
000182  f8d1c008          LDR      r12,[r1,#8]
000186  68c9              LDR      r1,[r1,#0xc]
000188  ea4f4c0c          LSL      r12,r12,#16
00018c  ea4c6101          ORR      r1,r12,r1,LSL #24
000190  430b              ORRS     r3,r3,r1
;;;266                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;267                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;268                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;269                
;;;270      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;271      tmppatt = (u32)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000192  6a41              LDR      r1,[r0,#0x24]
000194  f8d1c000          LDR      r12,[r1,#0]
000198  684c              LDR      r4,[r1,#4]
00019a  ea4c2c04          ORR      r12,r12,r4,LSL #8
00019e  688c              LDR      r4,[r1,#8]
0001a0  68c9              LDR      r1,[r1,#0xc]
0001a2  0424              LSLS     r4,r4,#16
0001a4  ea446101          ORR      r1,r4,r1,LSL #24
0001a8  ea4c0101          ORR      r1,r12,r1
;;;272                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;273                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;274                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;275      
;;;276      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;277      {
;;;278        /* FSMC_Bank2_NAND registers configuration */
;;;279        FSMC_Bank2->PCR2 = tmppcr;
0001ac  f8d0c000          LDR      r12,[r0,#0]
0001b0  f04f4020          MOV      r0,#0xa0000000
0001b4  f1bc0f10          CMP      r12,#0x10             ;276
0001b8  d007              BEQ      |L1.458|
;;;280        FSMC_Bank2->PMEM2 = tmppmem;
;;;281        FSMC_Bank2->PATT2 = tmppatt;
;;;282      }
;;;283      else
;;;284      {
;;;285        /* FSMC_Bank3_NAND registers configuration */
;;;286        FSMC_Bank3->PCR3 = tmppcr;
0001ba  f8c02080          STR      r2,[r0,#0x80]
;;;287        FSMC_Bank3->PMEM3 = tmppmem;
0001be  f8c03088          STR      r3,[r0,#0x88]
;;;288        FSMC_Bank3->PATT3 = tmppatt;
0001c2  f8c0108c          STR      r1,[r0,#0x8c]
;;;289      }
;;;290    }
0001c6  bc10              POP      {r4}
0001c8  4770              BX       lr
                  |L1.458|
0001ca  6602              STR      r2,[r0,#0x60]         ;279
0001cc  6683              STR      r3,[r0,#0x68]         ;280
0001ce  66c1              STR      r1,[r0,#0x6c]         ;281
0001d0  bc10              POP      {r4}
0001d2  4770              BX       lr
;;;291    
                          ENDP

                  FSMC_PCCARDInit PROC
;;;301    *******************************************************************************/
;;;302    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
0001d4  6842              LDR      r2,[r0,#4]
;;;303    {
;;;304      /* Check the parameters */
;;;305      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;306      assert_param(IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_PCCARDInitStruct->FSMC_AddressLowMapping));
;;;307      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;308      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;309    
;;;310     
;;;311      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;312      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;313      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;314      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;315      
;;;316      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;317      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;318      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;319      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;320    
;;;321      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;322      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;323      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;324      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;325      
;;;326      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;327      FSMC_Bank4->PCR4 = (u32)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
0001d6  6801              LDR      r1,[r0,#0]
0001d8  68c3              LDR      r3,[r0,#0xc]
0001da  4311              ORRS     r1,r1,r2
0001dc  6882              LDR      r2,[r0,#8]
0001de  0252              LSLS     r2,r2,#9
0001e0  ea423243          ORR      r2,r2,r3,LSL #13
0001e4  4311              ORRS     r1,r1,r2
0001e6  4a9a              LDR      r2,|L1.1104|
0001e8  6011              STR      r1,[r2,#0]
;;;328                         FSMC_PCCARDInitStruct->FSMC_AddressLowMapping |
;;;329                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;330                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;331                
;;;332      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;333      FSMC_Bank4->PMEM4 = (u32)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
0001ea  6901              LDR      r1,[r0,#0x10]
0001ec  f8d1c004          LDR      r12,[r1,#4]
0001f0  680b              LDR      r3,[r1,#0]
0001f2  ea43230c          ORR      r3,r3,r12,LSL #8
0001f6  f8d1c008          LDR      r12,[r1,#8]
0001fa  68c9              LDR      r1,[r1,#0xc]
0001fc  ea4f4c0c          LSL      r12,r12,#16
000200  ea4c6101          ORR      r1,r12,r1,LSL #24
000204  ea430101          ORR      r1,r3,r1
000208  6091              STR      r1,[r2,#8]
;;;334                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;335                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;336                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;337                
;;;338      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;339      FSMC_Bank4->PATT4 = (u32)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
00020a  6941              LDR      r1,[r0,#0x14]
00020c  f8d1c004          LDR      r12,[r1,#4]
000210  680b              LDR      r3,[r1,#0]
000212  ea43230c          ORR      r3,r3,r12,LSL #8
000216  f8d1c008          LDR      r12,[r1,#8]
00021a  68c9              LDR      r1,[r1,#0xc]
00021c  ea4f4c0c          LSL      r12,r12,#16
000220  ea4c6101          ORR      r1,r12,r1,LSL #24
000224  ea430101          ORR      r1,r3,r1
000228  60d1              STR      r1,[r2,#0xc]
;;;340                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;341                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;342                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;343                
;;;344      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;345      FSMC_Bank4->PIO4 = (u32)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
00022a  6980              LDR      r0,[r0,#0x18]
00022c  6843              LDR      r3,[r0,#4]
00022e  6801              LDR      r1,[r0,#0]
000230  ea412103          ORR      r1,r1,r3,LSL #8
000234  6883              LDR      r3,[r0,#8]
000236  68c0              LDR      r0,[r0,#0xc]
000238  ea4f4303          LSL      r3,r3,#16
00023c  ea436000          ORR      r0,r3,r0,LSL #24
000240  ea410000          ORR      r0,r1,r0
000244  6110              STR      r0,[r2,#0x10]
;;;346                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;347                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;348                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;349    }
000246  4770              BX       lr
;;;350    
                          ENDP

                  FSMC_NORSRAMStructInit PROC
;;;358    *******************************************************************************/
;;;359    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000248  2100              MOVS     r1,#0
;;;360    {  
;;;361      /* Reset NOR/SRAM Init structure parameters values */
;;;362      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
00024a  6001              STR      r1,[r0,#0]
;;;363      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
00024c  2202              MOVS     r2,#2
00024e  6042              STR      r2,[r0,#4]
;;;364      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
000250  6081              STR      r1,[r0,#8]
;;;365      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000252  60c1              STR      r1,[r0,#0xc]
;;;366      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
000254  6101              STR      r1,[r0,#0x10]
;;;367      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000256  6141              STR      r1,[r0,#0x14]
;;;368      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000258  6181              STR      r1,[r0,#0x18]
;;;369      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
00025a  61c1              STR      r1,[r0,#0x1c]
;;;370      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
00025c  02d2              LSLS     r2,r2,#11
00025e  6202              STR      r2,[r0,#0x20]
;;;371      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
000260  0052              LSLS     r2,r2,#1
000262  6242              STR      r2,[r0,#0x24]
;;;372      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000264  6281              STR      r1,[r0,#0x28]
;;;373      FSMC_NORSRAMInitStruct->FSMC_AsyncWait = FSMC_AsyncWait_Disable;
000266  62c1              STR      r1,[r0,#0x2c]
;;;374      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000268  6301              STR      r1,[r0,#0x30]
;;;375      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
00026a  6b43              LDR      r3,[r0,#0x34]
00026c  220f              MOVS     r2,#0xf
00026e  601a              STR      r2,[r3,#0]
;;;376      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000270  6b43              LDR      r3,[r0,#0x34]
000272  605a              STR      r2,[r3,#4]
;;;377      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000274  f8d0c034          LDR      r12,[r0,#0x34]
000278  23ff              MOVS     r3,#0xff
00027a  f8cc3008          STR      r3,[r12,#8]
;;;378      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00027e  f8d0c034          LDR      r12,[r0,#0x34]
000282  f8cc200c          STR      r2,[r12,#0xc]
;;;379      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000286  f8d0c034          LDR      r12,[r0,#0x34]
00028a  f8cc2010          STR      r2,[r12,#0x10]
;;;380      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
00028e  f8d0c034          LDR      r12,[r0,#0x34]
000292  f8cc2014          STR      r2,[r12,#0x14]
;;;381      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
000296  f8d0c034          LDR      r12,[r0,#0x34]
00029a  f8cc1018          STR      r1,[r12,#0x18]
;;;382      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
00029e  f8d0c038          LDR      r12,[r0,#0x38]
0002a2  f8cc2000          STR      r2,[r12,#0]
;;;383      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
0002a6  f8d0c038          LDR      r12,[r0,#0x38]
0002aa  f8cc2004          STR      r2,[r12,#4]
;;;384      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
0002ae  f8d0c038          LDR      r12,[r0,#0x38]
0002b2  f8cc3008          STR      r3,[r12,#8]
;;;385      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
0002b6  6b83              LDR      r3,[r0,#0x38]
0002b8  60da              STR      r2,[r3,#0xc]
;;;386      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
0002ba  6b83              LDR      r3,[r0,#0x38]
0002bc  611a              STR      r2,[r3,#0x10]
;;;387      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
0002be  6b83              LDR      r3,[r0,#0x38]
0002c0  615a              STR      r2,[r3,#0x14]
;;;388      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
0002c2  6b80              LDR      r0,[r0,#0x38]
0002c4  6181              STR      r1,[r0,#0x18]
;;;389    }
0002c6  4770              BX       lr
;;;390    
                          ENDP

                  FSMC_NANDStructInit PROC
;;;398    *******************************************************************************/
;;;399    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
0002c8  2110              MOVS     r1,#0x10
;;;400    { 
;;;401      /* Reset NAND Init structure parameters values */
;;;402      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
0002ca  6001              STR      r1,[r0,#0]
;;;403      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
0002cc  2100              MOVS     r1,#0
0002ce  6041              STR      r1,[r0,#4]
;;;404      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
0002d0  6081              STR      r1,[r0,#8]
;;;405      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
0002d2  60c1              STR      r1,[r0,#0xc]
;;;406      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
0002d4  6101              STR      r1,[r0,#0x10]
;;;407      FSMC_NANDInitStruct->FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
0002d6  6141              STR      r1,[r0,#0x14]
;;;408      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
0002d8  6181              STR      r1,[r0,#0x18]
;;;409      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
0002da  61c1              STR      r1,[r0,#0x1c]
;;;410      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
0002dc  6a02              LDR      r2,[r0,#0x20]
0002de  21fc              MOVS     r1,#0xfc
0002e0  6011              STR      r1,[r2,#0]
;;;411      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002e2  6a02              LDR      r2,[r0,#0x20]
0002e4  6051              STR      r1,[r2,#4]
;;;412      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002e6  6a02              LDR      r2,[r0,#0x20]
0002e8  6091              STR      r1,[r2,#8]
;;;413      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
0002ea  6a02              LDR      r2,[r0,#0x20]
0002ec  60d1              STR      r1,[r2,#0xc]
;;;414      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
0002ee  6a42              LDR      r2,[r0,#0x24]
0002f0  6011              STR      r1,[r2,#0]
;;;415      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002f2  6a42              LDR      r2,[r0,#0x24]
0002f4  6051              STR      r1,[r2,#4]
;;;416      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002f6  6a42              LDR      r2,[r0,#0x24]
0002f8  6091              STR      r1,[r2,#8]
;;;417      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
0002fa  6a40              LDR      r0,[r0,#0x24]
0002fc  60c1              STR      r1,[r0,#0xc]
;;;418    }
0002fe  4770              BX       lr
;;;419    
                          ENDP

                  FSMC_PCCARDStructInit PROC
;;;427    *******************************************************************************/
;;;428    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000300  2100              MOVS     r1,#0
;;;429    {
;;;430      /* Reset PCCARD Init structure parameters values */
;;;431      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000302  6001              STR      r1,[r0,#0]
;;;432      FSMC_PCCARDInitStruct->FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
000304  6041              STR      r1,[r0,#4]
;;;433      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000306  6081              STR      r1,[r0,#8]
;;;434      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000308  60c1              STR      r1,[r0,#0xc]
;;;435      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00030a  6902              LDR      r2,[r0,#0x10]
00030c  21fc              MOVS     r1,#0xfc
00030e  6011              STR      r1,[r2,#0]
;;;436      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000310  6902              LDR      r2,[r0,#0x10]
000312  6051              STR      r1,[r2,#4]
;;;437      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000314  6902              LDR      r2,[r0,#0x10]
000316  6091              STR      r1,[r2,#8]
;;;438      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000318  6902              LDR      r2,[r0,#0x10]
00031a  60d1              STR      r1,[r2,#0xc]
;;;439      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00031c  6942              LDR      r2,[r0,#0x14]
00031e  6011              STR      r1,[r2,#0]
;;;440      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000320  6942              LDR      r2,[r0,#0x14]
000322  6051              STR      r1,[r2,#4]
;;;441      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000324  6942              LDR      r2,[r0,#0x14]
000326  6091              STR      r1,[r2,#8]
;;;442      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000328  6942              LDR      r2,[r0,#0x14]
00032a  60d1              STR      r1,[r2,#0xc]
;;;443      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00032c  6982              LDR      r2,[r0,#0x18]
00032e  6011              STR      r1,[r2,#0]
;;;444      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000330  6982              LDR      r2,[r0,#0x18]
000332  6051              STR      r1,[r2,#4]
;;;445      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000334  6982              LDR      r2,[r0,#0x18]
000336  6091              STR      r1,[r2,#8]
;;;446      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000338  6980              LDR      r0,[r0,#0x18]
00033a  60c1              STR      r1,[r0,#0xc]
;;;447    }
00033c  4770              BX       lr
;;;448    
                          ENDP

                  FSMC_NORSRAMCmd PROC
;;;462    *******************************************************************************/
;;;463    void FSMC_NORSRAMCmd(u32 FSMC_Bank, FunctionalState NewState)
00033e  f04f4220          MOV      r2,#0xa0000000
;;;464    {
;;;465      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;466      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;467      
;;;468      if (NewState != DISABLE)
;;;469      {
;;;470        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;471        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
000342  eb020080          ADD      r0,r2,r0,LSL #2
000346  b121              CBZ      r1,|L1.850|
000348  6801              LDR      r1,[r0,#0]
00034a  f0410101          ORR      r1,r1,#1
00034e  6001              STR      r1,[r0,#0]
;;;472      }
;;;473      else
;;;474      {
;;;475        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;476        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
;;;477      }
;;;478    }
000350  4770              BX       lr
                  |L1.850|
000352  6801              LDR      r1,[r0,#0]            ;476
000354  4a3f              LDR      r2,|L1.1108|
000356  4011              ANDS     r1,r1,r2              ;476
000358  6001              STR      r1,[r0,#0]            ;476
00035a  4770              BX       lr
;;;479    
                          ENDP

                  FSMC_NANDCmd PROC
;;;491    *******************************************************************************/
;;;492    void FSMC_NANDCmd(u32 FSMC_Bank, FunctionalState NewState)
00035c  f04f4220          MOV      r2,#0xa0000000
;;;493    {
;;;494      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;495      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;496      
;;;497      if (NewState != DISABLE)
000360  b169              CBZ      r1,|L1.894|
;;;498      {
;;;499        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;500        if(FSMC_Bank == FSMC_Bank2_NAND)
000362  2810              CMP      r0,#0x10
000364  d006              BEQ      |L1.884|
;;;501        {
;;;502          FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
;;;503        }
;;;504        else
;;;505        {
;;;506          FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
000366  f8d20080          LDR      r0,[r2,#0x80]
00036a  f0400004          ORR      r0,r0,#4
00036e  f8c20080          STR      r0,[r2,#0x80]
;;;507        }
;;;508      }
;;;509      else
;;;510      {
;;;511        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;512        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;513        {
;;;514          FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
;;;515        }
;;;516        else
;;;517        {
;;;518          FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
;;;519        }
;;;520      }
;;;521    }
000372  4770              BX       lr
                  |L1.884|
000374  6e10              LDR      r0,[r2,#0x60]         ;502
000376  f0400004          ORR      r0,r0,#4              ;502
00037a  6610              STR      r0,[r2,#0x60]         ;502
00037c  4770              BX       lr
                  |L1.894|
00037e  4936              LDR      r1,|L1.1112|
000380  2810              CMP      r0,#0x10              ;512
000382  d005              BEQ      |L1.912|
000384  f8d20080          LDR      r0,[r2,#0x80]         ;518
000388  4008              ANDS     r0,r0,r1              ;518
00038a  f8c20080          STR      r0,[r2,#0x80]         ;518
00038e  4770              BX       lr
                  |L1.912|
000390  6e10              LDR      r0,[r2,#0x60]         ;514
000392  4008              ANDS     r0,r0,r1              ;514
000394  6610              STR      r0,[r2,#0x60]         ;514
000396  4770              BX       lr
;;;522    
                          ENDP

                  FSMC_PCCARDCmd PROC
;;;530    *******************************************************************************/
;;;531    void FSMC_PCCARDCmd(FunctionalState NewState)
000398  f04f4120          MOV      r1,#0xa0000000
;;;532    {
;;;533      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;534      
;;;535      if (NewState != DISABLE)
00039c  b130              CBZ      r0,|L1.940|
;;;536      {
;;;537        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;538        FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
00039e  f8d100a0          LDR      r0,[r1,#0xa0]
0003a2  f0400004          ORR      r0,r0,#4
0003a6  f8c100a0          STR      r0,[r1,#0xa0]
;;;539      }
;;;540      else
;;;541      {
;;;542        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;543        FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
;;;544      }
;;;545    }
0003aa  4770              BX       lr
                  |L1.940|
0003ac  f8d100a0          LDR      r0,[r1,#0xa0]         ;543
0003b0  4a29              LDR      r2,|L1.1112|
0003b2  4010              ANDS     r0,r0,r2              ;543
0003b4  f8c100a0          STR      r0,[r1,#0xa0]         ;543
0003b8  4770              BX       lr
;;;546    
                          ENDP

                  FSMC_NANDECCCmd PROC
;;;558    *******************************************************************************/
;;;559    void FSMC_NANDECCCmd(u32 FSMC_Bank, FunctionalState NewState)
0003ba  f04f4220          MOV      r2,#0xa0000000
;;;560    {
;;;561      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;562      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;563      
;;;564      if (NewState != DISABLE)
0003be  b169              CBZ      r1,|L1.988|
;;;565      {
;;;566        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;567        if(FSMC_Bank == FSMC_Bank2_NAND)
0003c0  2810              CMP      r0,#0x10
0003c2  d006              BEQ      |L1.978|
;;;568        {
;;;569          FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
;;;570        }
;;;571        else
;;;572        {
;;;573          FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
0003c4  f8d20080          LDR      r0,[r2,#0x80]
0003c8  f0400040          ORR      r0,r0,#0x40
0003cc  f8c20080          STR      r0,[r2,#0x80]
;;;574        }
;;;575      }
;;;576      else
;;;577      {
;;;578        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;579        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;580        {
;;;581          FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
;;;582        }
;;;583        else
;;;584        {
;;;585          FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
;;;586        }
;;;587      }
;;;588    }
0003d0  4770              BX       lr
                  |L1.978|
0003d2  6e10              LDR      r0,[r2,#0x60]         ;569
0003d4  f0400040          ORR      r0,r0,#0x40           ;569
0003d8  6610              STR      r0,[r2,#0x60]         ;569
0003da  4770              BX       lr
                  |L1.988|
0003dc  491f              LDR      r1,|L1.1116|
0003de  2810              CMP      r0,#0x10              ;579
0003e0  d005              BEQ      |L1.1006|
0003e2  f8d20080          LDR      r0,[r2,#0x80]         ;585
0003e6  4008              ANDS     r0,r0,r1              ;585
0003e8  f8c20080          STR      r0,[r2,#0x80]         ;585
0003ec  4770              BX       lr
                  |L1.1006|
0003ee  6e10              LDR      r0,[r2,#0x60]         ;581
0003f0  4008              ANDS     r0,r0,r1              ;581
0003f2  6610              STR      r0,[r2,#0x60]         ;581
0003f4  4770              BX       lr
;;;589    
                          ENDP

                  FSMC_GetECC PROC
;;;599    *******************************************************************************/
;;;600    u32 FSMC_GetECC(u32 FSMC_Bank)
0003f6  f04f4120          MOV      r1,#0xa0000000
;;;601    {
;;;602      u32 eccval = 0x00000000;
;;;603      
;;;604      if(FSMC_Bank == FSMC_Bank2_NAND)
0003fa  2810              CMP      r0,#0x10
0003fc  d002              BEQ      |L1.1028|
;;;605      {
;;;606        /* Get the ECCR2 register value */
;;;607        eccval = FSMC_Bank2->ECCR2;
;;;608      }
;;;609      else
;;;610      {
;;;611        /* Get the ECCR3 register value */
;;;612        eccval = FSMC_Bank3->ECCR3;
0003fe  f8d10094          LDR      r0,[r1,#0x94]
;;;613      }
;;;614      /* Return the error correction code value */
;;;615      return(eccval);
;;;616    }
000402  4770              BX       lr
                  |L1.1028|
000404  6f48              LDR      r0,[r1,#0x74]         ;607
000406  4770              BX       lr
;;;617    
                          ENDP

                  FSMC_ITConfig PROC
;;;636    *******************************************************************************/
;;;637    void FSMC_ITConfig(u32 FSMC_Bank, u32 FSMC_IT, FunctionalState NewState)
000408  f04f4320          MOV      r3,#0xa0000000
;;;638    {
;;;639      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;640      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;641      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;642      
;;;643      if (NewState != DISABLE)
00040c  b1a2              CBZ      r2,|L1.1080|
;;;644      {
;;;645        /* Enable the selected FSMC_Bank2 interrupts */
;;;646        if(FSMC_Bank == FSMC_Bank2_NAND)
00040e  2810              CMP      r0,#0x10
000410  d008              BEQ      |L1.1060|
;;;647        {
;;;648          FSMC_Bank2->SR2 |= FSMC_IT;
;;;649        }
;;;650        /* Enable the selected FSMC_Bank3 interrupts */
;;;651        else if (FSMC_Bank == FSMC_Bank3_NAND)
000412  f5b07f80          CMP      r0,#0x100
000416  d009              BEQ      |L1.1068|
;;;652        {
;;;653          FSMC_Bank3->SR3 |= FSMC_IT;
;;;654        }
;;;655        /* Enable the selected FSMC_Bank4 interrupts */
;;;656        else
;;;657        {
;;;658          FSMC_Bank4->SR4 |= FSMC_IT;    
000418  f8d300a4          LDR      r0,[r3,#0xa4]
00041c  4308              ORRS     r0,r0,r1
00041e  f8c300a4          STR      r0,[r3,#0xa4]
;;;659        }
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Disable the selected FSMC_Bank2 interrupts */
;;;664        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;665        {
;;;666          
;;;667          FSMC_Bank2->SR2 &= (u32)~FSMC_IT;
;;;668        }
;;;669        /* Disable the selected FSMC_Bank3 interrupts */
;;;670        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;671        {
;;;672          FSMC_Bank3->SR3 &= (u32)~FSMC_IT;
;;;673        }
;;;674        /* Disable the selected FSMC_Bank4 interrupts */
;;;675        else
;;;676        {
;;;677          FSMC_Bank4->SR4 &= (u32)~FSMC_IT;    
;;;678        }
;;;679      }
;;;680    }
000422  4770              BX       lr
                  |L1.1060|
000424  6e58              LDR      r0,[r3,#0x64]         ;648
000426  4308              ORRS     r0,r0,r1              ;648
000428  6658              STR      r0,[r3,#0x64]         ;648
00042a  4770              BX       lr
                  |L1.1068|
00042c  f8d30084          LDR      r0,[r3,#0x84]         ;653
000430  4308              ORRS     r0,r0,r1              ;653
000432  f8c30084          STR      r0,[r3,#0x84]         ;653
000436  4770              BX       lr
                  |L1.1080|
000438  2810              CMP      r0,#0x10              ;664
00043a  d011              BEQ      |L1.1120|
00043c  f5b07f80          CMP      r0,#0x100             ;670
000440  d012              BEQ      |L1.1128|
000442  f8d300a4          LDR      r0,[r3,#0xa4]         ;677
000446  4388              BICS     r0,r0,r1              ;677
000448  f8c300a4          STR      r0,[r3,#0xa4]         ;677
                  |L1.1100|
00044c  4770              BX       lr
00044e  0000              DCW      0x0000
                  |L1.1104|
                          DCD      0xa00000a0
                  |L1.1108|
                          DCD      0x000ffffe
                  |L1.1112|
                          DCD      0x000ffffb
                  |L1.1116|
                          DCD      0x000fffbf
                  |L1.1120|
000460  6e58              LDR      r0,[r3,#0x64]         ;667
000462  4388              BICS     r0,r0,r1              ;667
000464  6658              STR      r0,[r3,#0x64]         ;667
000466  e7f1              B        |L1.1100|
                  |L1.1128|
000468  f8d30084          LDR      r0,[r3,#0x84]         ;672
00046c  4388              BICS     r0,r0,r1              ;672
00046e  f8c30084          STR      r0,[r3,#0x84]         ;672
000472  e7eb              B        |L1.1100|
;;;681                      
                          ENDP

                  FSMC_GetFlagStatus PROC
;;;698    *******************************************************************************/                   
;;;699    FlagStatus FSMC_GetFlagStatus(u32 FSMC_Bank, u32 FSMC_FLAG)
000474  2200              MOVS     r2,#0
;;;700    {
;;;701      FlagStatus bitstatus = RESET;
;;;702      u32 tmpsr = 0x00000000;
;;;703      
;;;704      /* Check the parameters */
;;;705      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;706      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;707      
;;;708      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;709      {
;;;710        tmpsr = FSMC_Bank2->SR2;
000476  f04f4320          MOV      r3,#0xa0000000
00047a  2810              CMP      r0,#0x10              ;708
00047c  d009              BEQ      |L1.1170|
;;;711      }  
;;;712      else if(FSMC_Bank == FSMC_Bank3_NAND)
00047e  f5b07f80          CMP      r0,#0x100
000482  d008              BEQ      |L1.1174|
;;;713      {
;;;714        tmpsr = FSMC_Bank3->SR3;
;;;715      }
;;;716      /* FSMC_Bank4_PCCARD*/
;;;717      else
;;;718      {
;;;719        tmpsr = FSMC_Bank4->SR4;
000484  f8d300a4          LDR      r0,[r3,#0xa4]
                  |L1.1160|
;;;720      } 
;;;721      
;;;722      /* Get the flag status */
;;;723      if ((tmpsr & FSMC_FLAG) != (u16)RESET )
000488  4208              TST      r0,r1
00048a  d000              BEQ      |L1.1166|
;;;724      {
;;;725        bitstatus = SET;
00048c  2201              MOVS     r2,#1
                  |L1.1166|
;;;726      }
;;;727      else
;;;728      {
;;;729        bitstatus = RESET;
;;;730      }
;;;731      /* Return the flag status */
;;;732      return bitstatus;
00048e  4610              MOV      r0,r2
;;;733    }
000490  4770              BX       lr
                  |L1.1170|
000492  6e58              LDR      r0,[r3,#0x64]         ;710
000494  e7f8              B        |L1.1160|
                  |L1.1174|
000496  f8d30084          LDR      r0,[r3,#0x84]         ;714
00049a  e7f5              B        |L1.1160|
;;;734    
                          ENDP

                  FSMC_ClearFlag PROC
;;;750    *******************************************************************************/                   
;;;751    void FSMC_ClearFlag(u32 FSMC_Bank, u32 FSMC_FLAG)
00049c  f04f4220          MOV      r2,#0xa0000000
;;;752    {
;;;753     /* Check the parameters */
;;;754      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;755      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;756        
;;;757      if(FSMC_Bank == FSMC_Bank2_NAND)
0004a0  2810              CMP      r0,#0x10
0004a2  d008              BEQ      |L1.1206|
;;;758      {
;;;759        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;760      }  
;;;761      else if(FSMC_Bank == FSMC_Bank3_NAND)
0004a4  f5b07f80          CMP      r0,#0x100
0004a8  d009              BEQ      |L1.1214|
;;;762      {
;;;763        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;764      }
;;;765      /* FSMC_Bank4_PCCARD*/
;;;766      else
;;;767      {
;;;768        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
0004aa  f8d200a4          LDR      r0,[r2,#0xa4]
0004ae  4388              BICS     r0,r0,r1
0004b0  f8c200a4          STR      r0,[r2,#0xa4]
;;;769      }
;;;770    }
0004b4  4770              BX       lr
                  |L1.1206|
0004b6  6e50              LDR      r0,[r2,#0x64]         ;759
0004b8  4388              BICS     r0,r0,r1              ;759
0004ba  6650              STR      r0,[r2,#0x64]         ;759
0004bc  4770              BX       lr
                  |L1.1214|
0004be  f8d20084          LDR      r0,[r2,#0x84]         ;763
0004c2  4388              BICS     r0,r0,r1              ;763
0004c4  f8c20084          STR      r0,[r2,#0x84]         ;763
0004c8  4770              BX       lr
;;;771    
                          ENDP

                  FSMC_GetITStatus PROC
;;;787    *******************************************************************************/ 
;;;788    ITStatus FSMC_GetITStatus(u32 FSMC_Bank, u32 FSMC_IT)
0004ca  2200              MOVS     r2,#0
;;;789    {
;;;790      ITStatus bitstatus = RESET;
;;;791      u32 tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;792      
;;;793      /* Check the parameters */
;;;794      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;795      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;796      
;;;797      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;798      {
;;;799        tmpsr = FSMC_Bank2->SR2;
0004cc  f04f4320          MOV      r3,#0xa0000000
0004d0  2810              CMP      r0,#0x10              ;797
0004d2  d00d              BEQ      |L1.1264|
;;;800      }  
;;;801      else if(FSMC_Bank == FSMC_Bank3_NAND)
0004d4  f5b07f80          CMP      r0,#0x100
0004d8  d00c              BEQ      |L1.1268|
;;;802      {
;;;803        tmpsr = FSMC_Bank3->SR3;
;;;804      }
;;;805      /* FSMC_Bank4_PCCARD*/
;;;806      else
;;;807      {
;;;808        tmpsr = FSMC_Bank4->SR4;
0004da  f8d300a4          LDR      r0,[r3,#0xa4]
                  |L1.1246|
;;;809      } 
;;;810      
;;;811      itstatus = tmpsr & FSMC_IT;
0004de  ea000301          AND      r3,r0,r1
;;;812      
;;;813      itenable = tmpsr & (FSMC_IT >> 3);
0004e2  ea0000d1          AND      r0,r0,r1,LSR #3
;;;814    
;;;815      if ((itstatus != (u32)RESET)  && (itenable != (u32)RESET))
0004e6  b10b              CBZ      r3,|L1.1260|
0004e8  b100              CBZ      r0,|L1.1260|
;;;816      {
;;;817        bitstatus = SET;
0004ea  2201              MOVS     r2,#1
                  |L1.1260|
;;;818      }
;;;819      else
;;;820      {
;;;821        bitstatus = RESET;
;;;822      }
;;;823      return bitstatus; 
0004ec  4610              MOV      r0,r2
;;;824    }
0004ee  4770              BX       lr
                  |L1.1264|
0004f0  6e58              LDR      r0,[r3,#0x64]         ;799
0004f2  e7f4              B        |L1.1246|
                  |L1.1268|
0004f4  f8d30084          LDR      r0,[r3,#0x84]         ;803
0004f8  e7f1              B        |L1.1246|
;;;825    
                          ENDP

                  FSMC_ClearITPendingBit PROC
;;;841    *******************************************************************************/
;;;842    void FSMC_ClearITPendingBit(u32 FSMC_Bank, u32 FSMC_IT)
0004fa  f04f4220          MOV      r2,#0xa0000000
;;;843    {
;;;844      /* Check the parameters */
;;;845      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;846      assert_param(IS_FSMC_IT(FSMC_IT));
;;;847        
;;;848      if(FSMC_Bank == FSMC_Bank2_NAND)
0004fe  2810              CMP      r0,#0x10
000500  d009              BEQ      |L1.1302|
;;;849      {
;;;850        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;851      }  
;;;852      else if(FSMC_Bank == FSMC_Bank3_NAND)
000502  f5b07f80          CMP      r0,#0x100
000506  d00b              BEQ      |L1.1312|
;;;853      {
;;;854        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;855      }
;;;856      /* FSMC_Bank4_PCCARD*/
;;;857      else
;;;858      {
;;;859        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
000508  f8d200a4          LDR      r0,[r2,#0xa4]
00050c  ea2000d1          BIC      r0,r0,r1,LSR #3
000510  f8c200a4          STR      r0,[r2,#0xa4]
;;;860      }
;;;861    }
000514  4770              BX       lr
                  |L1.1302|
000516  6e50              LDR      r0,[r2,#0x64]         ;850
000518  ea2000d1          BIC      r0,r0,r1,LSR #3       ;850
00051c  6650              STR      r0,[r2,#0x64]         ;850
00051e  4770              BX       lr
                  |L1.1312|
000520  f8d20084          LDR      r0,[r2,#0x84]         ;854
000524  ea2000d1          BIC      r0,r0,r1,LSR #3       ;854
000528  f8c20084          STR      r0,[r2,#0x84]         ;854
00052c  4770              BX       lr
;;;862    
                          ENDP

