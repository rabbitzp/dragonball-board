; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\stm32f10x_usart.o --depend=.\rvmdk\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\stm32f10x_usart.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;91     *******************************************************************************/
;;;92     void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;93     {
;;;94       /* Check the parameters */
;;;95       assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;96     
;;;97       switch (*(u32*)&USARTx)
000002  4aca              LDR      r2,|L1.812|
000004  1a81              SUBS     r1,r0,r2
000006  4290              CMP      r0,r2
000008  d02d              BEQ      |L1.102|
00000a  dc10              BGT      |L1.46|
00000c  f5116000          ADDS     r0,r1,#0x800
000010  d01e              BEQ      |L1.80|
000012  f5b06f80          CMP      r0,#0x400
000016  d13c              BNE      |L1.146|
;;;98       {
;;;99         case USART1_BASE:
;;;100          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
;;;101          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
;;;102          break;
;;;103    
;;;104        case USART2_BASE:
;;;105          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
;;;106          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
;;;107          break;
;;;108    
;;;109        case USART3_BASE:
;;;110          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000018  2101              MOVS     r1,#1
00001a  0488              LSLS     r0,r1,#18
00001c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;111          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000020  e8bd4010          POP      {r4,lr}
000024  2100              MOVS     r1,#0
000026  f44f2080          MOV      r0,#0x40000
00002a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.46|
00002e  f5b16f80          CMP      r1,#0x400             ;97
000032  d023              BEQ      |L1.124|
000034  f5b14f6c          CMP      r1,#0xec00            ;97
000038  d12b              BNE      |L1.146|
00003a  2101              MOVS     r1,#1                 ;100
00003c  0388              LSLS     r0,r1,#14             ;100
00003e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000042  e8bd4010          POP      {r4,lr}               ;101
000046  2100              MOVS     r1,#0                 ;101
000048  f44f4080          MOV      r0,#0x4000            ;101
00004c  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.80|
000050  2101              MOVS     r1,#1                 ;105
000052  0448              LSLS     r0,r1,#17             ;105
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
000058  e8bd4010          POP      {r4,lr}               ;106
00005c  2100              MOVS     r1,#0                 ;106
00005e  f44f3000          MOV      r0,#0x20000           ;106
000062  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.102|
;;;112          break;
;;;113        
;;;114        case UART4_BASE:
;;;115          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000066  2101              MOVS     r1,#1
000068  04c8              LSLS     r0,r1,#19
00006a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;116          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
00006e  e8bd4010          POP      {r4,lr}
000072  2100              MOVS     r1,#0
000074  f44f2000          MOV      r0,#0x80000
000078  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.124|
;;;117          break;
;;;118        
;;;119        case UART5_BASE:
;;;120          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
00007c  2101              MOVS     r1,#1
00007e  0508              LSLS     r0,r1,#20
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;121          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000084  e8bd4010          POP      {r4,lr}
000088  2100              MOVS     r1,#0
00008a  f44f1080          MOV      r0,#0x100000
00008e  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.146|
;;;122          break;            
;;;123    
;;;124        default:
;;;125          break;
;;;126      }
;;;127    }
000092  bd10              POP      {r4,pc}
;;;128    
                          ENDP

                  USART_Init PROC
;;;141    *******************************************************************************/
;;;142    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000094  b530              PUSH     {r4,r5,lr}
;;;143    {
000096  b085              SUB      sp,sp,#0x14
000098  4604              MOV      r4,r0
00009a  460d              MOV      r5,r1
;;;144      u32 tmpreg = 0x00, apbclock = 0x00;
;;;145      u32 integerdivider = 0x00;
;;;146      u32 fractionaldivider = 0x00;
;;;147      u32 usartxbase = 0;
;;;148      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;149    
;;;150      /* Check the parameters */
;;;151      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;152      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;153      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;154      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;155      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;156      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;157      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;158      /* The hardware flow control is available only for USART1, USART2 and USART3 */          
;;;159      assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
;;;160      
;;;161      usartxbase = (*(u32*)&USARTx);
;;;162    
;;;163    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;164      tmpreg = USARTx->CR2;
00009c  8a20              LDRH     r0,[r4,#0x10]
;;;165      /* Clear STOP[13:12] bits */
;;;166      tmpreg &= CR2_STOP_CLEAR_Mask;
00009e  f64c71ff          MOV      r1,#0xcfff
0000a2  4008              ANDS     r0,r0,r1
;;;167    
;;;168      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;169      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;170      tmpreg |= (u32)USART_InitStruct->USART_StopBits;
0000a4  88e9              LDRH     r1,[r5,#6]
0000a6  4308              ORRS     r0,r0,r1
;;;171      
;;;172      /* Write to USART CR2 */
;;;173      USARTx->CR2 = (u16)tmpreg;
0000a8  8220              STRH     r0,[r4,#0x10]
;;;174    
;;;175    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;176      tmpreg = USARTx->CR1;
0000aa  89a0              LDRH     r0,[r4,#0xc]
;;;177      /* Clear M, PCE, PS, TE and RE bits */
;;;178      tmpreg &= CR1_CLEAR_Mask;
0000ac  f64e11f3          MOV      r1,#0xe9f3
0000b0  4008              ANDS     r0,r0,r1
;;;179    
;;;180      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;181      /* Set the M bits according to USART_WordLength value */
;;;182      /* Set PCE and PS bits according to USART_Parity value */
;;;183      /* Set TE and RE bits according to USART_Mode value */
;;;184      tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
0000b2  88a9              LDRH     r1,[r5,#4]
0000b4  892a              LDRH     r2,[r5,#8]
0000b6  4311              ORRS     r1,r1,r2
0000b8  896a              LDRH     r2,[r5,#0xa]
0000ba  4310              ORRS     r0,r0,r2
0000bc  4308              ORRS     r0,r0,r1
;;;185                USART_InitStruct->USART_Mode;
;;;186    
;;;187      /* Write to USART CR1 */
;;;188      USARTx->CR1 = (u16)tmpreg;
0000be  81a0              STRH     r0,[r4,#0xc]
;;;189    
;;;190    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;191      tmpreg = USARTx->CR3;
0000c0  8aa0              LDRH     r0,[r4,#0x14]
;;;192      /* Clear CTSE and RTSE bits */
;;;193      tmpreg &= CR3_CLEAR_Mask;
0000c2  f64f41ff          MOV      r1,#0xfcff
0000c6  4008              ANDS     r0,r0,r1
;;;194    
;;;195      /* Configure the USART HFC -------------------------------------------------*/
;;;196      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;197      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
0000c8  89a9              LDRH     r1,[r5,#0xc]
0000ca  4308              ORRS     r0,r0,r1
;;;198    
;;;199      /* Write to USART CR3 */
;;;200      USARTx->CR3 = (u16)tmpreg;
0000cc  82a0              STRH     r0,[r4,#0x14]
;;;201    
;;;202    /*---------------------------- USART BRR Configuration -----------------------*/
;;;203      /* Configure the USART Baud Rate -------------------------------------------*/
;;;204      RCC_GetClocksFreq(&RCC_ClocksStatus);
0000ce  4668              MOV      r0,sp
0000d0  f7fffffe          BL       RCC_GetClocksFreq
;;;205      if (usartxbase == USART1_BASE)
0000d4  f1a44080          SUB      r0,r4,#0x40000000
0000d8  f5b0309c          SUBS     r0,r0,#0x13800
0000dc  d101              BNE      |L1.226|
;;;206      {
;;;207        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
0000de  9803              LDR      r0,[sp,#0xc]
0000e0  e000              B        |L1.228|
                  |L1.226|
;;;208      }
;;;209      else
;;;210      {
;;;211        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
0000e2  9802              LDR      r0,[sp,#8]
                  |L1.228|
;;;212      }
;;;213    
;;;214      /* Determine the integer part */
;;;215      integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
0000e4  eb0001c0          ADD      r1,r0,r0,LSL #3
0000e8  eb011000          ADD      r0,r1,r0,LSL #4
0000ec  6829              LDR      r1,[r5,#0]
0000ee  0089              LSLS     r1,r1,#2
0000f0  fbb0f0f1          UDIV     r0,r0,r1
;;;216      tmpreg = (integerdivider / 0x64) << 0x04;
0000f4  4a8e              LDR      r2,|L1.816|
0000f6  fba23100          UMULL    r3,r1,r2,r0
0000fa  0949              LSRS     r1,r1,#5
0000fc  0109              LSLS     r1,r1,#4
;;;217    
;;;218      /* Determine the fractional part */
;;;219      fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
0000fe  090b              LSRS     r3,r1,#4
000100  f06f0c18          MVN      r12,#0x18
000104  fb03f30c          MUL      r3,r3,r12
000108  eb000083          ADD      r0,r0,r3,LSL #2
;;;220      tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
00010c  2332              MOVS     r3,#0x32
00010e  eb031000          ADD      r0,r3,r0,LSL #4
000112  fba22000          UMULL    r2,r0,r2,r0
000116  f3c01043          UBFX     r0,r0,#5,#4
00011a  4308              ORRS     r0,r0,r1
;;;221    
;;;222      /* Write to USART BRR */
;;;223      USARTx->BRR = (u16)tmpreg;
00011c  8120              STRH     r0,[r4,#8]
;;;224    }
00011e  b005              ADD      sp,sp,#0x14
000120  bd30              POP      {r4,r5,pc}
;;;225    
                          ENDP

                  USART_StructInit PROC
;;;233    *******************************************************************************/
;;;234    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000122  f44f5116          MOV      r1,#0x2580
;;;235    {
;;;236      /* USART_InitStruct members default value */
;;;237      USART_InitStruct->USART_BaudRate = 9600;
000126  6001              STR      r1,[r0,#0]
;;;238      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000128  2100              MOVS     r1,#0
00012a  8081              STRH     r1,[r0,#4]
;;;239      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00012c  80c1              STRH     r1,[r0,#6]
;;;240      USART_InitStruct->USART_Parity = USART_Parity_No ;
00012e  8101              STRH     r1,[r0,#8]
;;;241      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000130  220c              MOVS     r2,#0xc
000132  8142              STRH     r2,[r0,#0xa]
;;;242      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000134  8181              STRH     r1,[r0,#0xc]
;;;243    }
000136  4770              BX       lr
;;;244    
                          ENDP

                  USART_ClockInit PROC
;;;256    *******************************************************************************/
;;;257    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000138  8a02              LDRH     r2,[r0,#0x10]
;;;258    {
;;;259      u32 tmpreg = 0x00;
;;;260    
;;;261      /* Check the parameters */
;;;262      assert_param(IS_USART_123_PERIPH(USARTx));
;;;263      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;264      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;265      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;266      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
;;;267      
;;;268    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;269      tmpreg = USARTx->CR2;
;;;270      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;271      tmpreg &= CR2_CLOCK_CLEAR_Mask;
00013a  f24f03ff          MOV      r3,#0xf0ff
00013e  401a              ANDS     r2,r2,r3
;;;272    
;;;273      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;274      /* Set CLKEN bit according to USART_Clock value */
;;;275      /* Set CPOL bit according to USART_CPOL value */
;;;276      /* Set CPHA bit according to USART_CPHA value */
;;;277      /* Set LBCL bit according to USART_LastBit value */
;;;278      tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000140  880b              LDRH     r3,[r1,#0]
000142  f8b1c002          LDRH     r12,[r1,#2]
000146  ea43030c          ORR      r3,r3,r12
00014a  f8b1c004          LDRH     r12,[r1,#4]
00014e  88c9              LDRH     r1,[r1,#6]
000150  ea4c0101          ORR      r1,r12,r1
000154  4319              ORRS     r1,r1,r3
000156  4311              ORRS     r1,r1,r2
;;;279                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;280    
;;;281      /* Write to USART CR2 */
;;;282      USARTx->CR2 = (u16)tmpreg;
000158  8201              STRH     r1,[r0,#0x10]
;;;283    }
00015a  4770              BX       lr
;;;284    
                          ENDP

                  USART_ClockStructInit PROC
;;;292    *******************************************************************************/
;;;293    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
00015c  2100              MOVS     r1,#0
;;;294    {
;;;295      /* USART_ClockInitStruct members default value */
;;;296      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
00015e  8001              STRH     r1,[r0,#0]
;;;297      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000160  8041              STRH     r1,[r0,#2]
;;;298      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000162  8081              STRH     r1,[r0,#4]
;;;299      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000164  80c1              STRH     r1,[r0,#6]
;;;300    }
000166  4770              BX       lr
;;;301    
                          ENDP

                  USART_Cmd PROC
;;;312    *******************************************************************************/
;;;313    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000168  b121              CBZ      r1,|L1.372|
;;;314    {
;;;315      /* Check the parameters */
;;;316      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;317      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;318      
;;;319      if (NewState != DISABLE)
;;;320      {
;;;321        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;322        USARTx->CR1 |= CR1_UE_Set;
00016a  8981              LDRH     r1,[r0,#0xc]
00016c  f4415100          ORR      r1,r1,#0x2000
000170  8181              STRH     r1,[r0,#0xc]
;;;323      }
;;;324      else
;;;325      {
;;;326        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;327        USARTx->CR1 &= CR1_UE_Reset;
;;;328      }
;;;329    }
000172  4770              BX       lr
                  |L1.372|
000174  8981              LDRH     r1,[r0,#0xc]          ;327
000176  f4215100          BIC      r1,r1,#0x2000         ;327
00017a  8181              STRH     r1,[r0,#0xc]          ;327
00017c  4770              BX       lr
;;;330    
                          ENDP

                  USART_ITConfig PROC
;;;355    *******************************************************************************/
;;;356    void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
00017e  f3c11342          UBFX     r3,r1,#5,#3
;;;357    {
;;;358      u32 usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;359      u32 usartxbase = 0x00;
;;;360    
;;;361      /* Check the parameters */
;;;362      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;363      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;364      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */     
;;;365      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;366    
;;;367      usartxbase = (*(u32*)&(USARTx));
;;;368    
;;;369      /* Get the USART register index */
;;;370      usartreg = (((u8)USART_IT) >> 0x05);
;;;371    
;;;372      /* Get the interrupt position */
;;;373      itpos = USART_IT & IT_Mask;
000182  f001011f          AND      r1,r1,#0x1f
;;;374    
;;;375      itmask = (((u32)0x01) << itpos);
000186  f04f0c01          MOV      r12,#1
00018a  fa0cf101          LSL      r1,r12,r1
;;;376        
;;;377      if (usartreg == 0x01) /* The IT is in CR1 register */
00018e  2b01              CMP      r3,#1
000190  d007              BEQ      |L1.418|
;;;378      {
;;;379        usartxbase += 0x0C;
;;;380      }
;;;381      else if (usartreg == 0x02) /* The IT is in CR2 register */
000192  2b02              CMP      r3,#2
000194  d007              BEQ      |L1.422|
;;;382      {
;;;383        usartxbase += 0x10;
;;;384      }
;;;385      else /* The IT is in CR3 register */
;;;386      {
;;;387        usartxbase += 0x14; 
000196  3014              ADDS     r0,r0,#0x14
                  |L1.408|
;;;388      }
;;;389      if (NewState != DISABLE)
000198  b13a              CBZ      r2,|L1.426|
;;;390      {
;;;391        *(vu32*)usartxbase  |= itmask;
00019a  6802              LDR      r2,[r0,#0]
00019c  4311              ORRS     r1,r1,r2
00019e  6001              STR      r1,[r0,#0]
;;;392      }
;;;393      else
;;;394      {
;;;395        *(vu32*)usartxbase &= ~itmask;
;;;396      }
;;;397    }
0001a0  4770              BX       lr
                  |L1.418|
0001a2  300c              ADDS     r0,r0,#0xc            ;379
0001a4  e7f8              B        |L1.408|
                  |L1.422|
0001a6  3010              ADDS     r0,r0,#0x10           ;383
0001a8  e7f6              B        |L1.408|
                  |L1.426|
0001aa  6802              LDR      r2,[r0,#0]            ;395
0001ac  ea220101          BIC      r1,r2,r1              ;395
0001b0  6001              STR      r1,[r0,#0]            ;395
0001b2  4770              BX       lr
;;;398    
                          ENDP

                  USART_DMACmd PROC
;;;414    *******************************************************************************/
;;;415    void USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState)
0001b4  b11a              CBZ      r2,|L1.446|
;;;416    {
;;;417      /* Check the parameters */
;;;418      assert_param(IS_USART_1234_PERIPH(USARTx));
;;;419      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;420      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;421    
;;;422      if (NewState != DISABLE)
;;;423      {
;;;424        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;425           DMAR bits in the USART CR3 register */
;;;426        USARTx->CR3 |= USART_DMAReq;
0001b6  8a82              LDRH     r2,[r0,#0x14]
0001b8  4311              ORRS     r1,r1,r2
0001ba  8281              STRH     r1,[r0,#0x14]
;;;427      }
;;;428      else
;;;429      {
;;;430        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;431           DMAR bits in the USART CR3 register */
;;;432        USARTx->CR3 &= (u16)~USART_DMAReq;
;;;433      }
;;;434    }
0001bc  4770              BX       lr
                  |L1.446|
0001be  8a82              LDRH     r2,[r0,#0x14]         ;432
0001c0  ea220101          BIC      r1,r2,r1              ;432
0001c4  8281              STRH     r1,[r0,#0x14]         ;432
0001c6  4770              BX       lr
;;;435    
                          ENDP

                  USART_SetAddress PROC
;;;445    *******************************************************************************/
;;;446    void USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address)
0001c8  8a02              LDRH     r2,[r0,#0x10]
;;;447    {
;;;448      /* Check the parameters */
;;;449      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;450      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;451        
;;;452      /* Clear the USART address */
;;;453      USARTx->CR2 &= CR2_Address_Mask;
0001ca  f022020f          BIC      r2,r2,#0xf
0001ce  8202              STRH     r2,[r0,#0x10]
;;;454      /* Set the USART address node */
;;;455      USARTx->CR2 |= USART_Address;
0001d0  8a02              LDRH     r2,[r0,#0x10]
0001d2  4311              ORRS     r1,r1,r2
0001d4  8201              STRH     r1,[r0,#0x10]
;;;456    }
0001d6  4770              BX       lr
;;;457    
                          ENDP

                  USART_WakeUpConfig PROC
;;;470    *******************************************************************************/
;;;471    void USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp)
0001d8  8982              LDRH     r2,[r0,#0xc]
;;;472    {
;;;473      /* Check the parameters */
;;;474      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;475      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;476      
;;;477      USARTx->CR1 &= CR1_WAKE_Mask;
0001da  f4226200          BIC      r2,r2,#0x800
0001de  8182              STRH     r2,[r0,#0xc]
;;;478      USARTx->CR1 |= USART_WakeUp;
0001e0  8982              LDRH     r2,[r0,#0xc]
0001e2  4311              ORRS     r1,r1,r2
0001e4  8181              STRH     r1,[r0,#0xc]
;;;479    }
0001e6  4770              BX       lr
;;;480    
                          ENDP

                  USART_ReceiverWakeUpCmd PROC
;;;491    *******************************************************************************/
;;;492    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0001e8  b121              CBZ      r1,|L1.500|
;;;493    {
;;;494      /* Check the parameters */
;;;495      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;496      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;497      
;;;498      if (NewState != DISABLE)
;;;499      {
;;;500        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;501        USARTx->CR1 |= CR1_RWU_Set;
0001ea  8981              LDRH     r1,[r0,#0xc]
0001ec  f0410102          ORR      r1,r1,#2
0001f0  8181              STRH     r1,[r0,#0xc]
;;;502      }
;;;503      else
;;;504      {
;;;505        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;506        USARTx->CR1 &= CR1_RWU_Reset;
;;;507      }
;;;508    }
0001f2  4770              BX       lr
                  |L1.500|
0001f4  8981              LDRH     r1,[r0,#0xc]          ;506
0001f6  f0210102          BIC      r1,r1,#2              ;506
0001fa  8181              STRH     r1,[r0,#0xc]          ;506
0001fc  4770              BX       lr
;;;509    
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;523    *******************************************************************************/
;;;524    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength)
0001fe  8a02              LDRH     r2,[r0,#0x10]
;;;525    {
;;;526      /* Check the parameters */
;;;527      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;528      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;529      
;;;530      USARTx->CR2 &= CR2_LBDL_Mask;
000200  f0220220          BIC      r2,r2,#0x20
000204  8202              STRH     r2,[r0,#0x10]
;;;531      USARTx->CR2 |= USART_LINBreakDetectLength;  
000206  8a02              LDRH     r2,[r0,#0x10]
000208  4311              ORRS     r1,r1,r2
00020a  8201              STRH     r1,[r0,#0x10]
;;;532    }
00020c  4770              BX       lr
;;;533    
                          ENDP

                  USART_LINCmd PROC
;;;544    *******************************************************************************/
;;;545    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00020e  b121              CBZ      r1,|L1.538|
;;;546    {
;;;547      /* Check the parameters */
;;;548      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;549      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;550      
;;;551      if (NewState != DISABLE)
;;;552      {
;;;553        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;554        USARTx->CR2 |= CR2_LINEN_Set;
000210  8a01              LDRH     r1,[r0,#0x10]
000212  f4414180          ORR      r1,r1,#0x4000
000216  8201              STRH     r1,[r0,#0x10]
;;;555      }
;;;556      else
;;;557      {
;;;558        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;559        USARTx->CR2 &= CR2_LINEN_Reset;
;;;560      }
;;;561    }
000218  4770              BX       lr
                  |L1.538|
00021a  8a01              LDRH     r1,[r0,#0x10]         ;559
00021c  f4214180          BIC      r1,r1,#0x4000         ;559
000220  8201              STRH     r1,[r0,#0x10]         ;559
000222  4770              BX       lr
;;;562    
                          ENDP

                  USART_SendData PROC
;;;572    *******************************************************************************/
;;;573    void USART_SendData(USART_TypeDef* USARTx, u16 Data)
000224  f3c10108          UBFX     r1,r1,#0,#9
;;;574    {
;;;575      /* Check the parameters */
;;;576      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;577      assert_param(IS_USART_DATA(Data)); 
;;;578        
;;;579      /* Transmit Data */
;;;580      USARTx->DR = (Data & (u16)0x01FF);
000228  8081              STRH     r1,[r0,#4]
;;;581    }
00022a  4770              BX       lr
;;;582    
                          ENDP

                  USART_ReceiveData PROC
;;;591    *******************************************************************************/
;;;592    u16 USART_ReceiveData(USART_TypeDef* USARTx)
00022c  8880              LDRH     r0,[r0,#4]
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;596      
;;;597      /* Receive Data */
;;;598      return (u16)(USARTx->DR & (u16)0x01FF);
00022e  f3c00008          UBFX     r0,r0,#0,#9
;;;599    }
000232  4770              BX       lr
;;;600    
                          ENDP

                  USART_SendBreak PROC
;;;609    *******************************************************************************/
;;;610    void USART_SendBreak(USART_TypeDef* USARTx)
000234  8981              LDRH     r1,[r0,#0xc]
;;;611    {
;;;612      /* Check the parameters */
;;;613      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;614      
;;;615      /* Send break characters */
;;;616      USARTx->CR1 |= CR1_SBK_Set;
000236  f0410101          ORR      r1,r1,#1
00023a  8181              STRH     r1,[r0,#0xc]
;;;617    }
00023c  4770              BX       lr
;;;618    
                          ENDP

                  USART_SetGuardTime PROC
;;;628    *******************************************************************************/
;;;629    void USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime)
00023e  8b02              LDRH     r2,[r0,#0x18]
;;;630    {    
;;;631      /* Check the parameters */
;;;632      assert_param(IS_USART_123_PERIPH(USARTx));
;;;633      
;;;634      /* Clear the USART Guard time */
;;;635      USARTx->GTPR &= GTPR_LSB_Mask;
000240  b2d2              UXTB     r2,r2
000242  8302              STRH     r2,[r0,#0x18]
;;;636      /* Set the USART guard time */
;;;637      USARTx->GTPR |= (u16)((u16)USART_GuardTime << 0x08);
000244  8b02              LDRH     r2,[r0,#0x18]
000246  ea422101          ORR      r1,r2,r1,LSL #8
00024a  8301              STRH     r1,[r0,#0x18]
;;;638    }
00024c  4770              BX       lr
;;;639    
                          ENDP

                  USART_SetPrescaler PROC
;;;650    *******************************************************************************/
;;;651    void USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler)
00024e  8b02              LDRH     r2,[r0,#0x18]
;;;652    { 
;;;653      /* Check the parameters */
;;;654      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;655      
;;;656      /* Clear the USART prescaler */
;;;657      USARTx->GTPR &= GTPR_MSB_Mask;
000250  f402427f          AND      r2,r2,#0xff00
000254  8302              STRH     r2,[r0,#0x18]
;;;658      /* Set the USART prescaler */
;;;659      USARTx->GTPR |= USART_Prescaler;
000256  8b02              LDRH     r2,[r0,#0x18]
000258  4311              ORRS     r1,r1,r2
00025a  8301              STRH     r1,[r0,#0x18]
;;;660    }
00025c  4770              BX       lr
;;;661    
                          ENDP

                  USART_SmartCardCmd PROC
;;;672    *******************************************************************************/
;;;673    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00025e  b121              CBZ      r1,|L1.618|
;;;674    {
;;;675      /* Check the parameters */
;;;676      assert_param(IS_USART_123_PERIPH(USARTx));
;;;677      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;678    
;;;679      if (NewState != DISABLE)
;;;680      {
;;;681        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;682        USARTx->CR3 |= CR3_SCEN_Set;
000260  8a81              LDRH     r1,[r0,#0x14]
000262  f0410120          ORR      r1,r1,#0x20
000266  8281              STRH     r1,[r0,#0x14]
;;;683      }
;;;684      else
;;;685      {
;;;686        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;687        USARTx->CR3 &= CR3_SCEN_Reset;
;;;688      }
;;;689    }
000268  4770              BX       lr
                  |L1.618|
00026a  8a81              LDRH     r1,[r0,#0x14]         ;687
00026c  f0210120          BIC      r1,r1,#0x20           ;687
000270  8281              STRH     r1,[r0,#0x14]         ;687
000272  4770              BX       lr
;;;690    
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;701    *******************************************************************************/
;;;702    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000274  b121              CBZ      r1,|L1.640|
;;;703    {
;;;704      /* Check the parameters */
;;;705      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;706      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;707    
;;;708      if (NewState != DISABLE)
;;;709      {
;;;710        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;711        USARTx->CR3 |= CR3_NACK_Set;
000276  8a81              LDRH     r1,[r0,#0x14]
000278  f0410110          ORR      r1,r1,#0x10
00027c  8281              STRH     r1,[r0,#0x14]
;;;712      }
;;;713      else
;;;714      {
;;;715        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;716        USARTx->CR3 &= CR3_NACK_Reset;
;;;717      }
;;;718    }
00027e  4770              BX       lr
                  |L1.640|
000280  8a81              LDRH     r1,[r0,#0x14]         ;716
000282  f0210110          BIC      r1,r1,#0x10           ;716
000286  8281              STRH     r1,[r0,#0x14]         ;716
000288  4770              BX       lr
;;;719    
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;730    *******************************************************************************/
;;;731    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00028a  b121              CBZ      r1,|L1.662|
;;;732    {
;;;733      /* Check the parameters */
;;;734      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;735      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;736      
;;;737      if (NewState != DISABLE)
;;;738      {
;;;739        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;740        USARTx->CR3 |= CR3_HDSEL_Set;
00028c  8a81              LDRH     r1,[r0,#0x14]
00028e  f0410108          ORR      r1,r1,#8
000292  8281              STRH     r1,[r0,#0x14]
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;745        USARTx->CR3 &= CR3_HDSEL_Reset;
;;;746      }
;;;747    }
000294  4770              BX       lr
                  |L1.662|
000296  8a81              LDRH     r1,[r0,#0x14]         ;745
000298  f0210108          BIC      r1,r1,#8              ;745
00029c  8281              STRH     r1,[r0,#0x14]         ;745
00029e  4770              BX       lr
;;;748    
                          ENDP

                  USART_IrDAConfig PROC
;;;761    *******************************************************************************/
;;;762    void USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode)
0002a0  8a82              LDRH     r2,[r0,#0x14]
;;;763    {
;;;764      /* Check the parameters */
;;;765      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;766      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;767        
;;;768      USARTx->CR3 &= CR3_IRLP_Mask;
0002a2  f0220204          BIC      r2,r2,#4
0002a6  8282              STRH     r2,[r0,#0x14]
;;;769      USARTx->CR3 |= USART_IrDAMode;
0002a8  8a82              LDRH     r2,[r0,#0x14]
0002aa  4311              ORRS     r1,r1,r2
0002ac  8281              STRH     r1,[r0,#0x14]
;;;770    }
0002ae  4770              BX       lr
;;;771    
                          ENDP

                  USART_IrDACmd PROC
;;;782    *******************************************************************************/
;;;783    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002b0  b121              CBZ      r1,|L1.700|
;;;784    {
;;;785      /* Check the parameters */
;;;786      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;787      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;788        
;;;789      if (NewState != DISABLE)
;;;790      {
;;;791        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;792        USARTx->CR3 |= CR3_IREN_Set;
0002b2  8a81              LDRH     r1,[r0,#0x14]
0002b4  f0410102          ORR      r1,r1,#2
0002b8  8281              STRH     r1,[r0,#0x14]
;;;793      }
;;;794      else
;;;795      {
;;;796        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;797        USARTx->CR3 &= CR3_IREN_Reset;
;;;798      }
;;;799    }
0002ba  4770              BX       lr
                  |L1.700|
0002bc  8a81              LDRH     r1,[r0,#0x14]         ;797
0002be  f0210102          BIC      r1,r1,#2              ;797
0002c2  8281              STRH     r1,[r0,#0x14]         ;797
0002c4  4770              BX       lr
;;;800    
                          ENDP

                  USART_GetFlagStatus PROC
;;;822    *******************************************************************************/
;;;823    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG)
0002c6  4602              MOV      r2,r0
;;;824    {
;;;825      FlagStatus bitstatus = RESET;
0002c8  2000              MOVS     r0,#0
;;;826    
;;;827      /* Check the parameters */
;;;828      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;829      assert_param(IS_USART_FLAG(USART_FLAG));
;;;830      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;831    
;;;832      if ((USARTx->SR & USART_FLAG) != (u16)RESET)
0002ca  8812              LDRH     r2,[r2,#0]
0002cc  420a              TST      r2,r1
0002ce  d000              BEQ      |L1.722|
;;;833      {
;;;834        bitstatus = SET;
0002d0  2001              MOVS     r0,#1
                  |L1.722|
;;;835      }
;;;836      else
;;;837      {
;;;838        bitstatus = RESET;
;;;839      }
;;;840      return bitstatus;
;;;841    }
0002d2  4770              BX       lr
;;;842    
                          ENDP

                  USART_ClearFlag PROC
;;;868    *******************************************************************************/
;;;869    void USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG)
0002d4  43c9              MVNS     r1,r1
;;;870    {
;;;871      /* Check the parameters */
;;;872      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;873      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;874      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;875       
;;;876      USARTx->SR = (u16)~USART_FLAG;
0002d6  8001              STRH     r1,[r0,#0]
;;;877    }
0002d8  4770              BX       lr
;;;878    
                          ENDP

                  USART_GetITStatus PROC
;;;901    *******************************************************************************/
;;;902    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
0002da  b410              PUSH     {r4}
;;;903    {
;;;904      u32 bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;905      ITStatus bitstatus = RESET;
0002dc  f04f0c00          MOV      r12,#0
;;;906    
;;;907      /* Check the parameters */
;;;908      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;909      assert_param(IS_USART_IT(USART_IT));
;;;910      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
;;;911      
;;;912      /* Get the USART register index */
;;;913      usartreg = (((u8)USART_IT) >> 0x05);
0002e0  f3c11342          UBFX     r3,r1,#5,#3
;;;914    
;;;915      /* Get the interrupt position */
;;;916      itmask = USART_IT & IT_Mask;
0002e4  f001021f          AND      r2,r1,#0x1f
;;;917    
;;;918      itmask = (u32)0x01 << itmask;
0002e8  2401              MOVS     r4,#1
0002ea  fa04f202          LSL      r2,r4,r2
;;;919      
;;;920      if (usartreg == 0x01) /* The IT  is in CR1 register */
0002ee  2b01              CMP      r3,#1
0002f0  d00f              BEQ      |L1.786|
;;;921      {
;;;922        itmask &= USARTx->CR1;
;;;923      }
;;;924      else if (usartreg == 0x02) /* The IT  is in CR2 register */
0002f2  2b02              CMP      r3,#2
0002f4  d010              BEQ      |L1.792|
;;;925      {
;;;926        itmask &= USARTx->CR2;
;;;927      }
;;;928      else /* The IT  is in CR3 register */
;;;929      {
;;;930        itmask &= USARTx->CR3;
0002f6  8a83              LDRH     r3,[r0,#0x14]
0002f8  401a              ANDS     r2,r2,r3
                  |L1.762|
;;;931      }
;;;932      
;;;933      bitpos = USART_IT >> 0x08;
0002fa  0a09              LSRS     r1,r1,#8
;;;934    
;;;935      bitpos = (u32)0x01 << bitpos;
0002fc  fa04f101          LSL      r1,r4,r1
;;;936      bitpos &= USARTx->SR;
000300  8800              LDRH     r0,[r0,#0]
000302  4008              ANDS     r0,r0,r1
;;;937    
;;;938      if ((itmask != (u16)RESET)&&(bitpos != (u16)RESET))
000304  b112              CBZ      r2,|L1.780|
000306  b108              CBZ      r0,|L1.780|
;;;939      {
;;;940        bitstatus = SET;
000308  f04f0c01          MOV      r12,#1
                  |L1.780|
;;;941      }
;;;942      else
;;;943      {
;;;944        bitstatus = RESET;
;;;945      }
;;;946      
;;;947      return bitstatus;  
;;;948    }
00030c  bc10              POP      {r4}
00030e  4660              MOV      r0,r12                ;947
000310  4770              BX       lr
                  |L1.786|
000312  8983              LDRH     r3,[r0,#0xc]          ;922
000314  401a              ANDS     r2,r2,r3              ;922
000316  e7f0              B        |L1.762|
                  |L1.792|
000318  8a03              LDRH     r3,[r0,#0x10]         ;926
00031a  401a              ANDS     r2,r2,r3              ;926
00031c  e7ed              B        |L1.762|
;;;949    
                          ENDP

                  USART_ClearITPendingBit PROC
;;;975    *******************************************************************************/
;;;976    void USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT)
00031e  0a09              LSRS     r1,r1,#8
;;;977    {
;;;978      u16 bitpos = 0x00, itmask = 0x00;
;;;979    
;;;980      /* Check the parameters */
;;;981      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;982      assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;983      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
;;;984      
;;;985      bitpos = USART_IT >> 0x08;
;;;986    
;;;987      itmask = (u16)((u16)0x01 << bitpos);
000320  2201              MOVS     r2,#1
000322  fa02f101          LSL      r1,r2,r1
;;;988      USARTx->SR = (u16)~itmask;
000326  43c9              MVNS     r1,r1
000328  8001              STRH     r1,[r0,#0]
;;;989    }
00032a  4770              BX       lr
;;;990    
                          ENDP

                  |L1.812|
                          DCD      0x40004c00
                  |L1.816|
                          DCD      0x51eb851f
