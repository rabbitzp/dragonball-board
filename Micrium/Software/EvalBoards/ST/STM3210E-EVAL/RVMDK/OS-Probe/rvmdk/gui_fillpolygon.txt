; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\gui_fillpolygon.o --depend=.\rvmdk\gui_fillpolygon.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\gui_fillpolygon.crf ..\..\..\..\..\uCGUI\GUI\Core\GUI_FillPolygon.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _DrawHLine PROC
;;;52     */
;;;53     static void _DrawHLine(int x0, int y, int x1) {
000000  b430              PUSH     {r4,r5}
000002  4604              MOV      r4,r0
000004  4694              MOV      r12,r2
;;;54       if (x0 < x1) {
;;;55         LCD_HL_DrawHLine(x0, y, x1);
000006  48b3              LDR      r0,|L1.724|
000008  4564              CMP      r4,r12                ;54
00000a  6dc0              LDR      r0,[r0,#0x5c]
00000c  6803              LDR      r3,[r0,#0]            ;54
00000e  da03              BGE      |L1.24|
000010  4620              MOV      r0,r4
000012  bc30              POP      {r4,r5}
000014  4662              MOV      r2,r12
000016  4718              BX       r3
                  |L1.24|
;;;56       } else {
;;;57         LCD_HL_DrawHLine(x1, y, x0);
000018  4622              MOV      r2,r4
00001a  bc30              POP      {r4,r5}
00001c  4660              MOV      r0,r12
00001e  4718              BX       r3
;;;58       }
;;;59     }
;;;60     
                          ENDP

                  _CheckYInterSect PROC
;;;74     */
;;;75     static int _CheckYInterSect(int y, int* px, const GUI_POINT*paPoint0, const GUI_POINT*paPoint1) {
000020  b430              PUSH     {r4,r5}
;;;76       int x0, y0, x1, y1;
;;;77       if (paPoint0->y <= (paPoint1)->y) {
000022  f9b24002          LDRSH    r4,[r2,#2]
000026  f9b35002          LDRSH    r5,[r3,#2]
00002a  42ac              CMP      r4,r5
00002c  dc10              BGT      |L1.80|
;;;78         y0 = paPoint0->y;
00002e  46a4              MOV      r12,r4
;;;79         if (y0 > y)      /* Check if there is an intersection ... (early out) */
000030  4584              CMP      r12,r0
000032  dd02              BLE      |L1.58|
;;;80           return 0;
;;;81         y1 = paPoint1->y;
;;;82         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;83           return 0;
;;;84         x0 = paPoint0->x;
;;;85         x1 = paPoint1->x;
;;;86       } else {
;;;87         y0 = paPoint1->y;
;;;88         if (y0 > y)      /* Check if there is an intersection ... (early out) */
;;;89           return 0;
;;;90         y1 = paPoint0->y;
;;;91         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;92           return 0;
;;;93         x0 = paPoint1->x;
;;;94         x1 = paPoint0->x;
;;;95       }
;;;96     /* Calculate intersection */
;;;97       {
;;;98         I32 Mul = (I32)(x1 - x0) * (I32)(y - y0);
;;;99         if (Mul > 0) {
;;;100          Mul += (y1 - y0) >> 1;	          /* for proper rounding */
;;;101        } else {
;;;102          Mul -= ((y1 - y0) >> 1) - 1;	    /* for proper rounding */
;;;103        }
;;;104        x0 += Mul / (y1 - y0);
;;;105      }
;;;106      *px = x0;
;;;107      return 1;
;;;108    } 
000034  bc30              POP      {r4,r5}
000036  2000              MOVS     r0,#0                 ;80
000038  4770              BX       lr
                  |L1.58|
00003a  462c              MOV      r4,r5                 ;81
00003c  4284              CMP      r4,r0                 ;82
00003e  da02              BGE      |L1.70|
000040  bc30              POP      {r4,r5}
000042  2000              MOVS     r0,#0                 ;83
000044  4770              BX       lr
                  |L1.70|
000046  f9b25000          LDRSH    r5,[r2,#0]            ;84
00004a  f9b32000          LDRSH    r2,[r3,#0]            ;85
00004e  e00e              B        |L1.110|
                  |L1.80|
000050  46ac              MOV      r12,r5                ;87
000052  4584              CMP      r12,r0                ;88
000054  dd02              BLE      |L1.92|
000056  bc30              POP      {r4,r5}
000058  2000              MOVS     r0,#0                 ;89
00005a  4770              BX       lr
                  |L1.92|
00005c  4284              CMP      r4,r0                 ;91
00005e  da02              BGE      |L1.102|
000060  bc30              POP      {r4,r5}
000062  2000              MOVS     r0,#0                 ;92
000064  4770              BX       lr
                  |L1.102|
000066  f9b35000          LDRSH    r5,[r3,#0]            ;93
00006a  f9b22000          LDRSH    r2,[r2,#0]            ;94
                  |L1.110|
00006e  eba0000c          SUB      r0,r0,r12             ;98
000072  1b52              SUBS     r2,r2,r5              ;98
000074  4350              MULS     r0,r2,r0              ;98
000076  2800              CMP      r0,#0                 ;99
000078  dd04              BLE      |L1.132|
00007a  eba4020c          SUB      r2,r4,r12             ;100
00007e  eb000062          ADD      r0,r0,r2,ASR #1       ;100
000082  e004              B        |L1.142|
                  |L1.132|
000084  eba4020c          SUB      r2,r4,r12             ;102
000088  eba00062          SUB      r0,r0,r2,ASR #1       ;102
00008c  1c40              ADDS     r0,r0,#1              ;102
                  |L1.142|
00008e  eba4020c          SUB      r2,r4,r12             ;104
000092  fb90f0f2          SDIV     r0,r0,r2              ;104
000096  4428              ADD      r0,r0,r5              ;104
000098  6008              STR      r0,[r1,#0]            ;106
00009a  bc30              POP      {r4,r5}
00009c  2001              MOVS     r0,#1                 ;107
00009e  4770              BX       lr
;;;109    
                          ENDP

                  _Add PROC
;;;115    */
;;;116    static void _Add(int x) {
0000a0  b410              PUSH     {r4}
;;;117      if (GL_FP_Cnt < GUI_FP_MAXCOUNT) {
0000a2  4c8d              LDR      r4,|L1.728|
0000a4  f8d4c000          LDR      r12,[r4,#0]  ; GL_FP_Cnt
0000a8  f1bc0f0c          CMP      r12,#0xc
0000ac  da11              BGE      |L1.210|
;;;118        int i;
;;;119        /* Move all entries to the right (bigger x-value) */
;;;120        for (i=GL_FP_Cnt; i ; i--) {
0000ae  4661              MOV      r1,r12
;;;121          if (_aX[i-1] < x)
0000b0  4b8a              LDR      r3,|L1.732|
0000b2  b149              CBZ      r1,|L1.200|
                  |L1.180|
0000b4  1e4a              SUBS     r2,r1,#1
0000b6  f9332012          LDRSH    r2,[r3,r2,LSL #1]
0000ba  4282              CMP      r2,r0
0000bc  db04              BLT      |L1.200|
;;;122            break;
;;;123          _aX[i] = _aX[i-1];
0000be  f8232011          STRH     r2,[r3,r1,LSL #1]
0000c2  1e49              SUBS     r1,r1,#1              ;120
0000c4  2900              CMP      r1,#0                 ;120
0000c6  d1f5              BNE      |L1.180|
                  |L1.200|
;;;124        }
;;;125        /* Insert new entry */
;;;126        _aX[i]    = x;
0000c8  f8230011          STRH     r0,[r3,r1,LSL #1]
;;;127        GL_FP_Cnt++;
0000cc  f10c0001          ADD      r0,r12,#1
0000d0  6020              STR      r0,[r4,#0]  ; GL_FP_Cnt
                  |L1.210|
;;;128      }
;;;129    }
0000d2  bc10              POP      {r4}
0000d4  4770              BX       lr
;;;130    
                          ENDP

                  _Init PROC
;;;136    */
;;;137    static void _Init(void) {
0000d6  4980              LDR      r1,|L1.728|
;;;138      GL_FP_Cnt = 0;
0000d8  2000              MOVS     r0,#0
0000da  6008              STR      r0,[r1,#0]  ; GL_FP_Cnt
;;;139    }
0000dc  4770              BX       lr
;;;140    
                          ENDP

                  _Flush PROC
;;;146    */
;;;147    static void _Flush(int x0, int y) {
0000de  e92d5ff0          PUSH     {r4-r12,lr}
0000e2  4607              MOV      r7,r0
0000e4  468b              MOV      r11,r1
;;;148      int i, x = 0;
0000e6  2000              MOVS     r0,#0
;;;149      char On=0;
0000e8  2500              MOVS     r5,#0
;;;150      for (i=0; i<GL_FP_Cnt; i++) {
0000ea  2400              MOVS     r4,#0
0000ec  f8df81e8          LDR      r8,|L1.728|
0000f0  f8d81000          LDR      r1,[r8,#0]  ; GL_FP_Cnt
0000f4  2900              CMP      r1,#0
0000f6  dd15              BLE      |L1.292|
;;;151        int xNew = _aX[i];
0000f8  f8df91e0          LDR      r9,|L1.732|
;;;152        if (On) {
;;;153          LCD_HL_DrawHLine(x0 + x, y, x0 + xNew);
0000fc  f8dfa1d4          LDR      r10,|L1.724|
                  |L1.256|
000100  f9396014          LDRSH    r6,[r9,r4,LSL #1]     ;151
000104  b135              CBZ      r5,|L1.276|
000106  f8da105c          LDR      r1,[r10,#0x5c]  ; GUI_Context
00010a  19ba              ADDS     r2,r7,r6
00010c  4438              ADD      r0,r0,r7
00010e  680b              LDR      r3,[r1,#0]
000110  4659              MOV      r1,r11
000112  4798              BLX      r3
                  |L1.276|
;;;154        }
;;;155        On ^= 1;
000114  f0850501          EOR      r5,r5,#1
;;;156        x = xNew;
000118  4630              MOV      r0,r6
00011a  1c64              ADDS     r4,r4,#1              ;150
00011c  f8d81000          LDR      r1,[r8,#0]            ;150  ; GL_FP_Cnt
000120  428c              CMP      r4,r1                 ;150
000122  dbed              BLT      |L1.256|
                  |L1.292|
;;;157      }
;;;158    }
000124  e8bd9ff0          POP      {r4-r12,pc}
;;;159    
                          ENDP

                  _AddPoint PROC
;;;167    */
;;;168    static void _AddPoint(int x, int y, int y0, int y1, int xOff, int yOff) {
000128  b430              PUSH     {r4,r5}
00012a  4604              MOV      r4,r0
00012c  f8ddc00c          LDR      r12,[sp,#0xc]
000130  9802              LDR      r0,[sp,#8]
;;;169      if ((y0 ^ y1) >= 0) {
000132  405a              EORS     r2,r2,r3
000134  d407              BMI      |L1.326|
;;;170        x += xOff;
000136  4420              ADD      r0,r0,r4
;;;171        LCD_HL_DrawHLine(x, y + yOff, x);    /* V-point, not crossing the polygon */
000138  4b66              LDR      r3,|L1.724|
00013a  4461              ADD      r1,r1,r12
00013c  4602              MOV      r2,r0
00013e  6ddb              LDR      r3,[r3,#0x5c]  ; GUI_Context
000140  681b              LDR      r3,[r3,#0]
000142  bc30              POP      {r4,r5}
000144  4718              BX       r3
                  |L1.326|
;;;172      } else {
;;;173        _Add(x);
000146  4620              MOV      r0,r4
000148  bc30              POP      {r4,r5}
00014a  e7fe              B        _Add
;;;174      }
;;;175    }
;;;176    
                          ENDP

                  _GetPrevPointDiffy PROC
;;;182    */
;;;183    static int _GetPrevPointDiffy(const GUI_POINT* paPoint, int i,
00014c  b430              PUSH     {r4,r5}
;;;184                                  const int NumPoints, const int y0) {
00014e  4604              MOV      r4,r0
;;;185      int j, y1;
;;;186      for (j = 0; j < (NumPoints - 1) ; j++) {
000150  2000              MOVS     r0,#0
000152  1e55              SUBS     r5,r2,#1
000154  2d00              CMP      r5,#0
000156  dd0f              BLE      |L1.376|
                  |L1.344|
;;;187        i = (i != 0) ? i - 1 : NumPoints - 1;
000158  b109              CBZ      r1,|L1.350|
00015a  1e49              SUBS     r1,r1,#1
00015c  e000              B        |L1.352|
                  |L1.350|
00015e  1e51              SUBS     r1,r2,#1
                  |L1.352|
;;;188        y1 = (paPoint + i)->y;
000160  eb040c81          ADD      r12,r4,r1,LSL #2
000164  f9bcc002          LDRSH    r12,[r12,#2]
;;;189        if (y1 != y0) {
000168  459c              CMP      r12,r3
00016a  d002              BEQ      |L1.370|
;;;190          return y1;
;;;191        }
;;;192      }
;;;193      return y0;
;;;194    }
00016c  bc30              POP      {r4,r5}
00016e  4660              MOV      r0,r12                ;190
000170  4770              BX       lr
                  |L1.370|
000172  1c40              ADDS     r0,r0,#1              ;186
000174  42a8              CMP      r0,r5                 ;186
000176  dbef              BLT      |L1.344|
                  |L1.376|
000178  bc30              POP      {r4,r5}
00017a  4618              MOV      r0,r3                 ;193
00017c  4770              BX       lr
;;;195    
                          ENDP

                  GL_FillPolygon PROC
;;;207    */
;;;208    void GL_FillPolygon  (const GUI_POINT*paPoint, int NumPoints, int xOff, int yOff) {
00017e  e92d4ff0          PUSH     {r4-r11,lr}
000182  b085              SUB      sp,sp,#0x14
000184  4606              MOV      r6,r0
000186  4688              MOV      r8,r1
000188  4692              MOV      r10,r2
00018a  469b              MOV      r11,r3
;;;209      int i, y;
;;;210      int yMin = GUI_YMAX;
00018c  f64074ff          MOV      r4,#0xfff
;;;211      int yMax = GUI_YMIN;
000190  f1c40900          RSB      r9,r4,#0
;;;212    /* First step : find uppermost and lowermost coordinates */
;;;213      for (i=0; i<NumPoints; i++) {
000194  2100              MOVS     r1,#0
000196  f1b80f00          CMP      r8,#0
00019a  dd0c              BLE      |L1.438|
                  |L1.412|
;;;214        y = (paPoint + i)->y;
00019c  eb060081          ADD      r0,r6,r1,LSL #2
0001a0  f9b00002          LDRSH    r0,[r0,#2]
;;;215        if (y < yMin)
0001a4  42a0              CMP      r0,r4
0001a6  da00              BGE      |L1.426|
;;;216          yMin = y;
0001a8  4604              MOV      r4,r0
                  |L1.426|
;;;217        if (y > yMax)
0001aa  4548              CMP      r0,r9
0001ac  dd00              BLE      |L1.432|
;;;218          yMax = y;
0001ae  4681              MOV      r9,r0
                  |L1.432|
0001b0  1c49              ADDS     r1,r1,#1              ;213
0001b2  4541              CMP      r1,r8                 ;213
0001b4  dbf2              BLT      |L1.412|
                  |L1.438|
;;;219      }
;;;220    /* Use Clipping rect to reduce calculation (if possible) */
;;;221      if (GUI_Context.pClipRect_HL) {
0001b6  4847              LDR      r0,|L1.724|
0001b8  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
0001ba  b168              CBZ      r0,|L1.472|
;;;222        if (yMax > (GUI_Context.pClipRect_HL->y1 - yOff))
0001bc  f9b01006          LDRSH    r1,[r0,#6]
0001c0  eba1010b          SUB      r1,r1,r11
0001c4  4549              CMP      r1,r9
0001c6  da00              BGE      |L1.458|
;;;223          yMax = (GUI_Context.pClipRect_HL->y1 - yOff);
0001c8  4689              MOV      r9,r1
                  |L1.458|
;;;224        if (yMin < (GUI_Context.pClipRect_HL->y0 - yOff))
0001ca  f9b00002          LDRSH    r0,[r0,#2]
0001ce  eba0000b          SUB      r0,r0,r11
0001d2  42a0              CMP      r0,r4
0001d4  dd00              BLE      |L1.472|
;;;225          yMin = (GUI_Context.pClipRect_HL->y0 - yOff);
0001d6  4604              MOV      r4,r0
                  |L1.472|
;;;226      }
;;;227    /* Second step: Calculate and draw horizontal lines */
;;;228      for (y=yMin; y<=yMax; y++) {
0001d8  454c              CMP      r4,r9
0001da  dc58              BGT      |L1.654|
;;;229        _Init();
;;;230        /* find next intersection and count lines*/
;;;231        for (i=0; i<NumPoints; i++) {
;;;232          int i1 = (i < (NumPoints - 1)) ? i + 1 : 0;
0001dc  f1a80001          SUB      r0,r8,#1
0001e0  9004              STR      r0,[sp,#0x10]
                  |L1.482|
0001e2  f7fffffe          BL       _Init
0001e6  2500              MOVS     r5,#0                 ;231
0001e8  f1b80f00          CMP      r8,#0                 ;231
0001ec  dd47              BLE      |L1.638|
;;;233          int y0 = (paPoint + i )->y;
;;;234          int y1 = (paPoint + i1)->y;
;;;235          /* Check if starting point is on line */
;;;236          if (y0 == y) {
;;;237            if (y1 == y) {  /* Add the entire line */
;;;238              _DrawHLine((paPoint + i )->x + xOff , y + yOff, (paPoint + i1)->x + xOff);
0001ee  eb04000b          ADD      r0,r4,r11
0001f2  9003              STR      r0,[sp,#0xc]
                  |L1.500|
0001f4  9804              LDR      r0,[sp,#0x10]         ;232
0001f6  4285              CMP      r5,r0                 ;232
0001f8  da01              BGE      |L1.510|
0001fa  1c69              ADDS     r1,r5,#1              ;232
0001fc  e000              B        |L1.512|
                  |L1.510|
0001fe  2100              MOVS     r1,#0                 ;232
                  |L1.512|
000200  eb060285          ADD      r2,r6,r5,LSL #2       ;233
000204  f9b20002          LDRSH    r0,[r2,#2]            ;233
000208  eb060381          ADD      r3,r6,r1,LSL #2       ;234
00020c  f9b37002          LDRSH    r7,[r3,#2]            ;234
000210  42a0              CMP      r0,r4                 ;236
000212  d120              BNE      |L1.598|
000214  42a7              CMP      r7,r4                 ;237
000216  d10a              BNE      |L1.558|
000218  f9360021          LDRSH    r0,[r6,r1,LSL #2]
00021c  9903              LDR      r1,[sp,#0xc]
00021e  eb00020a          ADD      r2,r0,r10
000222  f9360025          LDRSH    r0,[r6,r5,LSL #2]
000226  4450              ADD      r0,r0,r10
000228  f7fffffe          BL       _DrawHLine
00022c  e024              B        |L1.632|
                  |L1.558|
;;;239            } else {        /* Add only one point */
;;;240              int yPrev = _GetPrevPointDiffy(paPoint, i, NumPoints, y);
00022e  4623              MOV      r3,r4
000230  4642              MOV      r2,r8
000232  4629              MOV      r1,r5
000234  4630              MOV      r0,r6
000236  f7fffffe          BL       _GetPrevPointDiffy
;;;241              if (yPrev != y) {
00023a  42a0              CMP      r0,r4
00023c  d01c              BEQ      |L1.632|
;;;242                _AddPoint((paPoint + i)->x, y, yPrev - y, y1 - y, xOff, yOff);
00023e  1b02              SUBS     r2,r0,r4
000240  f8cdb004          STR      r11,[sp,#4]
000244  f8cda000          STR      r10,[sp,#0]
000248  1b3b              SUBS     r3,r7,r4
00024a  f9360025          LDRSH    r0,[r6,r5,LSL #2]
00024e  4621              MOV      r1,r4
000250  f7fffffe          BL       _AddPoint
000254  e010              B        |L1.632|
                  |L1.598|
;;;243              } 
;;;244            }
;;;245          } else if (y1 != y) {  /* Ignore if end-point is on the line */
000256  42a7              CMP      r7,r4
000258  d00e              BEQ      |L1.632|
;;;246            if (((y1 >= y) && (y0 <= y)) || ((y0 >= y) && (y1 <= y))) {
00025a  db01              BLT      |L1.608|
00025c  42a0              CMP      r0,r4
00025e  dd03              BLE      |L1.616|
                  |L1.608|
000260  42a0              CMP      r0,r4
000262  db09              BLT      |L1.632|
000264  42a7              CMP      r7,r4
000266  dc07              BGT      |L1.632|
                  |L1.616|
;;;247              int xIntersect;
;;;248              if (_CheckYInterSect(y, &xIntersect, paPoint + i, paPoint + i1)) {
000268  a902              ADD      r1,sp,#8
00026a  4620              MOV      r0,r4
00026c  f7fffffe          BL       _CheckYInterSect
000270  b110              CBZ      r0,|L1.632|
;;;249                _Add(xIntersect);
000272  9802              LDR      r0,[sp,#8]
000274  f7fffffe          BL       _Add
                  |L1.632|
000278  1c6d              ADDS     r5,r5,#1              ;231
00027a  4545              CMP      r5,r8                 ;231
00027c  dbba              BLT      |L1.500|
                  |L1.638|
;;;250              }
;;;251            }
;;;252          }
;;;253        }
;;;254        _Flush(xOff, y + yOff);
00027e  eb04010b          ADD      r1,r4,r11
000282  4650              MOV      r0,r10
000284  f7fffffe          BL       _Flush
000288  1c64              ADDS     r4,r4,#1              ;228
00028a  454c              CMP      r4,r9                 ;228
00028c  dda9              BLE      |L1.482|
                  |L1.654|
;;;255      }  
;;;256    }
00028e  b005              ADD      sp,sp,#0x14
000290  e8bd8ff0          POP      {r4-r11,pc}
;;;257    
                          ENDP

                  GUI_FillPolygon PROC
;;;261    */
;;;262    void GUI_FillPolygon(const GUI_POINT* pPoints, int NumPoints, int x0, int y0) {
000294  e92d41f0          PUSH     {r4-r8,lr}
000298  4606              MOV      r6,r0
00029a  460f              MOV      r7,r1
00029c  4614              MOV      r4,r2
00029e  461d              MOV      r5,r3
;;;263      GUI_LOCK();
0002a0  f7fffffe          BL       GUI_Lock
;;;264      #if (GUI_WINSUPPORT)
;;;265        WM_ADDORG(x0, y0);
0002a4  480b              LDR      r0,|L1.724|
0002a6  6c41              LDR      r1,[r0,#0x44]  ; GUI_Context
0002a8  440c              ADD      r4,r4,r1
0002aa  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
0002ac  4405              ADD      r5,r5,r0
;;;266        WM_ITERATE_START(NULL); {
0002ae  2000              MOVS     r0,#0
0002b0  f7fffffe          BL       WM__InitIVRSearch
0002b4  b148              CBZ      r0,|L1.714|
                  |L1.694|
;;;267      #endif
;;;268      GL_FillPolygon (pPoints, NumPoints, x0, y0);
0002b6  462b              MOV      r3,r5
0002b8  4622              MOV      r2,r4
0002ba  4639              MOV      r1,r7
0002bc  4630              MOV      r0,r6
0002be  f7fffffe          BL       GL_FillPolygon
;;;269      #if (GUI_WINSUPPORT)
;;;270        } WM_ITERATE_END();
0002c2  f7fffffe          BL       WM__GetNextIVR
0002c6  2800              CMP      r0,#0
0002c8  d1f5              BNE      |L1.694|
                  |L1.714|
;;;271      #endif
;;;272      GUI_UNLOCK();
0002ca  e8bd41f0          POP      {r4-r8,lr}
0002ce  f7ffbffe          B.W      GUI_Unlock
;;;273    }
;;;274    
                          ENDP

0002d2  0000              DCW      0x0000
                  |L1.724|
                          DCD      GUI_Context
                  |L1.728|
                          DCD      ||.data||
                  |L1.732|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=6

                  _aX
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  GL_FP_Cnt
                          DCD      0x00000000
