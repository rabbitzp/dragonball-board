; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\stm32f10x_tim.o --depend=.\rvmdk\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\stm32f10x_tim.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;135    *******************************************************************************/
;;;136    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;137    {
;;;138      /* Check the parameters */
;;;139      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;140     
;;;141      switch (*(u32*)&TIMx)
000002  4afa              LDR      r2,|L1.1004|
000004  1a81              SUBS     r1,r0,r2
000006  4290              CMP      r0,r2
000008  d053              BEQ      |L1.178|
00000a  dc15              BGT      |L1.56|
00000c  f1b04f80          CMP      r0,#0x40000000
000010  d031              BEQ      |L1.118|
000012  f5116040          ADDS     r0,r1,#0xc00
000016  d038              BEQ      |L1.138|
000018  f5b06f80          CMP      r0,#0x400
00001c  d03f              BEQ      |L1.158|
00001e  f5b06f00          CMP      r0,#0x800
000022  d15a              BNE      |L1.218|
;;;142      {
;;;143        case TIM1_BASE:
;;;144          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
;;;145          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
;;;146          break; 
;;;147          
;;;148        case TIM2_BASE:
;;;149          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;150          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;151          break;
;;;152     
;;;153        case TIM3_BASE:
;;;154          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
;;;155          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
;;;156          break;
;;;157     
;;;158        case TIM4_BASE:
;;;159          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
;;;160          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
;;;161          break;
;;;162          
;;;163        case TIM5_BASE:
;;;164          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000024  2101              MOVS     r1,#1
000026  2008              MOVS     r0,#8
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;165          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
00002c  2100              MOVS     r1,#0
00002e  e8bd4010          POP      {r4,lr}
000032  2008              MOVS     r0,#8
000034  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.56|
000038  f5b16f80          CMP      r1,#0x400             ;141
00003c  d043              BEQ      |L1.198|
00003e  f5b13f8e          CMP      r1,#0x11c00           ;141
000042  d00d              BEQ      |L1.96|
000044  f5b13f92          CMP      r1,#0x12400           ;141
000048  d147              BNE      |L1.218|
;;;166          break;
;;;167          
;;;168        case TIM6_BASE:
;;;169          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
;;;170          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
;;;171          break;
;;;172          
;;;173        case TIM7_BASE:
;;;174          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
;;;175          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
;;;176          break;
;;;177          
;;;178        case TIM8_BASE:
;;;179          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  0348              LSLS     r0,r1,#13
00004e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;180          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
000052  e8bd4010          POP      {r4,lr}
000056  2100              MOVS     r1,#0
000058  f44f5000          MOV      r0,#0x2000
00005c  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.96|
000060  2101              MOVS     r1,#1                 ;144
000062  02c8              LSLS     r0,r1,#11             ;144
000064  f7fffffe          BL       RCC_APB2PeriphResetCmd
000068  e8bd4010          POP      {r4,lr}               ;145
00006c  2100              MOVS     r1,#0                 ;145
00006e  f44f6000          MOV      r0,#0x800             ;145
000072  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.118|
000076  2101              MOVS     r1,#1                 ;149
000078  4608              MOV      r0,r1                 ;149
00007a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007e  2100              MOVS     r1,#0                 ;150
000080  e8bd4010          POP      {r4,lr}               ;150
000084  2001              MOVS     r0,#1                 ;150
000086  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.138|
00008a  2101              MOVS     r1,#1                 ;154
00008c  2002              MOVS     r0,#2                 ;154
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  2100              MOVS     r1,#0                 ;155
000094  e8bd4010          POP      {r4,lr}               ;155
000098  2002              MOVS     r0,#2                 ;155
00009a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.158|
00009e  2101              MOVS     r1,#1                 ;159
0000a0  2004              MOVS     r0,#4                 ;159
0000a2  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000a6  2100              MOVS     r1,#0                 ;160
0000a8  e8bd4010          POP      {r4,lr}               ;160
0000ac  2004              MOVS     r0,#4                 ;160
0000ae  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.178|
0000b2  2101              MOVS     r1,#1                 ;169
0000b4  2010              MOVS     r0,#0x10              ;169
0000b6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000ba  2100              MOVS     r1,#0                 ;170
0000bc  e8bd4010          POP      {r4,lr}               ;170
0000c0  2010              MOVS     r0,#0x10              ;170
0000c2  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.198|
0000c6  2101              MOVS     r1,#1                 ;174
0000c8  2020              MOVS     r0,#0x20              ;174
0000ca  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000ce  2100              MOVS     r1,#0                 ;175
0000d0  e8bd4010          POP      {r4,lr}               ;175
0000d4  2020              MOVS     r0,#0x20              ;175
0000d6  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.218|
;;;181          break; 
;;;182          
;;;183        default:
;;;184          break;
;;;185      }
;;;186    }
0000da  bd10              POP      {r4,pc}
;;;187    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;199    *******************************************************************************/
;;;200    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0000dc  8802              LDRH     r2,[r0,#0]
;;;201    {
;;;202      /* Check the parameters */
;;;203      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;204      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;205      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;206    
;;;207      /* Select the Counter Mode and set the clock division */
;;;208      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
0000de  f002028f          AND      r2,r2,#0x8f
0000e2  8002              STRH     r2,[r0,#0]
;;;209      TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
0000e4  88ca              LDRH     r2,[r1,#6]
0000e6  884b              LDRH     r3,[r1,#2]
0000e8  431a              ORRS     r2,r2,r3
0000ea  8803              LDRH     r3,[r0,#0]
0000ec  431a              ORRS     r2,r2,r3
0000ee  8002              STRH     r2,[r0,#0]
;;;210                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;211      /* Set the Autoreload value */
;;;212      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
0000f0  888a              LDRH     r2,[r1,#4]
0000f2  8582              STRH     r2,[r0,#0x2c]
;;;213    
;;;214      /* Set the Prescaler value */
;;;215      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
0000f4  880a              LDRH     r2,[r1,#0]
0000f6  8502              STRH     r2,[r0,#0x28]
;;;216    
;;;217      /* Generate an update event to reload the Prescaler value immediatly */
;;;218      TIMx->EGR = TIM_PSCReloadMode_Immediate;
0000f8  2201              MOVS     r2,#1
0000fa  8282              STRH     r2,[r0,#0x14]
;;;219        
;;;220      if (((*(u32*)&TIMx) == TIM1_BASE) || ((*(u32*)&TIMx) == TIM8_BASE))  
0000fc  f1a04280          SUB      r2,r0,#0x40000000
000100  f5b23296          SUBS     r2,r2,#0x12c00
000104  d002              BEQ      |L1.268|
000106  f5b26200          SUBS     r2,r2,#0x800
00010a  d101              BNE      |L1.272|
                  |L1.268|
;;;221      {
;;;222        /* Set the Repetition Counter value */
;;;223        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
00010c  7a09              LDRB     r1,[r1,#8]
00010e  8601              STRH     r1,[r0,#0x30]
                  |L1.272|
;;;224      }        
;;;225    }
000110  4770              BX       lr
;;;226    
                          ENDP

                  TIM_OC1Init PROC
;;;238    *******************************************************************************/
;;;239    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000112  b410              PUSH     {r4}
;;;240    {
;;;241      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;242       
;;;243      /* Check the parameters */
;;;244      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;245      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;246      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;247      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;248    
;;;249      /* Disable the Channel 1: Reset the CC1E Bit */
;;;250      TIMx->CCER &= CCER_CC1E_Reset;
000114  8c02              LDRH     r2,[r0,#0x20]
000116  f0220201          BIC      r2,r2,#1
00011a  8402              STRH     r2,[r0,#0x20]
;;;251      
;;;252      /* Get the TIMx CCER register value */
;;;253      tmpccer = TIMx->CCER;
00011c  8c03              LDRH     r3,[r0,#0x20]
;;;254    
;;;255      /* Get the TIMx CR2 register value */
;;;256      tmpcr2 =  TIMx->CR2;
00011e  8882              LDRH     r2,[r0,#4]
;;;257      
;;;258      /* Get the TIMx CCMR1 register value */
;;;259      tmpccmrx = TIMx->CCMR1;
000120  f8b0c018          LDRH     r12,[r0,#0x18]
;;;260        
;;;261      /* Reset the Output Compare Mode Bits */
;;;262      tmpccmrx &= CCMR_OC13M_Mask;
000124  f02c0c70          BIC      r12,r12,#0x70
;;;263      
;;;264      /* Select the Output Compare Mode */
;;;265      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000128  880c              LDRH     r4,[r1,#0]
00012a  ea440c0c          ORR      r12,r4,r12
;;;266      
;;;267      /* Reset the Output Polarity level */
;;;268      tmpccer &= CCER_CC1P_Reset;
00012e  f0230302          BIC      r3,r3,#2
;;;269    
;;;270      /* Set the Output Compare Polarity */
;;;271      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000132  890c              LDRH     r4,[r1,#8]
000134  4323              ORRS     r3,r3,r4
;;;272      
;;;273      /* Set the Output State */
;;;274      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000136  884c              LDRH     r4,[r1,#2]
000138  4323              ORRS     r3,r3,r4
;;;275      
;;;276      /* Set the Capture Compare Register value */
;;;277      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
00013a  88cc              LDRH     r4,[r1,#6]
00013c  8684              STRH     r4,[r0,#0x34]
;;;278      
;;;279      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
00013e  f1a04480          SUB      r4,r0,#0x40000000
000142  f5b43496          SUBS     r4,r4,#0x12c00
000146  d002              BEQ      |L1.334|
000148  f5b46400          SUBS     r4,r4,#0x800
00014c  d10f              BNE      |L1.366|
                  |L1.334|
;;;280      {
;;;281        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;282        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;283        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;284        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;285        
;;;286        /* Reset the Output N Polarity level */
;;;287        tmpccer &= CCER_CC1NP_Reset;
00014e  f0230308          BIC      r3,r3,#8
;;;288    
;;;289        /* Set the Output N Polarity */
;;;290        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000152  894c              LDRH     r4,[r1,#0xa]
000154  4323              ORRS     r3,r3,r4
;;;291    
;;;292        /* Reset the Output N State */
;;;293        tmpccer &= CCER_CC1NE_Reset;
000156  f0230304          BIC      r3,r3,#4
;;;294        
;;;295        /* Set the Output N State */
;;;296        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
00015a  888c              LDRH     r4,[r1,#4]
00015c  4323              ORRS     r3,r3,r4
;;;297    
;;;298        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;299        tmpcr2 &= CR2_OIS1_Reset;
00015e  f4224201          BIC      r2,r2,#0x8100
;;;300        tmpcr2 &= CR2_OIS1N_Reset;
000162  f4224202          BIC      r2,r2,#0x8200
;;;301    
;;;302        /* Set the Output Idle state */
;;;303        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000166  898c              LDRH     r4,[r1,#0xc]
000168  4322              ORRS     r2,r2,r4
;;;304    
;;;305        /* Set the Output N Idle state */
;;;306        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
00016a  89c9              LDRH     r1,[r1,#0xe]
00016c  430a              ORRS     r2,r2,r1
                  |L1.366|
;;;307      }
;;;308      /* Write to TIMx CR2 */
;;;309      TIMx->CR2 = tmpcr2;
00016e  8082              STRH     r2,[r0,#4]
;;;310      
;;;311      /* Write to TIMx CCMR1 */
;;;312      TIMx->CCMR1 = tmpccmrx;
000170  f8a0c018          STRH     r12,[r0,#0x18]
;;;313      
;;;314      /* Write to TIMx CCER */
;;;315      TIMx->CCER = tmpccer;
000174  8403              STRH     r3,[r0,#0x20]
;;;316    }
000176  bc10              POP      {r4}
000178  4770              BX       lr
;;;317    
                          ENDP

                  TIM_OC2Init PROC
;;;329    *******************************************************************************/
;;;330    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00017a  b410              PUSH     {r4}
;;;331    {
;;;332      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;333       
;;;334      /* Check the parameters */
;;;335      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;336      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;337      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;338      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;339    
;;;340      /* Disable the Channel 2: Reset the CC2E Bit */
;;;341      TIMx->CCER &= CCER_CC2E_Reset;
00017c  8c02              LDRH     r2,[r0,#0x20]
00017e  f0220210          BIC      r2,r2,#0x10
000182  8402              STRH     r2,[r0,#0x20]
;;;342      
;;;343      /* Get the TIMx CCER register value */  
;;;344      tmpccer = TIMx->CCER;
000184  8c02              LDRH     r2,[r0,#0x20]
;;;345    
;;;346      /* Get the TIMx CR2 register value */
;;;347      tmpcr2 =  TIMx->CR2;
000186  8883              LDRH     r3,[r0,#4]
;;;348      
;;;349      /* Get the TIMx CCMR1 register value */
;;;350      tmpccmrx = TIMx->CCMR1;
000188  f8b0c018          LDRH     r12,[r0,#0x18]
;;;351        
;;;352      /* Reset the Output Compare Mode Bits */
;;;353      tmpccmrx &= CCMR_OC24M_Mask;
00018c  f42c4ce0          BIC      r12,r12,#0x7000
;;;354      
;;;355      /* Select the Output Compare Mode */
;;;356      tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
000190  880c              LDRH     r4,[r1,#0]
000192  0624              LSLS     r4,r4,#24
000194  ea4c4c14          ORR      r12,r12,r4,LSR #16
;;;357      
;;;358      /* Reset the Output Polarity level */
;;;359      tmpccer &= CCER_CC2P_Reset;
000198  f0220220          BIC      r2,r2,#0x20
;;;360    
;;;361      /* Set the Output Compare Polarity */
;;;362      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 4);
00019c  890c              LDRH     r4,[r1,#8]
00019e  0524              LSLS     r4,r4,#20
0001a0  ea424214          ORR      r2,r2,r4,LSR #16
;;;363      
;;;364      /* Set the Output State */
;;;365      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 4);
0001a4  884c              LDRH     r4,[r1,#2]
0001a6  0524              LSLS     r4,r4,#20
0001a8  ea424214          ORR      r2,r2,r4,LSR #16
;;;366      
;;;367      /* Set the Capture Compare Register value */
;;;368      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
0001ac  88cc              LDRH     r4,[r1,#6]
0001ae  8704              STRH     r4,[r0,#0x38]
;;;369      
;;;370      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
0001b0  f1a04480          SUB      r4,r0,#0x40000000
0001b4  f5b43496          SUBS     r4,r4,#0x12c00
0001b8  d002              BEQ      |L1.448|
0001ba  f5b46400          SUBS     r4,r4,#0x800
0001be  d117              BNE      |L1.496|
                  |L1.448|
;;;371      {
;;;372        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;373        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;374        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;375        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;376        
;;;377        /* Reset the Output N Polarity level */
;;;378        tmpccer &= CCER_CC2NP_Reset;
0001c0  f0220280          BIC      r2,r2,#0x80
;;;379    
;;;380        /* Set the Output N Polarity */
;;;381        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
0001c4  894c              LDRH     r4,[r1,#0xa]
0001c6  0524              LSLS     r4,r4,#20
0001c8  ea424214          ORR      r2,r2,r4,LSR #16
;;;382    
;;;383        /* Reset the Output N State */
;;;384        tmpccer &= CCER_CC2NE_Reset;
0001cc  f0220240          BIC      r2,r2,#0x40
;;;385        
;;;386        /* Set the Output N State */
;;;387        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 4);
0001d0  888c              LDRH     r4,[r1,#4]
0001d2  0524              LSLS     r4,r4,#20
0001d4  ea424214          ORR      r2,r2,r4,LSR #16
;;;388    
;;;389        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;390        tmpcr2 &= CR2_OIS2_Reset;
0001d8  f4234304          BIC      r3,r3,#0x8400
;;;391        tmpcr2 &= CR2_OIS2N_Reset;
0001dc  f4234308          BIC      r3,r3,#0x8800
;;;392    
;;;393        /* Set the Output Idle state */
;;;394        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 2);
0001e0  898c              LDRH     r4,[r1,#0xc]
0001e2  04a4              LSLS     r4,r4,#18
0001e4  ea434314          ORR      r3,r3,r4,LSR #16
;;;395    
;;;396        /* Set the Output N Idle state */
;;;397        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
0001e8  89c9              LDRH     r1,[r1,#0xe]
0001ea  0489              LSLS     r1,r1,#18
0001ec  ea434311          ORR      r3,r3,r1,LSR #16
                  |L1.496|
;;;398      }
;;;399    
;;;400      /* Write to TIMx CR2 */
;;;401      TIMx->CR2 = tmpcr2;
0001f0  8083              STRH     r3,[r0,#4]
;;;402      
;;;403      /* Write to TIMx CCMR1 */
;;;404      TIMx->CCMR1 = tmpccmrx;
0001f2  f8a0c018          STRH     r12,[r0,#0x18]
;;;405      
;;;406      /* Write to TIMx CCER */
;;;407      TIMx->CCER = tmpccer;
0001f6  8402              STRH     r2,[r0,#0x20]
;;;408    }
0001f8  bc10              POP      {r4}
0001fa  4770              BX       lr
;;;409    
                          ENDP

                  TIM_OC3Init PROC
;;;421    *******************************************************************************/
;;;422    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0001fc  b410              PUSH     {r4}
;;;423    {
;;;424      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;425       
;;;426      /* Check the parameters */
;;;427      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;428      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;429      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;430      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;431    
;;;432      /* Disable the Channel 2: Reset the CC2E Bit */
;;;433      TIMx->CCER &= CCER_CC3E_Reset;
0001fe  8c02              LDRH     r2,[r0,#0x20]
000200  f4227280          BIC      r2,r2,#0x100
000204  8402              STRH     r2,[r0,#0x20]
;;;434      
;;;435      /* Get the TIMx CCER register value */
;;;436      tmpccer = TIMx->CCER;
000206  8c03              LDRH     r3,[r0,#0x20]
;;;437    
;;;438      /* Get the TIMx CR2 register value */
;;;439      tmpcr2 =  TIMx->CR2;
000208  8882              LDRH     r2,[r0,#4]
;;;440      
;;;441      /* Get the TIMx CCMR2 register value */
;;;442      tmpccmrx = TIMx->CCMR2;
00020a  f8b0c01c          LDRH     r12,[r0,#0x1c]
;;;443        
;;;444      /* Reset the Output Compare Mode Bits */
;;;445      tmpccmrx &= CCMR_OC13M_Mask;
00020e  f02c0c70          BIC      r12,r12,#0x70
;;;446      
;;;447      /* Select the Output Compare Mode */
;;;448      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000212  880c              LDRH     r4,[r1,#0]
000214  ea440c0c          ORR      r12,r4,r12
;;;449      
;;;450      /* Reset the Output Polarity level */
;;;451      tmpccer &= CCER_CC3P_Reset;
000218  f4237300          BIC      r3,r3,#0x200
;;;452    
;;;453      /* Set the Output Compare Polarity */
;;;454      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00021c  890c              LDRH     r4,[r1,#8]
00021e  0624              LSLS     r4,r4,#24
000220  ea434314          ORR      r3,r3,r4,LSR #16
;;;455      
;;;456      /* Set the Output State */
;;;457      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 8);
000224  884c              LDRH     r4,[r1,#2]
000226  0624              LSLS     r4,r4,#24
000228  ea434314          ORR      r3,r3,r4,LSR #16
;;;458      
;;;459      /* Set the Capture Compare Register value */
;;;460      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00022c  88cc              LDRH     r4,[r1,#6]
00022e  8784              STRH     r4,[r0,#0x3c]
;;;461      
;;;462      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000230  f1a04480          SUB      r4,r0,#0x40000000
000234  f5b43496          SUBS     r4,r4,#0x12c00
000238  d002              BEQ      |L1.576|
00023a  f5b46400          SUBS     r4,r4,#0x800
00023e  d117              BNE      |L1.624|
                  |L1.576|
;;;463      {
;;;464        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;465        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;466        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;467        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;468        
;;;469        /* Reset the Output N Polarity level */
;;;470        tmpccer &= CCER_CC3NP_Reset;
000240  f4236300          BIC      r3,r3,#0x800
;;;471    
;;;472        /* Set the Output N Polarity */
;;;473        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000244  894c              LDRH     r4,[r1,#0xa]
000246  0624              LSLS     r4,r4,#24
000248  ea434314          ORR      r3,r3,r4,LSR #16
;;;474    
;;;475        /* Reset the Output N State */
;;;476        tmpccer &= CCER_CC3NE_Reset;
00024c  f4236380          BIC      r3,r3,#0x400
;;;477        
;;;478        /* Set the Output N State */
;;;479        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 8);
000250  888c              LDRH     r4,[r1,#4]
000252  0624              LSLS     r4,r4,#24
000254  ea434314          ORR      r3,r3,r4,LSR #16
;;;480    
;;;481        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;482        tmpcr2 &= CR2_OIS3_Reset;
000258  f4224210          BIC      r2,r2,#0x9000
;;;483        tmpcr2 &= CR2_OIS3N_Reset;
00025c  f4224220          BIC      r2,r2,#0xa000
;;;484    
;;;485        /* Set the Output Idle state */
;;;486        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000260  898c              LDRH     r4,[r1,#0xc]
000262  0524              LSLS     r4,r4,#20
000264  ea424214          ORR      r2,r2,r4,LSR #16
;;;487    
;;;488        /* Set the Output N Idle state */
;;;489        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000268  89c9              LDRH     r1,[r1,#0xe]
00026a  0509              LSLS     r1,r1,#20
00026c  ea424211          ORR      r2,r2,r1,LSR #16
                  |L1.624|
;;;490      }
;;;491    
;;;492      /* Write to TIMx CR2 */
;;;493      TIMx->CR2 = tmpcr2;
000270  8082              STRH     r2,[r0,#4]
;;;494      
;;;495      /* Write to TIMx CCMR2 */
;;;496      TIMx->CCMR2 = tmpccmrx;
000272  f8a0c01c          STRH     r12,[r0,#0x1c]
;;;497      
;;;498      /* Write to TIMx CCER */
;;;499      TIMx->CCER = tmpccer;
000276  8403              STRH     r3,[r0,#0x20]
;;;500    }
000278  bc10              POP      {r4}
00027a  4770              BX       lr
;;;501    
                          ENDP

                  TIM_OC4Init PROC
;;;513    *******************************************************************************/
;;;514    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00027c  b410              PUSH     {r4}
;;;515    {
;;;516      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;517       
;;;518      /* Check the parameters */
;;;519      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;520      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;521      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;522      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;523    
;;;524      /* Disable the Channel 2: Reset the CC4E Bit */
;;;525      TIMx->CCER &= CCER_CC4E_Reset;
00027e  8c02              LDRH     r2,[r0,#0x20]
000280  f4225280          BIC      r2,r2,#0x1000
000284  8402              STRH     r2,[r0,#0x20]
;;;526      
;;;527      /* Get the TIMx CCER register value */
;;;528      tmpccer = TIMx->CCER;
000286  8c03              LDRH     r3,[r0,#0x20]
;;;529    
;;;530      /* Get the TIMx CR2 register value */
;;;531      tmpcr2 =  TIMx->CR2;
000288  8882              LDRH     r2,[r0,#4]
;;;532      
;;;533      /* Get the TIMx CCMR2 register value */
;;;534      tmpccmrx = TIMx->CCMR2;
00028a  f8b0c01c          LDRH     r12,[r0,#0x1c]
;;;535        
;;;536      /* Reset the Output Compare Mode Bits */
;;;537      tmpccmrx &= CCMR_OC24M_Mask;
00028e  f42c4ce0          BIC      r12,r12,#0x7000
;;;538      
;;;539      /* Select the Output Compare Mode */
;;;540      tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
000292  880c              LDRH     r4,[r1,#0]
000294  0624              LSLS     r4,r4,#24
000296  ea4c4c14          ORR      r12,r12,r4,LSR #16
;;;541      
;;;542      /* Reset the Output Polarity level */
;;;543      tmpccer &= CCER_CC4P_Reset;
00029a  f4235300          BIC      r3,r3,#0x2000
;;;544    
;;;545      /* Set the Output Compare Polarity */
;;;546      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 12);
00029e  890c              LDRH     r4,[r1,#8]
0002a0  0724              LSLS     r4,r4,#28
0002a2  ea434314          ORR      r3,r3,r4,LSR #16
;;;547      
;;;548      /* Set the Output State */
;;;549      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 12);
0002a6  884c              LDRH     r4,[r1,#2]
0002a8  0724              LSLS     r4,r4,#28
0002aa  ea434314          ORR      r3,r3,r4,LSR #16
;;;550      
;;;551      /* Set the Capture Compare Register value */
;;;552      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
0002ae  88cc              LDRH     r4,[r1,#6]
0002b0  f8a04040          STRH     r4,[r0,#0x40]
;;;553      
;;;554      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
0002b4  f1a04480          SUB      r4,r0,#0x40000000
0002b8  f5b43496          SUBS     r4,r4,#0x12c00
0002bc  d002              BEQ      |L1.708|
0002be  f5b46400          SUBS     r4,r4,#0x800
0002c2  d105              BNE      |L1.720|
                  |L1.708|
;;;555      {
;;;556        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;557    
;;;558        /* Reset the Ouput Compare IDLE State */
;;;559        tmpcr2 &= CR2_OIS4_Reset;
0002c4  f3c2020d          UBFX     r2,r2,#0,#14
;;;560    
;;;561        /* Set the Output Idle state */
;;;562        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 6);
0002c8  8989              LDRH     r1,[r1,#0xc]
0002ca  0589              LSLS     r1,r1,#22
0002cc  ea424211          ORR      r2,r2,r1,LSR #16
                  |L1.720|
;;;563      }
;;;564    
;;;565      /* Write to TIMx CR2 */
;;;566      TIMx->CR2 = tmpcr2;
0002d0  8082              STRH     r2,[r0,#4]
;;;567      
;;;568      /* Write to TIMx CCMR2 */  
;;;569      TIMx->CCMR2 = tmpccmrx;
0002d2  f8a0c01c          STRH     r12,[r0,#0x1c]
;;;570      
;;;571      /* Write to TIMx CCER */
;;;572      TIMx->CCER = tmpccer;
0002d6  8403              STRH     r3,[r0,#0x20]
;;;573    }
0002d8  bc10              POP      {r4}
0002da  4770              BX       lr
;;;574    
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2751   *******************************************************************************/
;;;2752   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
0002dc  8b82              LDRH     r2,[r0,#0x1c]
;;;2753   {  
;;;2754     /* Check the parameters */
;;;2755     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2756     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2757   
;;;2758     /* Reset the IC4PSC Bits */
;;;2759     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
0002de  f4226240          BIC      r2,r2,#0xc00
0002e2  8382              STRH     r2,[r0,#0x1c]
;;;2760   
;;;2761     /* Set the IC4PSC value */
;;;2762     TIMx->CCMR2 |= (u16)(TIM_ICPSC << 8);
0002e4  8b82              LDRH     r2,[r0,#0x1c]
0002e6  ea422101          ORR      r1,r2,r1,LSL #8
0002ea  8381              STRH     r1,[r0,#0x1c]
;;;2763   }
0002ec  4770              BX       lr
;;;2764   
                          ENDP

                  TI4_Config PROC
;;;3196   *******************************************************************************/
;;;3197   static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
0002ee  b410              PUSH     {r4}
;;;3198                          u16 TIM_ICFilter)
;;;3199   {
;;;3200     u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
;;;3201   
;;;3202     /* Disable the Channel 4: Reset the CC4E Bit */
;;;3203     TIMx->CCER &= CCER_CC4E_Reset;
0002f0  f8b0c020          LDRH     r12,[r0,#0x20]
0002f4  f42c5c80          BIC      r12,r12,#0x1000
0002f8  f8a0c020          STRH     r12,[r0,#0x20]
;;;3204   
;;;3205     tmpccmr2 = TIMx->CCMR2;
0002fc  8b84              LDRH     r4,[r0,#0x1c]
;;;3206     tmpccer = TIMx->CCER;
0002fe  f8b0c020          LDRH     r12,[r0,#0x20]
;;;3207     tmp = (u16)(TIM_ICPolarity << 12);
000302  0309              LSLS     r1,r1,#12
;;;3208   
;;;3209     /* Select the Input and set the filter */
;;;3210     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000304  f4244473          BIC      r4,r4,#0xf300
;;;3211     tmpccmr2 |= (u16)(TIM_ICSelection << 8) | (u16)(TIM_ICFilter << 12);
000308  0212              LSLS     r2,r2,#8
00030a  ea423203          ORR      r2,r2,r3,LSL #12
00030e  4322              ORRS     r2,r2,r4
;;;3212   
;;;3213     /* Select the Polarity and set the CC4E Bit */
;;;3214     tmpccer &= CCER_CC4P_Reset;
000310  f42c5300          BIC      r3,r12,#0x2000
;;;3215     tmpccer |= tmp | CCER_CC4E_Set;
000314  4319              ORRS     r1,r1,r3
000316  f4415180          ORR      r1,r1,#0x1000
;;;3216   
;;;3217     /* Write to TIMx CCMR2 and CCER registers */
;;;3218     TIMx->CCMR2 = tmpccmr2;
00031a  8382              STRH     r2,[r0,#0x1c]
;;;3219     TIMx->CCER = tmpccer ;
00031c  8401              STRH     r1,[r0,#0x20]
;;;3220   }
00031e  bc10              POP      {r4}
000320  4770              BX       lr
;;;3221   
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2723   *******************************************************************************/
;;;2724   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000322  8b82              LDRH     r2,[r0,#0x1c]
;;;2725   {
;;;2726     /* Check the parameters */
;;;2727     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2728     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2729   
;;;2730     /* Reset the IC3PSC Bits */
;;;2731     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
000324  f022020c          BIC      r2,r2,#0xc
000328  8382              STRH     r2,[r0,#0x1c]
;;;2732   
;;;2733     /* Set the IC3PSC value */
;;;2734     TIMx->CCMR2 |= TIM_ICPSC;
00032a  8b82              LDRH     r2,[r0,#0x1c]
00032c  4311              ORRS     r1,r1,r2
00032e  8381              STRH     r1,[r0,#0x1c]
;;;2735   }
000330  4770              BX       lr
;;;2736   
                          ENDP

                  TI3_Config PROC
;;;3149   *******************************************************************************/
;;;3150   static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000332  b410              PUSH     {r4}
;;;3151                          u16 TIM_ICFilter)
;;;3152   {
;;;3153     u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
;;;3154   
;;;3155     /* Disable the Channel 3: Reset the CC3E Bit */
;;;3156     TIMx->CCER &= CCER_CC3E_Reset;
000334  f8b0c020          LDRH     r12,[r0,#0x20]
000338  f42c7c80          BIC      r12,r12,#0x100
00033c  f8a0c020          STRH     r12,[r0,#0x20]
;;;3157   
;;;3158     tmpccmr2 = TIMx->CCMR2;
000340  8b84              LDRH     r4,[r0,#0x1c]
;;;3159     tmpccer = TIMx->CCER;
000342  f8b0c020          LDRH     r12,[r0,#0x20]
;;;3160     tmp = (u16)(TIM_ICPolarity << 8);
000346  0209              LSLS     r1,r1,#8
;;;3161   
;;;3162     /* Select the Input and set the filter */
;;;3163     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000348  f02404f3          BIC      r4,r4,#0xf3
;;;3164     tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
00034c  ea421203          ORR      r2,r2,r3,LSL #4
000350  4322              ORRS     r2,r2,r4
;;;3165   
;;;3166     /* Select the Polarity and set the CC3E Bit */
;;;3167     tmpccer &= CCER_CC3P_Reset;
000352  f42c7300          BIC      r3,r12,#0x200
;;;3168     tmpccer |= tmp | CCER_CC3E_Set;
000356  4319              ORRS     r1,r1,r3
000358  f4417180          ORR      r1,r1,#0x100
;;;3169   
;;;3170     /* Write to TIMx CCMR2 and CCER registers */
;;;3171     TIMx->CCMR2 = tmpccmr2;
00035c  8382              STRH     r2,[r0,#0x1c]
;;;3172     TIMx->CCER = tmpccer;
00035e  8401              STRH     r1,[r0,#0x20]
;;;3173   }
000360  bc10              POP      {r4}
000362  4770              BX       lr
;;;3174   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2695   *******************************************************************************/
;;;2696   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000364  8b02              LDRH     r2,[r0,#0x18]
;;;2697   {
;;;2698     /* Check the parameters */
;;;2699     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2700     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2701   
;;;2702     /* Reset the IC2PSC Bits */
;;;2703     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
000366  f4226240          BIC      r2,r2,#0xc00
00036a  8302              STRH     r2,[r0,#0x18]
;;;2704   
;;;2705     /* Set the IC2PSC value */
;;;2706     TIMx->CCMR1 |= (u16)(TIM_ICPSC << 8);
00036c  8b02              LDRH     r2,[r0,#0x18]
00036e  ea422101          ORR      r1,r2,r1,LSL #8
000372  8301              STRH     r1,[r0,#0x18]
;;;2707   }
000374  4770              BX       lr
;;;2708   
                          ENDP

                  TI2_Config PROC
;;;3101   *******************************************************************************/
;;;3102   static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000376  b410              PUSH     {r4}
;;;3103                          u16 TIM_ICFilter)
;;;3104   {
;;;3105     u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;3106   
;;;3107     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3108     TIMx->CCER &= CCER_CC2E_Reset;
000378  f8b0c020          LDRH     r12,[r0,#0x20]
00037c  f02c0c10          BIC      r12,r12,#0x10
000380  f8a0c020          STRH     r12,[r0,#0x20]
;;;3109   
;;;3110     tmpccmr1 = TIMx->CCMR1;
000384  8b04              LDRH     r4,[r0,#0x18]
;;;3111     tmpccer = TIMx->CCER;
000386  f8b0c020          LDRH     r12,[r0,#0x20]
;;;3112     tmp = (u16)(TIM_ICPolarity << 4);
00038a  0109              LSLS     r1,r1,#4
;;;3113   
;;;3114     /* Select the Input and set the filter */
;;;3115     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
00038c  f4244473          BIC      r4,r4,#0xf300
;;;3116     tmpccmr1 |= (u16)(TIM_ICFilter << 12);
000390  ea443303          ORR      r3,r4,r3,LSL #12
;;;3117     tmpccmr1 |= (u16)(TIM_ICSelection << 8);
000394  ea432202          ORR      r2,r3,r2,LSL #8
;;;3118   
;;;3119     /* Select the Polarity and set the CC2E Bit */
;;;3120     tmpccer &= CCER_CC2P_Reset;
000398  f02c0320          BIC      r3,r12,#0x20
;;;3121     tmpccer |=  tmp | CCER_CC2E_Set;
00039c  4319              ORRS     r1,r1,r3
00039e  f0410110          ORR      r1,r1,#0x10
;;;3122   
;;;3123     /* Write to TIMx CCMR1 and CCER registers */
;;;3124     TIMx->CCMR1 = tmpccmr1 ;
0003a2  8302              STRH     r2,[r0,#0x18]
;;;3125     TIMx->CCER = tmpccer;
0003a4  8401              STRH     r1,[r0,#0x20]
;;;3126   }
0003a6  bc10              POP      {r4}
0003a8  4770              BX       lr
;;;3127   
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2667   *******************************************************************************/
;;;2668   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
0003aa  8b02              LDRH     r2,[r0,#0x18]
;;;2669   {
;;;2670     /* Check the parameters */
;;;2671     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2672     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2673   
;;;2674     /* Reset the IC1PSC Bits */
;;;2675     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
0003ac  f022020c          BIC      r2,r2,#0xc
0003b0  8302              STRH     r2,[r0,#0x18]
;;;2676   
;;;2677     /* Set the IC1PSC value */
;;;2678     TIMx->CCMR1 |= TIM_ICPSC;
0003b2  8b02              LDRH     r2,[r0,#0x18]
0003b4  4311              ORRS     r1,r1,r2
0003b6  8301              STRH     r1,[r0,#0x18]
;;;2679   }
0003b8  4770              BX       lr
;;;2680   
                          ENDP

                  TI1_Config PROC
;;;3055   *******************************************************************************/
;;;3056   static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
0003ba  b410              PUSH     {r4}
;;;3057                          u16 TIM_ICFilter)
;;;3058   {
;;;3059     u16 tmpccmr1 = 0, tmpccer = 0;
;;;3060   
;;;3061     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3062     TIMx->CCER &= CCER_CC1E_Reset;
0003bc  f8b0c020          LDRH     r12,[r0,#0x20]
0003c0  f02c0c01          BIC      r12,r12,#1
0003c4  f8a0c020          STRH     r12,[r0,#0x20]
;;;3063   
;;;3064     tmpccmr1 = TIMx->CCMR1;
0003c8  8b04              LDRH     r4,[r0,#0x18]
;;;3065     tmpccer = TIMx->CCER;
0003ca  f8b0c020          LDRH     r12,[r0,#0x20]
;;;3066   
;;;3067     /* Select the Input and set the filter */
;;;3068     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
0003ce  f02404f3          BIC      r4,r4,#0xf3
;;;3069     tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
0003d2  ea421203          ORR      r2,r2,r3,LSL #4
0003d6  4322              ORRS     r2,r2,r4
;;;3070   
;;;3071     /* Select the Polarity and set the CC1E Bit */
;;;3072     tmpccer &= CCER_CC1P_Reset;
0003d8  f02c0302          BIC      r3,r12,#2
;;;3073     tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
0003dc  4319              ORRS     r1,r1,r3
0003de  f0410101          ORR      r1,r1,#1
;;;3074   
;;;3075     /* Write to TIMx CCMR1 and CCER registers */
;;;3076     TIMx->CCMR1 = tmpccmr1;
0003e2  8302              STRH     r2,[r0,#0x18]
;;;3077     TIMx->CCER = tmpccer;
0003e4  8401              STRH     r1,[r0,#0x20]
;;;3078   }
0003e6  bc10              POP      {r4}
0003e8  4770              BX       lr
0003ea  0000              DCW      0x0000
                  |L1.1004|
                          DCD      0x40001000
                          ENDP

                  TIM_ICInit PROC
;;;586    *******************************************************************************/
;;;587    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
0003f0  b570              PUSH     {r4-r6,lr}
;;;588    {
0003f2  4605              MOV      r5,r0
0003f4  460c              MOV      r4,r1
;;;589      /* Check the parameters */
;;;590      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;591      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;592      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;593      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;594      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;595      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;596      
;;;597      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
0003f6  8821              LDRH     r1,[r4,#0]
;;;598      {
;;;599        /* TI1 Configuration */
;;;600        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
0003f8  f8b4c002          LDRH     r12,[r4,#2]
0003fc  88a2              LDRH     r2,[r4,#4]
0003fe  8923              LDRH     r3,[r4,#8]
000400  b161              CBZ      r1,|L1.1052|
;;;601                   TIM_ICInitStruct->TIM_ICSelection,
;;;602                   TIM_ICInitStruct->TIM_ICFilter);
;;;603    
;;;604        /* Set the Input Capture Prescaler value */
;;;605        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;606      }
;;;607      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000402  2904              CMP      r1,#4
000404  d013              BEQ      |L1.1070|
;;;608      {
;;;609        /* TI2 Configuration */
;;;610        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;611                   TIM_ICInitStruct->TIM_ICSelection,
;;;612                   TIM_ICInitStruct->TIM_ICFilter);
;;;613    
;;;614        /* Set the Input Capture Prescaler value */
;;;615        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;616      }
;;;617      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000406  2908              CMP      r1,#8
000408  d01a              BEQ      |L1.1088|
;;;618      {
;;;619        /* TI3 Configuration */
;;;620        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;621                   TIM_ICInitStruct->TIM_ICSelection,
;;;622                   TIM_ICInitStruct->TIM_ICFilter);
;;;623    
;;;624        /* Set the Input Capture Prescaler value */
;;;625        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;626      }
;;;627      else
;;;628      {
;;;629        /* TI4 Configuration */
;;;630        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00040a  4661              MOV      r1,r12
00040c  4628              MOV      r0,r5
00040e  f7fffffe          BL       TI4_Config
;;;631                   TIM_ICInitStruct->TIM_ICSelection,
;;;632                   TIM_ICInitStruct->TIM_ICFilter);
;;;633    
;;;634        /* Set the Input Capture Prescaler value */
;;;635        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000412  88e1              LDRH     r1,[r4,#6]
000414  4628              MOV      r0,r5
000416  e8bd4070          POP      {r4-r6,lr}
00041a  e7fe              B        TIM_SetIC4Prescaler
                  |L1.1052|
00041c  4661              MOV      r1,r12                ;600
00041e  4628              MOV      r0,r5                 ;600
000420  f7fffffe          BL       TI1_Config
000424  88e1              LDRH     r1,[r4,#6]            ;605
000426  4628              MOV      r0,r5                 ;605
000428  e8bd4070          POP      {r4-r6,lr}            ;605
00042c  e7fe              B        TIM_SetIC1Prescaler
                  |L1.1070|
00042e  4661              MOV      r1,r12                ;610
000430  4628              MOV      r0,r5                 ;610
000432  f7fffffe          BL       TI2_Config
000436  88e1              LDRH     r1,[r4,#6]            ;615
000438  4628              MOV      r0,r5                 ;615
00043a  e8bd4070          POP      {r4-r6,lr}            ;615
00043e  e7fe              B        TIM_SetIC2Prescaler
                  |L1.1088|
000440  4661              MOV      r1,r12                ;620
000442  4628              MOV      r0,r5                 ;620
000444  f7fffffe          BL       TI3_Config
000448  88e1              LDRH     r1,[r4,#6]            ;625
00044a  4628              MOV      r0,r5                 ;625
00044c  e8bd4070          POP      {r4-r6,lr}            ;625
000450  e7fe              B        TIM_SetIC3Prescaler
;;;636      }
;;;637    }
;;;638    
                          ENDP

                  TIM_PWMIConfig PROC
;;;651    *******************************************************************************/
;;;652    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000452  e92d41f0          PUSH     {r4-r8,lr}
;;;653    {
000456  4607              MOV      r7,r0
000458  460c              MOV      r4,r1
;;;654      u16 icoppositepolarity = TIM_ICPolarity_Rising;
00045a  2500              MOVS     r5,#0
;;;655      u16 icoppositeselection = TIM_ICSelection_DirectTI;
00045c  2601              MOVS     r6,#1
;;;656    
;;;657      /* Check the parameters */
;;;658      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;659    
;;;660      /* Select the Opposite Input Polarity */
;;;661      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00045e  8861              LDRH     r1,[r4,#2]
000460  b901              CBNZ     r1,|L1.1124|
;;;662      {
;;;663        icoppositepolarity = TIM_ICPolarity_Falling;
000462  2502              MOVS     r5,#2
                  |L1.1124|
;;;664      }
;;;665      else
;;;666      {
;;;667        icoppositepolarity = TIM_ICPolarity_Rising;
;;;668      }
;;;669    
;;;670      /* Select the Opposite Input */
;;;671      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000464  88a2              LDRH     r2,[r4,#4]
000466  2a01              CMP      r2,#1
000468  d100              BNE      |L1.1132|
;;;672      {
;;;673        icoppositeselection = TIM_ICSelection_IndirectTI;
00046a  2602              MOVS     r6,#2
                  |L1.1132|
;;;674      }
;;;675      else
;;;676      {
;;;677        icoppositeselection = TIM_ICSelection_DirectTI;
;;;678      }
;;;679    
;;;680      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00046c  8820              LDRH     r0,[r4,#0]
;;;681      {
;;;682        /* TI1 Configuration */
;;;683        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00046e  8923              LDRH     r3,[r4,#8]
000470  b188              CBZ      r0,|L1.1174|
;;;684                   TIM_ICInitStruct->TIM_ICFilter);
;;;685    
;;;686        /* Set the Input Capture Prescaler value */
;;;687        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;688    
;;;689        /* TI2 Configuration */
;;;690        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;691    
;;;692        /* Set the Input Capture Prescaler value */
;;;693        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;694      }
;;;695      else
;;;696      { 
;;;697        /* TI2 Configuration */
;;;698        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000472  4638              MOV      r0,r7
000474  f7fffffe          BL       TI2_Config
;;;699                   TIM_ICInitStruct->TIM_ICFilter);
;;;700    
;;;701        /* Set the Input Capture Prescaler value */
;;;702        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000478  88e1              LDRH     r1,[r4,#6]
00047a  4638              MOV      r0,r7
00047c  f7fffffe          BL       TIM_SetIC2Prescaler
;;;703    
;;;704        /* TI1 Configuration */
;;;705        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000480  8923              LDRH     r3,[r4,#8]
000482  4632              MOV      r2,r6
000484  4629              MOV      r1,r5
000486  4638              MOV      r0,r7
000488  f7fffffe          BL       TI1_Config
;;;706    
;;;707        /* Set the Input Capture Prescaler value */
;;;708        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00048c  88e1              LDRH     r1,[r4,#6]
00048e  4638              MOV      r0,r7
000490  e8bd41f0          POP      {r4-r8,lr}
000494  e7fe              B        TIM_SetIC1Prescaler
                  |L1.1174|
000496  4638              MOV      r0,r7                 ;683
000498  f7fffffe          BL       TI1_Config
00049c  88e1              LDRH     r1,[r4,#6]            ;687
00049e  4638              MOV      r0,r7                 ;687
0004a0  f7fffffe          BL       TIM_SetIC1Prescaler
0004a4  8923              LDRH     r3,[r4,#8]            ;690
0004a6  4632              MOV      r2,r6                 ;690
0004a8  4629              MOV      r1,r5                 ;690
0004aa  4638              MOV      r0,r7                 ;690
0004ac  f7fffffe          BL       TI2_Config
0004b0  88e1              LDRH     r1,[r4,#6]            ;693
0004b2  4638              MOV      r0,r7                 ;693
0004b4  e8bd41f0          POP      {r4-r8,lr}            ;693
0004b8  e7fe              B        TIM_SetIC2Prescaler
;;;709      }
;;;710    }
;;;711    
                          ENDP

                  TIM_BDTRConfig PROC
;;;722    *******************************************************************************/
;;;723    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
0004ba  880a              LDRH     r2,[r1,#0]
;;;724    {
;;;725      /* Check the parameters */
;;;726      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;727      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;728      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;729      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;730      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;731      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;732      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;733    
;;;734      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;735         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;736    
;;;737      TIMx->BDTR = (u32)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
0004bc  884b              LDRH     r3,[r1,#2]
0004be  f8b1c006          LDRH     r12,[r1,#6]
0004c2  431a              ORRS     r2,r2,r3
0004c4  888b              LDRH     r3,[r1,#4]
0004c6  ea43030c          ORR      r3,r3,r12
0004ca  431a              ORRS     r2,r2,r3
0004cc  890b              LDRH     r3,[r1,#8]
0004ce  431a              ORRS     r2,r2,r3
0004d0  894b              LDRH     r3,[r1,#0xa]
0004d2  8989              LDRH     r1,[r1,#0xc]
0004d4  431a              ORRS     r2,r2,r3
0004d6  4311              ORRS     r1,r1,r2
0004d8  f8a01044          STRH     r1,[r0,#0x44]
;;;738                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;739                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;740                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;741    
;;;742    }
0004dc  4770              BX       lr
;;;743    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;751    *******************************************************************************/
;;;752    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0004de  f64f71ff          MOV      r1,#0xffff
;;;753    {
;;;754      /* Set the default configuration */
;;;755      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
0004e2  8081              STRH     r1,[r0,#4]
;;;756      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
0004e4  2100              MOVS     r1,#0
0004e6  8001              STRH     r1,[r0,#0]
;;;757      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
0004e8  80c1              STRH     r1,[r0,#6]
;;;758      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
0004ea  8041              STRH     r1,[r0,#2]
;;;759      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
0004ec  7201              STRB     r1,[r0,#8]
;;;760    }
0004ee  4770              BX       lr
;;;761    
                          ENDP

                  TIM_OCStructInit PROC
;;;769    *******************************************************************************/
;;;770    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
0004f0  2100              MOVS     r1,#0
;;;771    {
;;;772      /* Set the default configuration */
;;;773      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
0004f2  8001              STRH     r1,[r0,#0]
;;;774      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
0004f4  8041              STRH     r1,[r0,#2]
;;;775      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
0004f6  8081              STRH     r1,[r0,#4]
;;;776      TIM_OCInitStruct->TIM_Pulse = 0x0000;
0004f8  80c1              STRH     r1,[r0,#6]
;;;777      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
0004fa  8101              STRH     r1,[r0,#8]
;;;778      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
0004fc  8141              STRH     r1,[r0,#0xa]
;;;779      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
0004fe  8181              STRH     r1,[r0,#0xc]
;;;780      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000500  81c1              STRH     r1,[r0,#0xe]
;;;781    }
000502  4770              BX       lr
;;;782    
                          ENDP

                  TIM_ICStructInit PROC
;;;790    *******************************************************************************/
;;;791    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000504  2100              MOVS     r1,#0
;;;792    {
;;;793      /* Set the default configuration */
;;;794      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000506  8001              STRH     r1,[r0,#0]
;;;795      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000508  8041              STRH     r1,[r0,#2]
;;;796      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
00050a  2201              MOVS     r2,#1
00050c  8082              STRH     r2,[r0,#4]
;;;797      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00050e  80c1              STRH     r1,[r0,#6]
;;;798      TIM_ICInitStruct->TIM_ICFilter = 0x00;
000510  8101              STRH     r1,[r0,#8]
;;;799    }
000512  4770              BX       lr
;;;800    
                          ENDP

                  TIM_BDTRStructInit PROC
;;;808    *******************************************************************************/
;;;809    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000514  2100              MOVS     r1,#0
;;;810    {
;;;811      /* Set the default configuration */
;;;812      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000516  8001              STRH     r1,[r0,#0]
;;;813      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000518  8041              STRH     r1,[r0,#2]
;;;814      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
00051a  8081              STRH     r1,[r0,#4]
;;;815      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
00051c  80c1              STRH     r1,[r0,#6]
;;;816      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00051e  8101              STRH     r1,[r0,#8]
;;;817      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
000520  8141              STRH     r1,[r0,#0xa]
;;;818      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
000522  8181              STRH     r1,[r0,#0xc]
;;;819    }
000524  4770              BX       lr
;;;820    
                          ENDP

                  TIM_Cmd PROC
;;;829    *******************************************************************************/
;;;830    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000526  b121              CBZ      r1,|L1.1330|
;;;831    {
;;;832      /* Check the parameters */
;;;833      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;834      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;835      
;;;836      if (NewState != DISABLE)
;;;837      {
;;;838        /* Enable the TIM Counter */
;;;839        TIMx->CR1 |= CR1_CEN_Set;
000528  8801              LDRH     r1,[r0,#0]
00052a  f0410101          ORR      r1,r1,#1
00052e  8001              STRH     r1,[r0,#0]
;;;840      }
;;;841      else
;;;842      {
;;;843        /* Disable the TIM Counter */
;;;844        TIMx->CR1 &= CR1_CEN_Reset;
;;;845      }
;;;846    }
000530  4770              BX       lr
                  |L1.1330|
000532  8801              LDRH     r1,[r0,#0]            ;844
000534  f0210101          BIC      r1,r1,#1              ;844
000538  f421417c          BIC      r1,r1,#0xfc00         ;844
00053c  8001              STRH     r1,[r0,#0]            ;844
00053e  4770              BX       lr
;;;847    
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;856    *******************************************************************************/
;;;857    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000540  b131              CBZ      r1,|L1.1360|
;;;858    {
;;;859      /* Check the parameters */
;;;860      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;861      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;862    
;;;863      if (NewState != DISABLE)
;;;864      {
;;;865        /* Enable the TIM Main Output */
;;;866        TIMx->BDTR |= BDTR_MOE_Set;
000542  f8b01044          LDRH     r1,[r0,#0x44]
000546  f4414100          ORR      r1,r1,#0x8000
00054a  f8a01044          STRH     r1,[r0,#0x44]
;;;867      }
;;;868      else
;;;869      {
;;;870        /* Disable the TIM Main Output */
;;;871        TIMx->BDTR &= BDTR_MOE_Reset;
;;;872      }  
;;;873    }
00054e  4770              BX       lr
                  |L1.1360|
000550  f8b01044          LDRH     r1,[r0,#0x44]         ;871
000554  f3c1010e          UBFX     r1,r1,#0,#15          ;871
000558  f8a01044          STRH     r1,[r0,#0x44]         ;871
00055c  4770              BX       lr
;;;874    
                          ENDP

                  TIM_ITConfig PROC
;;;894    *******************************************************************************/
;;;895    void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
00055e  b11a              CBZ      r2,|L1.1384|
;;;896    {  
;;;897      /* Check the parameters */
;;;898      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;899      assert_param(IS_TIM_IT(TIM_IT));
;;;900      assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
;;;901      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;902      
;;;903      if (NewState != DISABLE)
;;;904      {
;;;905        /* Enable the Interrupt sources */
;;;906        TIMx->DIER |= TIM_IT;
000560  8982              LDRH     r2,[r0,#0xc]
000562  4311              ORRS     r1,r1,r2
000564  8181              STRH     r1,[r0,#0xc]
;;;907      }
;;;908      else
;;;909      {
;;;910        /* Disable the Interrupt sources */
;;;911        TIMx->DIER &= (u16)~TIM_IT;
;;;912      }
;;;913    }
000566  4770              BX       lr
                  |L1.1384|
000568  8982              LDRH     r2,[r0,#0xc]          ;911
00056a  ea220101          BIC      r1,r2,r1              ;911
00056e  8181              STRH     r1,[r0,#0xc]          ;911
000570  4770              BX       lr
;;;914    
                          ENDP

                  TIM_GenerateEvent PROC
;;;929    *******************************************************************************/
;;;930    void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
000572  8281              STRH     r1,[r0,#0x14]
;;;931    { 
;;;932      /* Check the parameters */
;;;933      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;934      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;935      assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
;;;936    
;;;937      /* Set the event sources */
;;;938      TIMx->EGR = TIM_EventSource;
;;;939    }
000574  4770              BX       lr
;;;940    
                          ENDP

                  TIM_DMAConfig PROC
;;;960    *******************************************************************************/
;;;961    void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
000576  4311              ORRS     r1,r1,r2
;;;962    {
;;;963      /* Check the parameters */
;;;964      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;965      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;966      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;967    
;;;968      /* Set the DMA Base and the DMA Burst Length */
;;;969      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000578  f8a01048          STRH     r1,[r0,#0x48]
;;;970    }
00057c  4770              BX       lr
;;;971    
                          ENDP

                  TIM_DMACmd PROC
;;;989    *******************************************************************************/
;;;990    void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
00057e  b11a              CBZ      r2,|L1.1416|
;;;991    { 
;;;992      /* Check the parameters */
;;;993      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;994      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;995      assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
;;;996      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;997      
;;;998      if (NewState != DISABLE)
;;;999      {
;;;1000       /* Enable the DMA sources */
;;;1001       TIMx->DIER |= TIM_DMASource; 
000580  8982              LDRH     r2,[r0,#0xc]
000582  4311              ORRS     r1,r1,r2
000584  8181              STRH     r1,[r0,#0xc]
;;;1002     }
;;;1003     else
;;;1004     {
;;;1005       /* Disable the DMA sources */
;;;1006       TIMx->DIER &= (u16)~TIM_DMASource;
;;;1007     }
;;;1008   }
000586  4770              BX       lr
                  |L1.1416|
000588  8982              LDRH     r2,[r0,#0xc]          ;1006
00058a  ea220101          BIC      r1,r2,r1              ;1006
00058e  8181              STRH     r1,[r0,#0xc]          ;1006
000590  4770              BX       lr
;;;1009   
                          ENDP

                  TIM_InternalClockConfig PROC
;;;1017   *******************************************************************************/
;;;1018   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000592  8901              LDRH     r1,[r0,#8]
;;;1019   {
;;;1020     /* Check the parameters */
;;;1021     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1022   
;;;1023     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;1024     TIMx->SMCR &=  SMCR_SMS_Mask;
000594  f0210107          BIC      r1,r1,#7
000598  8101              STRH     r1,[r0,#8]
;;;1025   }
00059a  4770              BX       lr
;;;1026   /*******************************************************************************
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;1305   *******************************************************************************/
;;;1306   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
00059c  8902              LDRH     r2,[r0,#8]
;;;1307   {
;;;1308     u16 tmpsmcr = 0;
;;;1309   
;;;1310     /* Check the parameters */
;;;1311     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1312     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1313   
;;;1314     /* Get the TIMx SMCR register value */
;;;1315     tmpsmcr = TIMx->SMCR;
;;;1316   
;;;1317     /* Reset the TS Bits */
;;;1318     tmpsmcr &= SMCR_TS_Mask;
00059e  f0220270          BIC      r2,r2,#0x70
;;;1319   
;;;1320     /* Set the Input Trigger source */
;;;1321     tmpsmcr |= TIM_InputTriggerSource;
0005a2  4311              ORRS     r1,r1,r2
;;;1322   
;;;1323     /* Write to TIMx SMCR */
;;;1324     TIMx->SMCR = tmpsmcr;
0005a4  8101              STRH     r1,[r0,#8]
;;;1325   }
0005a6  4770              BX       lr
;;;1326   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;1039   *******************************************************************************/
;;;1040   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
0005a8  b500              PUSH     {lr}
;;;1041   {
0005aa  4603              MOV      r3,r0
;;;1042     /* Check the parameters */
;;;1043     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1044     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1045   
;;;1046     /* Select the Internal Trigger */
;;;1047     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
0005ac  4618              MOV      r0,r3
0005ae  f7fffffe          BL       TIM_SelectInputTrigger
;;;1048   
;;;1049     /* Select the External clock mode1 */
;;;1050     TIMx->SMCR |= TIM_SlaveMode_External1;
0005b2  8918              LDRH     r0,[r3,#8]
0005b4  f0400007          ORR      r0,r0,#7
0005b8  8118              STRH     r0,[r3,#8]
;;;1051   }
0005ba  bd00              POP      {pc}
;;;1052   /*******************************************************************************
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;1070   *******************************************************************************/
;;;1071   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
0005bc  b570              PUSH     {r4-r6,lr}
;;;1072                                   u16 TIM_ICPolarity, u16 ICFilter)
;;;1073   {
0005be  460d              MOV      r5,r1
0005c0  4604              MOV      r4,r0
0005c2  4611              MOV      r1,r2
;;;1074     /* Check the parameters */
;;;1075     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1076     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1077     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1078     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1079   
;;;1080     /* Configure the Timer Input Clock Source */
;;;1081     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
0005c4  2d60              CMP      r5,#0x60
0005c6  d00c              BEQ      |L1.1506|
;;;1082     {
;;;1083       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;1084     }
;;;1085     else
;;;1086     {
;;;1087       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
0005c8  2201              MOVS     r2,#1
0005ca  4620              MOV      r0,r4
0005cc  f7fffffe          BL       TI1_Config
                  |L1.1488|
;;;1088     }
;;;1089   
;;;1090     /* Select the Trigger source */
;;;1091     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
0005d0  4629              MOV      r1,r5
0005d2  4620              MOV      r0,r4
0005d4  f7fffffe          BL       TIM_SelectInputTrigger
;;;1092   
;;;1093     /* Select the External clock mode1 */
;;;1094     TIMx->SMCR |= TIM_SlaveMode_External1;
0005d8  8920              LDRH     r0,[r4,#8]
0005da  f0400007          ORR      r0,r0,#7
0005de  8120              STRH     r0,[r4,#8]
;;;1095   }
0005e0  bd70              POP      {r4-r6,pc}
                  |L1.1506|
0005e2  2201              MOVS     r2,#1                 ;1083
0005e4  4620              MOV      r0,r4                 ;1083
0005e6  f7fffffe          BL       TI2_Config
0005ea  e7f1              B        |L1.1488|
;;;1096   
                          ENDP

                  TIM_ETRConfig PROC
;;;1202   *******************************************************************************/
;;;1203   void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
0005ec  f8b0c008          LDRH     r12,[r0,#8]
;;;1204                      u16 ExtTRGFilter)
;;;1205   {
;;;1206     u16 tmpsmcr = 0;
;;;1207   
;;;1208     /* Check the parameters */
;;;1209     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1210     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1211     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1212     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1213   
;;;1214     tmpsmcr = TIMx->SMCR;
;;;1215   
;;;1216     /* Reset the ETR Bits */
;;;1217     tmpsmcr &= SMCR_ETR_Mask;
0005f0  f00c0cff          AND      r12,r12,#0xff
;;;1218   
;;;1219     /* Set the Prescaler, the Filter value and the Polarity */
;;;1220     tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter << 8);
0005f4  430a              ORRS     r2,r2,r1
0005f6  ea422103          ORR      r1,r2,r3,LSL #8
0005fa  ea41010c          ORR      r1,r1,r12
;;;1221   
;;;1222     /* Write to TIMx SMCR */
;;;1223     TIMx->SMCR = tmpsmcr;
0005fe  8101              STRH     r1,[r0,#8]
;;;1224   }
000600  4770              BX       lr
;;;1225   
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;1116   *******************************************************************************/
;;;1117   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
000602  b510              PUSH     {r4,lr}
;;;1118                                u16 ExtTRGFilter)
;;;1119   {
000604  4604              MOV      r4,r0
;;;1120     u16 tmpsmcr = 0;
;;;1121   
;;;1122     /* Check the parameters */
;;;1123     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1124     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1125     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1126     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1127   
;;;1128     /* Configure the ETR Clock source */
;;;1129     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000606  4620              MOV      r0,r4
000608  f7fffffe          BL       TIM_ETRConfig
;;;1130     
;;;1131     /* Get the TIMx SMCR register value */
;;;1132     tmpsmcr = TIMx->SMCR;
00060c  8920              LDRH     r0,[r4,#8]
;;;1133   
;;;1134     /* Reset the SMS Bits */
;;;1135     tmpsmcr &= SMCR_SMS_Mask;
00060e  f0200007          BIC      r0,r0,#7
;;;1136     /* Select the External clock mode1 */
;;;1137     tmpsmcr |= TIM_SlaveMode_External1;
000612  f0400007          ORR      r0,r0,#7
;;;1138   
;;;1139     /* Select the Trigger selection : ETRF */
;;;1140     tmpsmcr &= SMCR_TS_Mask;
000616  f0200070          BIC      r0,r0,#0x70
;;;1141     tmpsmcr |= TIM_TS_ETRF;
00061a  f0400070          ORR      r0,r0,#0x70
;;;1142   
;;;1143     /* Write to TIMx SMCR */
;;;1144     TIMx->SMCR = tmpsmcr;
00061e  8120              STRH     r0,[r4,#8]
;;;1145   }
000620  bd10              POP      {r4,pc}
;;;1146   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;1166   *******************************************************************************/
;;;1167   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
000622  b510              PUSH     {r4,lr}
;;;1168                                u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
;;;1169   {
000624  4604              MOV      r4,r0
;;;1170     /* Check the parameters */
;;;1171     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1172     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1173     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1174     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1175   
;;;1176     /* Configure the ETR Clock source */
;;;1177     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000626  4620              MOV      r0,r4
000628  f7fffffe          BL       TIM_ETRConfig
;;;1178   
;;;1179     /* Enable the External clock mode2 */
;;;1180     TIMx->SMCR |= SMCR_ECE_Set;
00062c  8920              LDRH     r0,[r4,#8]
00062e  f4404080          ORR      r0,r0,#0x4000
000632  8120              STRH     r0,[r4,#8]
;;;1181   }
000634  bd10              POP      {r4,pc}
;;;1182   
                          ENDP

                  TIM_PrescalerConfig PROC
;;;1239   *******************************************************************************/
;;;1240   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
000636  8501              STRH     r1,[r0,#0x28]
;;;1241   {
;;;1242     /* Check the parameters */
;;;1243     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1244     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1245   
;;;1246     /* Set the Prescaler value */
;;;1247     TIMx->PSC = Prescaler;
;;;1248   
;;;1249     /* Set or reset the UG Bit */
;;;1250     TIMx->EGR = TIM_PSCReloadMode;
000638  8282              STRH     r2,[r0,#0x14]
;;;1251   }
00063a  4770              BX       lr
;;;1252   
                          ENDP

                  TIM_CounterModeConfig PROC
;;;1267   *******************************************************************************/
;;;1268   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
00063c  8802              LDRH     r2,[r0,#0]
;;;1269   {
;;;1270     u16 tmpcr1 = 0;
;;;1271   
;;;1272     /* Check the parameters */
;;;1273     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1274     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1275   
;;;1276     tmpcr1 = TIMx->CR1;
;;;1277   
;;;1278     /* Reset the CMS and DIR Bits */
;;;1279     tmpcr1 &= CR1_CounterMode_Mask;
00063e  f4226247          BIC      r2,r2,#0xc70
000642  f4224270          BIC      r2,r2,#0xf000
;;;1280   
;;;1281     /* Set the Counter Mode */
;;;1282     tmpcr1 |= TIM_CounterMode;
000646  4311              ORRS     r1,r1,r2
;;;1283   
;;;1284     /* Write to TIMx CR1 register */
;;;1285     TIMx->CR1 = tmpcr1;
000648  8001              STRH     r1,[r0,#0]
;;;1286   }
00064a  4770              BX       lr
;;;1287   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;1350   *******************************************************************************/
;;;1351   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
00064c  b430              PUSH     {r4,r5}
;;;1352                                   u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
;;;1353   {
;;;1354     u16 tmpsmcr = 0;
;;;1355     u16 tmpccmr1 = 0;
;;;1356     u16 tmpccer = 0;
;;;1357       
;;;1358     /* Check the parameters */
;;;1359     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1360     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1361     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1362     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1363   
;;;1364     /* Get the TIMx SMCR register value */
;;;1365     tmpsmcr = TIMx->SMCR;
00064e  8905              LDRH     r5,[r0,#8]
;;;1366   
;;;1367     /* Get the TIMx CCMR1 register value */
;;;1368     tmpccmr1 = TIMx->CCMR1;
000650  8b04              LDRH     r4,[r0,#0x18]
;;;1369   
;;;1370     /* Get the TIMx CCER register value */
;;;1371     tmpccer = TIMx->CCER;
000652  f8b0c020          LDRH     r12,[r0,#0x20]
;;;1372   
;;;1373     /* Set the encoder Mode */
;;;1374     tmpsmcr &= SMCR_SMS_Mask;
000656  f0250507          BIC      r5,r5,#7
;;;1375     tmpsmcr |= TIM_EncoderMode;
00065a  4329              ORRS     r1,r1,r5
;;;1376   
;;;1377     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1378     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
00065c  f0240403          BIC      r4,r4,#3
000660  f4247440          BIC      r4,r4,#0x300
;;;1379     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
000664  f2401501          MOV      r5,#0x101
000668  432c              ORRS     r4,r4,r5
;;;1380   
;;;1381     /* Set the TI1 and the TI2 Polarities */
;;;1382     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
00066a  f02c0c22          BIC      r12,r12,#0x22
;;;1383     tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity << 4));
00066e  ea421203          ORR      r2,r2,r3,LSL #4
000672  ea42020c          ORR      r2,r2,r12
;;;1384   
;;;1385     /* Write to TIMx SMCR */
;;;1386     TIMx->SMCR = tmpsmcr;
000676  8101              STRH     r1,[r0,#8]
;;;1387   
;;;1388     /* Write to TIMx CCMR1 */
;;;1389     TIMx->CCMR1 = tmpccmr1;
000678  8304              STRH     r4,[r0,#0x18]
;;;1390   
;;;1391     /* Write to TIMx CCER */
;;;1392     TIMx->CCER = tmpccer;
00067a  8402              STRH     r2,[r0,#0x20]
;;;1393   }
00067c  bc30              POP      {r4,r5}
00067e  4770              BX       lr
;;;1394   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1408   *******************************************************************************/
;;;1409   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000680  8b02              LDRH     r2,[r0,#0x18]
;;;1410   {
;;;1411     u16 tmpccmr1 = 0;
;;;1412   
;;;1413     /* Check the parameters */
;;;1414     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1415     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1416   
;;;1417     tmpccmr1 = TIMx->CCMR1;
;;;1418   
;;;1419     /* Reset the OC1M Bits */
;;;1420     tmpccmr1 &= CCMR_OC13M_Mask;
000682  f0220270          BIC      r2,r2,#0x70
;;;1421   
;;;1422     /* Configure The Forced output Mode */
;;;1423     tmpccmr1 |= TIM_ForcedAction;
000686  4311              ORRS     r1,r1,r2
;;;1424   
;;;1425     /* Write to TIMx CCMR1 register */
;;;1426     TIMx->CCMR1 = tmpccmr1;
000688  8301              STRH     r1,[r0,#0x18]
;;;1427   }
00068a  4770              BX       lr
;;;1428   
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1442   *******************************************************************************/
;;;1443   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
00068c  8b02              LDRH     r2,[r0,#0x18]
;;;1444   {
;;;1445     u16 tmpccmr1 = 0;
;;;1446   
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1449     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1450   
;;;1451     tmpccmr1 = TIMx->CCMR1;
;;;1452   
;;;1453     /* Reset the OC2M Bits */
;;;1454     tmpccmr1 &= CCMR_OC24M_Mask;
00068e  f42242e0          BIC      r2,r2,#0x7000
;;;1455   
;;;1456     /* Configure The Forced output Mode */
;;;1457     tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
000692  ea422101          ORR      r1,r2,r1,LSL #8
;;;1458   
;;;1459     /* Write to TIMx CCMR1 register */
;;;1460     TIMx->CCMR1 = tmpccmr1;
000696  8301              STRH     r1,[r0,#0x18]
;;;1461   }
000698  4770              BX       lr
;;;1462   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1476   *******************************************************************************/
;;;1477   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
00069a  8b82              LDRH     r2,[r0,#0x1c]
;;;1478   {
;;;1479     u16 tmpccmr2 = 0;
;;;1480   
;;;1481     /* Check the parameters */
;;;1482     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1483     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1484   
;;;1485     tmpccmr2 = TIMx->CCMR2;
;;;1486   
;;;1487     /* Reset the OC1M Bits */
;;;1488     tmpccmr2 &= CCMR_OC13M_Mask;
00069c  f0220270          BIC      r2,r2,#0x70
;;;1489   
;;;1490     /* Configure The Forced output Mode */
;;;1491     tmpccmr2 |= TIM_ForcedAction;
0006a0  4311              ORRS     r1,r1,r2
;;;1492   
;;;1493     /* Write to TIMx CCMR2 register */
;;;1494     TIMx->CCMR2 = tmpccmr2;
0006a2  8381              STRH     r1,[r0,#0x1c]
;;;1495   }
0006a4  4770              BX       lr
;;;1496   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1510   *******************************************************************************/
;;;1511   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
0006a6  8b82              LDRH     r2,[r0,#0x1c]
;;;1512   {
;;;1513     u16 tmpccmr2 = 0;
;;;1514   
;;;1515     /* Check the parameters */
;;;1516     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1517     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1518     tmpccmr2 = TIMx->CCMR2;
;;;1519   
;;;1520     /* Reset the OC2M Bits */
;;;1521     tmpccmr2 &= CCMR_OC24M_Mask;
0006a8  f42242e0          BIC      r2,r2,#0x7000
;;;1522   
;;;1523     /* Configure The Forced output Mode */
;;;1524     tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
0006ac  ea422101          ORR      r1,r2,r1,LSL #8
;;;1525   
;;;1526     /* Write to TIMx CCMR2 register */
;;;1527     TIMx->CCMR2 = tmpccmr2;
0006b0  8381              STRH     r1,[r0,#0x1c]
;;;1528   }
0006b2  4770              BX       lr
;;;1529   
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;1539   *******************************************************************************/
;;;1540   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
0006b4  b121              CBZ      r1,|L1.1728|
;;;1541   {
;;;1542     /* Check the parameters */
;;;1543     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1544     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1545   
;;;1546     if (NewState != DISABLE)
;;;1547     {
;;;1548       /* Set the ARR Preload Bit */
;;;1549       TIMx->CR1 |= CR1_ARPE_Set;
0006b6  8801              LDRH     r1,[r0,#0]
0006b8  f0410180          ORR      r1,r1,#0x80
0006bc  8001              STRH     r1,[r0,#0]
;;;1550     }
;;;1551     else
;;;1552     {
;;;1553       /* Reset the ARR Preload Bit */
;;;1554       TIMx->CR1 &= CR1_ARPE_Reset;
;;;1555     }
;;;1556   }
0006be  4770              BX       lr
                  |L1.1728|
0006c0  8801              LDRH     r1,[r0,#0]            ;1554
0006c2  f42141f9          BIC      r1,r1,#0x7c80         ;1554
0006c6  f4214100          BIC      r1,r1,#0x8000         ;1554
0006ca  8001              STRH     r1,[r0,#0]            ;1554
0006cc  4770              BX       lr
;;;1557   
                          ENDP

                  TIM_SelectCOM PROC
;;;1566   *******************************************************************************/
;;;1567   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
0006ce  b121              CBZ      r1,|L1.1754|
;;;1568   {
;;;1569     /* Check the parameters */
;;;1570     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1571     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1572   
;;;1573     if (NewState != DISABLE)
;;;1574     {
;;;1575       /* Set the COM Bit */
;;;1576       TIMx->CR2 |= CR2_CCUS_Set;
0006d0  8881              LDRH     r1,[r0,#4]
0006d2  f0410104          ORR      r1,r1,#4
0006d6  8081              STRH     r1,[r0,#4]
;;;1577     }
;;;1578     else
;;;1579     {
;;;1580       /* Reset the COM Bit */
;;;1581       TIMx->CR2 &= CR2_CCUS_Reset;
;;;1582     }
;;;1583   }
0006d8  4770              BX       lr
                  |L1.1754|
0006da  8881              LDRH     r1,[r0,#4]            ;1581
0006dc  f0210104          BIC      r1,r1,#4              ;1581
0006e0  8081              STRH     r1,[r0,#4]            ;1581
0006e2  4770              BX       lr
;;;1584   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;1594   *******************************************************************************/
;;;1595   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
0006e4  b121              CBZ      r1,|L1.1776|
;;;1596   {
;;;1597     /* Check the parameters */
;;;1598     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1599     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1600   
;;;1601     if (NewState != DISABLE)
;;;1602     {
;;;1603       /* Set the CCDS Bit */
;;;1604       TIMx->CR2 |= CR2_CCDS_Set;
0006e6  8881              LDRH     r1,[r0,#4]
0006e8  f0410108          ORR      r1,r1,#8
0006ec  8081              STRH     r1,[r0,#4]
;;;1605     }
;;;1606     else
;;;1607     {
;;;1608       /* Reset the CCDS Bit */
;;;1609       TIMx->CR2 &= CR2_CCDS_Reset;
;;;1610     }
;;;1611   }
0006ee  4770              BX       lr
                  |L1.1776|
0006f0  8881              LDRH     r1,[r0,#4]            ;1609
0006f2  f0210108          BIC      r1,r1,#8              ;1609
0006f6  8081              STRH     r1,[r0,#4]            ;1609
0006f8  4770              BX       lr
;;;1612   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;1622   *******************************************************************************/
;;;1623   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
0006fa  b121              CBZ      r1,|L1.1798|
;;;1624   { 
;;;1625     /* Check the parameters */
;;;1626     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1627     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1628   
;;;1629     if (NewState != DISABLE)
;;;1630     {
;;;1631       /* Set the CCPC Bit */
;;;1632       TIMx->CR2 |= CR2_CCPC_Set;
0006fc  8881              LDRH     r1,[r0,#4]
0006fe  f0410101          ORR      r1,r1,#1
000702  8081              STRH     r1,[r0,#4]
;;;1633     }
;;;1634     else
;;;1635     {
;;;1636       /* Reset the CCPC Bit */
;;;1637       TIMx->CR2 &= CR2_CCPC_Reset;
;;;1638     }
;;;1639   }
000704  4770              BX       lr
                  |L1.1798|
000706  8881              LDRH     r1,[r0,#4]            ;1637
000708  f0210101          BIC      r1,r1,#1              ;1637
00070c  8081              STRH     r1,[r0,#4]            ;1637
00070e  4770              BX       lr
;;;1640   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1653   *******************************************************************************/
;;;1654   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000710  8b02              LDRH     r2,[r0,#0x18]
;;;1655   {
;;;1656     u16 tmpccmr1 = 0;
;;;1657   
;;;1658     /* Check the parameters */
;;;1659     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1660     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1661   
;;;1662     tmpccmr1 = TIMx->CCMR1;
;;;1663   
;;;1664     /* Reset the OC1PE Bit */
;;;1665     tmpccmr1 &= CCMR_OC13PE_Reset;
000712  f0220208          BIC      r2,r2,#8
;;;1666   
;;;1667     /* Enable or Disable the Output Compare Preload feature */
;;;1668     tmpccmr1 |= TIM_OCPreload;
000716  4311              ORRS     r1,r1,r2
;;;1669   
;;;1670     /* Write to TIMx CCMR1 register */
;;;1671     TIMx->CCMR1 = tmpccmr1;
000718  8301              STRH     r1,[r0,#0x18]
;;;1672   }
00071a  4770              BX       lr
;;;1673   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1686   *******************************************************************************/
;;;1687   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
00071c  8b02              LDRH     r2,[r0,#0x18]
;;;1688   {
;;;1689     u16 tmpccmr1 = 0;
;;;1690   
;;;1691     /* Check the parameters */
;;;1692     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1693     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1694   
;;;1695     tmpccmr1 = TIMx->CCMR1;
;;;1696   
;;;1697     /* Reset the OC2PE Bit */
;;;1698     tmpccmr1 &= CCMR_OC24PE_Reset;
00071e  f4226200          BIC      r2,r2,#0x800
;;;1699   
;;;1700     /* Enable or Disable the Output Compare Preload feature */
;;;1701     tmpccmr1 |= (u16)(TIM_OCPreload << 8);
000722  ea422101          ORR      r1,r2,r1,LSL #8
;;;1702   
;;;1703     /* Write to TIMx CCMR1 register */
;;;1704     TIMx->CCMR1 = tmpccmr1;
000726  8301              STRH     r1,[r0,#0x18]
;;;1705   }
000728  4770              BX       lr
;;;1706   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1719   *******************************************************************************/
;;;1720   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
00072a  8b82              LDRH     r2,[r0,#0x1c]
;;;1721   {
;;;1722     u16 tmpccmr2 = 0;
;;;1723   
;;;1724     /* Check the parameters */
;;;1725     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1726     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1727   
;;;1728     tmpccmr2 = TIMx->CCMR2;
;;;1729   
;;;1730     /* Reset the OC3PE Bit */
;;;1731     tmpccmr2 &= CCMR_OC13PE_Reset;
00072c  f0220208          BIC      r2,r2,#8
;;;1732   
;;;1733     /* Enable or Disable the Output Compare Preload feature */
;;;1734     tmpccmr2 |= TIM_OCPreload;
000730  4311              ORRS     r1,r1,r2
;;;1735   
;;;1736     /* Write to TIMx CCMR2 register */
;;;1737     TIMx->CCMR2 = tmpccmr2;
000732  8381              STRH     r1,[r0,#0x1c]
;;;1738   }
000734  4770              BX       lr
;;;1739   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1752   *******************************************************************************/
;;;1753   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000736  8b82              LDRH     r2,[r0,#0x1c]
;;;1754   {
;;;1755     u16 tmpccmr2 = 0;
;;;1756   
;;;1757     /* Check the parameters */
;;;1758     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1759     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1760   
;;;1761     tmpccmr2 = TIMx->CCMR2;
;;;1762   
;;;1763     /* Reset the OC4PE Bit */
;;;1764     tmpccmr2 &= CCMR_OC24PE_Reset;
000738  f4226200          BIC      r2,r2,#0x800
;;;1765   
;;;1766     /* Enable or Disable the Output Compare Preload feature */
;;;1767     tmpccmr2 |= (u16)(TIM_OCPreload << 8);
00073c  ea422101          ORR      r1,r2,r1,LSL #8
;;;1768   
;;;1769     /* Write to TIMx CCMR2 register */
;;;1770     TIMx->CCMR2 = tmpccmr2;
000740  8381              STRH     r1,[r0,#0x1c]
;;;1771   }
000742  4770              BX       lr
;;;1772   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1784   *******************************************************************************/
;;;1785   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000744  8b02              LDRH     r2,[r0,#0x18]
;;;1786   {
;;;1787     u16 tmpccmr1 = 0;
;;;1788   
;;;1789     /* Check the parameters */
;;;1790     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1791     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1792   
;;;1793     /* Get the TIMx CCMR1 register value */
;;;1794     tmpccmr1 = TIMx->CCMR1;
;;;1795   
;;;1796     /* Reset the OC1FE Bit */
;;;1797     tmpccmr1 &= CCMR_OC13FE_Reset;
000746  f0220204          BIC      r2,r2,#4
;;;1798   
;;;1799     /* Enable or Disable the Output Compare Fast Bit */
;;;1800     tmpccmr1 |= TIM_OCFast;
00074a  4311              ORRS     r1,r1,r2
;;;1801   
;;;1802     /* Write to TIMx CCMR1 */
;;;1803     TIMx->CCMR1 = tmpccmr1;
00074c  8301              STRH     r1,[r0,#0x18]
;;;1804   }
00074e  4770              BX       lr
;;;1805   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1817   *******************************************************************************/
;;;1818   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
000750  8b02              LDRH     r2,[r0,#0x18]
;;;1819   {
;;;1820     u16 tmpccmr1 = 0;
;;;1821   
;;;1822     /* Check the parameters */
;;;1823     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1824     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1825   
;;;1826     /* Get the TIMx CCMR1 register value */
;;;1827     tmpccmr1 = TIMx->CCMR1;
;;;1828   
;;;1829     /* Reset the OC2FE Bit */
;;;1830     tmpccmr1 &= CCMR_OC24FE_Reset;
000752  f4226280          BIC      r2,r2,#0x400
;;;1831   
;;;1832     /* Enable or Disable the Output Compare Fast Bit */
;;;1833     tmpccmr1 |= (u16)(TIM_OCFast << 8);
000756  ea422101          ORR      r1,r2,r1,LSL #8
;;;1834   
;;;1835     /* Write to TIMx CCMR1 */
;;;1836     TIMx->CCMR1 = tmpccmr1;
00075a  8301              STRH     r1,[r0,#0x18]
;;;1837   }
00075c  4770              BX       lr
;;;1838   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1850   *******************************************************************************/
;;;1851   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
00075e  8b82              LDRH     r2,[r0,#0x1c]
;;;1852   {
;;;1853     u16 tmpccmr2 = 0;
;;;1854   
;;;1855     /* Check the parameters */
;;;1856     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1857     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1858   
;;;1859     /* Get the TIMx CCMR2 register value */
;;;1860     tmpccmr2 = TIMx->CCMR2;
;;;1861   
;;;1862     /* Reset the OC3FE Bit */
;;;1863     tmpccmr2 &= CCMR_OC13FE_Reset;
000760  f0220204          BIC      r2,r2,#4
;;;1864   
;;;1865     /* Enable or Disable the Output Compare Fast Bit */
;;;1866     tmpccmr2 |= TIM_OCFast;
000764  4311              ORRS     r1,r1,r2
;;;1867   
;;;1868     /* Write to TIMx CCMR2 */
;;;1869     TIMx->CCMR2 = tmpccmr2;
000766  8381              STRH     r1,[r0,#0x1c]
;;;1870   }
000768  4770              BX       lr
;;;1871   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1883   *******************************************************************************/
;;;1884   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
00076a  8b82              LDRH     r2,[r0,#0x1c]
;;;1885   {
;;;1886     u16 tmpccmr2 = 0;
;;;1887   
;;;1888     /* Check the parameters */
;;;1889     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1890     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1891   
;;;1892     /* Get the TIMx CCMR2 register value */
;;;1893     tmpccmr2 = TIMx->CCMR2;
;;;1894   
;;;1895     /* Reset the OC4FE Bit */
;;;1896     tmpccmr2 &= CCMR_OC24FE_Reset;
00076c  f4226280          BIC      r2,r2,#0x400
;;;1897   
;;;1898     /* Enable or Disable the Output Compare Fast Bit */
;;;1899     tmpccmr2 |= (u16)(TIM_OCFast << 8);
000770  ea422101          ORR      r1,r2,r1,LSL #8
;;;1900   
;;;1901     /* Write to TIMx CCMR2 */
;;;1902     TIMx->CCMR2 = tmpccmr2;
000774  8381              STRH     r1,[r0,#0x1c]
;;;1903   }
000776  4770              BX       lr
;;;1904   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1916   *******************************************************************************/
;;;1917   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000778  8b02              LDRH     r2,[r0,#0x18]
;;;1918   {
;;;1919     u16 tmpccmr1 = 0;
;;;1920   
;;;1921     /* Check the parameters */
;;;1922     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1923     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1924   
;;;1925     tmpccmr1 = TIMx->CCMR1;
;;;1926   
;;;1927     /* Reset the OC1CE Bit */
;;;1928     tmpccmr1 &= CCMR_OC13CE_Reset;
00077a  f0220280          BIC      r2,r2,#0x80
;;;1929   
;;;1930     /* Enable or Disable the Output Compare Clear Bit */
;;;1931     tmpccmr1 |= TIM_OCClear;
00077e  4311              ORRS     r1,r1,r2
;;;1932   
;;;1933     /* Write to TIMx CCMR1 register */
;;;1934     TIMx->CCMR1 = tmpccmr1;
000780  8301              STRH     r1,[r0,#0x18]
;;;1935   }
000782  4770              BX       lr
;;;1936   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1948   *******************************************************************************/
;;;1949   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000784  8b02              LDRH     r2,[r0,#0x18]
;;;1950   {
;;;1951     u16 tmpccmr1 = 0;
;;;1952   
;;;1953     /* Check the parameters */
;;;1954     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1955     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1956   
;;;1957     tmpccmr1 = TIMx->CCMR1;
;;;1958   
;;;1959     /* Reset the OC2CE Bit */
;;;1960     tmpccmr1 &= CCMR_OC24CE_Reset;
000786  f3c2020e          UBFX     r2,r2,#0,#15
;;;1961   
;;;1962     /* Enable or Disable the Output Compare Clear Bit */
;;;1963     tmpccmr1 |= (u16)(TIM_OCClear << 8);
00078a  ea422101          ORR      r1,r2,r1,LSL #8
;;;1964   
;;;1965     /* Write to TIMx CCMR1 register */
;;;1966     TIMx->CCMR1 = tmpccmr1;
00078e  8301              STRH     r1,[r0,#0x18]
;;;1967   }
000790  4770              BX       lr
;;;1968   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1980   *******************************************************************************/
;;;1981   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000792  8b82              LDRH     r2,[r0,#0x1c]
;;;1982   {
;;;1983     u16 tmpccmr2 = 0;
;;;1984   
;;;1985     /* Check the parameters */
;;;1986     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1987     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1988   
;;;1989     tmpccmr2 = TIMx->CCMR2;
;;;1990   
;;;1991     /* Reset the OC3CE Bit */
;;;1992     tmpccmr2 &= CCMR_OC13CE_Reset;
000794  f0220280          BIC      r2,r2,#0x80
;;;1993   
;;;1994     /* Enable or Disable the Output Compare Clear Bit */
;;;1995     tmpccmr2 |= TIM_OCClear;
000798  4311              ORRS     r1,r1,r2
;;;1996   
;;;1997     /* Write to TIMx CCMR2 register */
;;;1998     TIMx->CCMR2 = tmpccmr2;
00079a  8381              STRH     r1,[r0,#0x1c]
;;;1999   }
00079c  4770              BX       lr
;;;2000   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;2012   *******************************************************************************/
;;;2013   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
00079e  8b82              LDRH     r2,[r0,#0x1c]
;;;2014   {
;;;2015     u16 tmpccmr2 = 0;
;;;2016   
;;;2017     /* Check the parameters */
;;;2018     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2019     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;2020   
;;;2021     tmpccmr2 = TIMx->CCMR2;
;;;2022   
;;;2023     /* Reset the OC4CE Bit */
;;;2024     tmpccmr2 &= CCMR_OC24CE_Reset;
0007a0  f3c2020e          UBFX     r2,r2,#0,#15
;;;2025   
;;;2026     /* Enable or Disable the Output Compare Clear Bit */
;;;2027     tmpccmr2 |= (u16)(TIM_OCClear << 8);
0007a4  ea422101          ORR      r1,r2,r1,LSL #8
;;;2028   
;;;2029     /* Write to TIMx CCMR2 register */
;;;2030     TIMx->CCMR2 = tmpccmr2;
0007a8  8381              STRH     r1,[r0,#0x1c]
;;;2031   }
0007aa  4770              BX       lr
;;;2032   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;2044   *******************************************************************************/
;;;2045   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
0007ac  8c02              LDRH     r2,[r0,#0x20]
;;;2046   {
;;;2047     u16 tmpccer = 0;
;;;2048   
;;;2049     /* Check the parameters */
;;;2050     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2051     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2052   
;;;2053     tmpccer = TIMx->CCER;
;;;2054   
;;;2055     /* Set or Reset the CC1P Bit */
;;;2056     tmpccer &= CCER_CC1P_Reset;
0007ae  f0220202          BIC      r2,r2,#2
;;;2057     tmpccer |= TIM_OCPolarity;
0007b2  4311              ORRS     r1,r1,r2
;;;2058   
;;;2059     /* Write to TIMx CCER register */
;;;2060     TIMx->CCER = tmpccer;
0007b4  8401              STRH     r1,[r0,#0x20]
;;;2061   }
0007b6  4770              BX       lr
;;;2062   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;2073   *******************************************************************************/
;;;2074   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
0007b8  8c02              LDRH     r2,[r0,#0x20]
;;;2075   {
;;;2076     u16 tmpccer = 0;
;;;2077   
;;;2078     /* Check the parameters */
;;;2079     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2080     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2081      
;;;2082     tmpccer = TIMx->CCER;
;;;2083   
;;;2084     /* Set or Reset the CC1NP Bit */
;;;2085     tmpccer &= CCER_CC1NP_Reset;
0007ba  f0220208          BIC      r2,r2,#8
;;;2086     tmpccer |= TIM_OCNPolarity;
0007be  4311              ORRS     r1,r1,r2
;;;2087   
;;;2088     /* Write to TIMx CCER register */
;;;2089     TIMx->CCER = tmpccer;
0007c0  8401              STRH     r1,[r0,#0x20]
;;;2090   }
0007c2  4770              BX       lr
;;;2091   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;2103   *******************************************************************************/
;;;2104   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
0007c4  8c02              LDRH     r2,[r0,#0x20]
;;;2105   {
;;;2106     u16 tmpccer = 0;
;;;2107   
;;;2108     /* Check the parameters */
;;;2109     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2110     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2111   
;;;2112     tmpccer = TIMx->CCER;
;;;2113   
;;;2114     /* Set or Reset the CC2P Bit */
;;;2115     tmpccer &= CCER_CC2P_Reset;
0007c6  f0220220          BIC      r2,r2,#0x20
;;;2116     tmpccer |= (u16)(TIM_OCPolarity << 4);
0007ca  ea421101          ORR      r1,r2,r1,LSL #4
;;;2117   
;;;2118     /* Write to TIMx CCER register */
;;;2119     TIMx->CCER = tmpccer;
0007ce  8401              STRH     r1,[r0,#0x20]
;;;2120   }
0007d0  4770              BX       lr
;;;2121   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;2132   *******************************************************************************/
;;;2133   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
0007d2  8c02              LDRH     r2,[r0,#0x20]
;;;2134   {
;;;2135     u16 tmpccer = 0;
;;;2136   
;;;2137     /* Check the parameters */
;;;2138     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2139     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2140     
;;;2141     tmpccer = TIMx->CCER;
;;;2142   
;;;2143     /* Set or Reset the CC2NP Bit */
;;;2144     tmpccer &= CCER_CC2NP_Reset;
0007d4  f0220280          BIC      r2,r2,#0x80
;;;2145     tmpccer |= (u16)(TIM_OCNPolarity << 4);
0007d8  ea421101          ORR      r1,r2,r1,LSL #4
;;;2146   
;;;2147     /* Write to TIMx CCER register */
;;;2148     TIMx->CCER = tmpccer;
0007dc  8401              STRH     r1,[r0,#0x20]
;;;2149   }
0007de  4770              BX       lr
;;;2150   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;2162   *******************************************************************************/
;;;2163   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
0007e0  8c02              LDRH     r2,[r0,#0x20]
;;;2164   {
;;;2165     u16 tmpccer = 0;
;;;2166   
;;;2167     /* Check the parameters */
;;;2168     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2169     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2170   
;;;2171     tmpccer = TIMx->CCER;
;;;2172   
;;;2173     /* Set or Reset the CC3P Bit */
;;;2174     tmpccer &= CCER_CC3P_Reset;
0007e2  f4227200          BIC      r2,r2,#0x200
;;;2175     tmpccer |= (u16)(TIM_OCPolarity << 8);
0007e6  ea422101          ORR      r1,r2,r1,LSL #8
;;;2176   
;;;2177     /* Write to TIMx CCER register */
;;;2178     TIMx->CCER = tmpccer;
0007ea  8401              STRH     r1,[r0,#0x20]
;;;2179   }
0007ec  4770              BX       lr
;;;2180   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;2191   *******************************************************************************/
;;;2192   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
0007ee  8c02              LDRH     r2,[r0,#0x20]
;;;2193   {
;;;2194     u16 tmpccer = 0;
;;;2195    
;;;2196     /* Check the parameters */
;;;2197     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2198     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2199       
;;;2200     tmpccer = TIMx->CCER;
;;;2201   
;;;2202     /* Set or Reset the CC3NP Bit */
;;;2203     tmpccer &= CCER_CC3NP_Reset;
0007f0  f4226200          BIC      r2,r2,#0x800
;;;2204     tmpccer |= (u16)(TIM_OCNPolarity << 8);
0007f4  ea422101          ORR      r1,r2,r1,LSL #8
;;;2205   
;;;2206     /* Write to TIMx CCER register */
;;;2207     TIMx->CCER = tmpccer;
0007f8  8401              STRH     r1,[r0,#0x20]
;;;2208   }
0007fa  4770              BX       lr
;;;2209   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;2221   *******************************************************************************/
;;;2222   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
0007fc  8c02              LDRH     r2,[r0,#0x20]
;;;2223   {
;;;2224     u16 tmpccer = 0;
;;;2225   
;;;2226     /* Check the parameters */
;;;2227     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2228     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2229   
;;;2230     tmpccer = TIMx->CCER;
;;;2231   
;;;2232     /* Set or Reset the CC4P Bit */
;;;2233     tmpccer &= CCER_CC4P_Reset;
0007fe  f4225200          BIC      r2,r2,#0x2000
;;;2234     tmpccer |= (u16)(TIM_OCPolarity << 12);
000802  ea423101          ORR      r1,r2,r1,LSL #12
;;;2235   
;;;2236     /* Write to TIMx CCER register */
;;;2237     TIMx->CCER = tmpccer;
000806  8401              STRH     r1,[r0,#0x20]
;;;2238   }
000808  4770              BX       lr
;;;2239   
                          ENDP

                  TIM_CCxCmd PROC
;;;2255   *******************************************************************************/
;;;2256   void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
00080a  f8b0c020          LDRH     r12,[r0,#0x20]
;;;2257   {
;;;2258     /* Check the parameters */
;;;2259     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2260     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2261     assert_param(IS_TIM_CCX(TIM_CCx));
;;;2262   
;;;2263     /* Reset the CCxE Bit */
;;;2264     TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
00080e  2301              MOVS     r3,#1
000810  408b              LSLS     r3,r3,r1
000812  ea2c0303          BIC      r3,r12,r3
000816  8403              STRH     r3,[r0,#0x20]
;;;2265   
;;;2266     /* Set or reset the CCxE Bit */ 
;;;2267     TIMx->CCER |=  (u16)(TIM_CCx << TIM_Channel);
000818  8c03              LDRH     r3,[r0,#0x20]
00081a  fa02f101          LSL      r1,r2,r1
00081e  4319              ORRS     r1,r1,r3
000820  8401              STRH     r1,[r0,#0x20]
;;;2268   }
000822  4770              BX       lr
;;;2269   
                          ENDP

                  TIM_CCxNCmd PROC
;;;2283   *******************************************************************************/
;;;2284   void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
000824  f8b0c020          LDRH     r12,[r0,#0x20]
;;;2285   {
;;;2286     /* Check the parameters */
;;;2287     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2288     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2289     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2290   
;;;2291     /* Reset the CCxNE Bit */
;;;2292     TIMx->CCER &= (u16)(~((u16)(CCER_CCNE_Set << TIM_Channel)));
000828  2304              MOVS     r3,#4
00082a  408b              LSLS     r3,r3,r1
00082c  ea2c0303          BIC      r3,r12,r3
000830  8403              STRH     r3,[r0,#0x20]
;;;2293   
;;;2294     /* Set or reset the CCxNE Bit */ 
;;;2295     TIMx->CCER |=  (u16)(TIM_CCxN << TIM_Channel);
000832  8c03              LDRH     r3,[r0,#0x20]
000834  fa02f101          LSL      r1,r2,r1
000838  4319              ORRS     r1,r1,r3
00083a  8401              STRH     r1,[r0,#0x20]
;;;2296   }
00083c  4770              BX       lr
;;;2297   
                          ENDP

                  TIM_SelectOCxM PROC
;;;2323   *******************************************************************************/
;;;2324   void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
00083e  f8b0c020          LDRH     r12,[r0,#0x20]
;;;2325   {
;;;2326     /* Check the parameters */
;;;2327     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2328     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2329     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2330     
;;;2331     /* Disable the Channel: Reset the CCxE Bit */
;;;2332     TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
000842  2301              MOVS     r3,#1
000844  408b              LSLS     r3,r3,r1
000846  ea2c0303          BIC      r3,r12,r3
00084a  8403              STRH     r3,[r0,#0x20]
;;;2333   
;;;2334     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
00084c  b171              CBZ      r1,|L1.2156|
00084e  2908              CMP      r1,#8
000850  d00c              BEQ      |L1.2156|
;;;2335     {
;;;2336       /* Reset the OCxM bits in the CCMRx register */
;;;2337       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
;;;2338      
;;;2339       /* Configure the OCxM bits in the CCMRx register */
;;;2340       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) = TIM_OCMode;
;;;2341   
;;;2342     }
;;;2343     else
;;;2344     {
;;;2345       /* Reset the OCxM bits in the CCMRx register */
;;;2346       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
000852  1f09              SUBS     r1,r1,#4
000854  b289              UXTH     r1,r1
000856  eb000051          ADD      r0,r0,r1,LSR #1
00085a  6981              LDR      r1,[r0,#0x18]
00085c  f64873ff          MOV      r3,#0x8fff
000860  4019              ANDS     r1,r1,r3
000862  6181              STR      r1,[r0,#0x18]
;;;2347       
;;;2348       /* Configure the OCxM bits in the CCMRx register */
;;;2349       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) = (u16)(TIM_OCMode << 8);
000864  0611              LSLS     r1,r2,#24
000866  0c09              LSRS     r1,r1,#16
000868  6181              STR      r1,[r0,#0x18]
;;;2350     }
;;;2351   }
00086a  4770              BX       lr
                  |L1.2156|
00086c  eb000051          ADD      r0,r0,r1,LSR #1       ;2337
000870  6981              LDR      r1,[r0,#0x18]         ;2337
000872  f64f738f          MOV      r3,#0xff8f            ;2337
000876  4019              ANDS     r1,r1,r3              ;2337
000878  6181              STR      r1,[r0,#0x18]         ;2337
00087a  6182              STR      r2,[r0,#0x18]         ;2340
00087c  4770              BX       lr
;;;2352   
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;2361   *******************************************************************************/
;;;2362   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
00087e  b121              CBZ      r1,|L1.2186|
;;;2363   {
;;;2364     /* Check the parameters */
;;;2365     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2366     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2367   
;;;2368     if (NewState != DISABLE)
;;;2369     {
;;;2370       /* Set the Update Disable Bit */
;;;2371       TIMx->CR1 |= CR1_UDIS_Set;
000880  8801              LDRH     r1,[r0,#0]
000882  f0410102          ORR      r1,r1,#2
000886  8001              STRH     r1,[r0,#0]
;;;2372     }
;;;2373     else
;;;2374     {
;;;2375       /* Reset the Update Disable Bit */
;;;2376       TIMx->CR1 &= CR1_UDIS_Reset;
;;;2377     }
;;;2378   }
000888  4770              BX       lr
                  |L1.2186|
00088a  8801              LDRH     r1,[r0,#0]            ;2376
00088c  f0210102          BIC      r1,r1,#2              ;2376
000890  f421417c          BIC      r1,r1,#0xfc00         ;2376
000894  8001              STRH     r1,[r0,#0]            ;2376
000896  4770              BX       lr
;;;2379   
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;2390   *******************************************************************************/
;;;2391   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
000898  b121              CBZ      r1,|L1.2212|
;;;2392   {
;;;2393     /* Check the parameters */
;;;2394     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2395     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2396   
;;;2397     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2398     {
;;;2399       /* Set the URS Bit */
;;;2400       TIMx->CR1 |= CR1_URS_Set;
00089a  8801              LDRH     r1,[r0,#0]
00089c  f0410104          ORR      r1,r1,#4
0008a0  8001              STRH     r1,[r0,#0]
;;;2401     }
;;;2402     else
;;;2403     {
;;;2404       /* Reset the URS Bit */
;;;2405       TIMx->CR1 &= CR1_URS_Reset;
;;;2406     }
;;;2407   }
0008a2  4770              BX       lr
                  |L1.2212|
0008a4  8801              LDRH     r1,[r0,#0]            ;2405
0008a6  f0210104          BIC      r1,r1,#4              ;2405
0008aa  f421417c          BIC      r1,r1,#0xfc00         ;2405
0008ae  8001              STRH     r1,[r0,#0]            ;2405
0008b0  4770              BX       lr
;;;2408   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;2417   *******************************************************************************/
;;;2418   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
0008b2  b121              CBZ      r1,|L1.2238|
;;;2419   {
;;;2420     /* Check the parameters */
;;;2421     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2422     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2423   
;;;2424     if (NewState != DISABLE)
;;;2425     {
;;;2426       /* Set the TI1S Bit */
;;;2427       TIMx->CR2 |= CR2_TI1S_Set;
0008b4  8881              LDRH     r1,[r0,#4]
0008b6  f0410180          ORR      r1,r1,#0x80
0008ba  8081              STRH     r1,[r0,#4]
;;;2428     }
;;;2429     else
;;;2430     {
;;;2431       /* Reset the TI1S Bit */
;;;2432       TIMx->CR2 &= CR2_TI1S_Reset;
;;;2433     }
;;;2434   }
0008bc  4770              BX       lr
                  |L1.2238|
0008be  8881              LDRH     r1,[r0,#4]            ;2432
0008c0  f0210180          BIC      r1,r1,#0x80           ;2432
0008c4  8081              STRH     r1,[r0,#4]            ;2432
0008c6  4770              BX       lr
;;;2435   
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;2446   *******************************************************************************/
;;;2447   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
0008c8  8802              LDRH     r2,[r0,#0]
;;;2448   {
;;;2449     /* Check the parameters */
;;;2450     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2451     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2452   
;;;2453     /* Reset the OPM Bit */
;;;2454     TIMx->CR1 &= CR1_OPM_Reset;
0008ca  f4226281          BIC      r2,r2,#0x408
0008ce  f4224278          BIC      r2,r2,#0xf800
0008d2  8002              STRH     r2,[r0,#0]
;;;2455   
;;;2456     /* Configure the OPM Mode */
;;;2457     TIMx->CR1 |= TIM_OPMode;
0008d4  8802              LDRH     r2,[r0,#0]
0008d6  4311              ORRS     r1,r1,r2
0008d8  8001              STRH     r1,[r0,#0]
;;;2458   }
0008da  4770              BX       lr
;;;2459   
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2479   *******************************************************************************/
;;;2480   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
0008dc  8882              LDRH     r2,[r0,#4]
;;;2481   {
;;;2482     /* Check the parameters */
;;;2483     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2484     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2485     assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
;;;2486   
;;;2487     /* Reset the MMS Bits */
;;;2488     TIMx->CR2 &= CR2_MMS_Mask;
0008de  f0220270          BIC      r2,r2,#0x70
0008e2  8082              STRH     r2,[r0,#4]
;;;2489   
;;;2490     /* Select the TRGO source */
;;;2491     TIMx->CR2 |=  TIM_TRGOSource;
0008e4  8882              LDRH     r2,[r0,#4]
0008e6  4311              ORRS     r1,r1,r2
0008e8  8081              STRH     r1,[r0,#4]
;;;2492   }
0008ea  4770              BX       lr
;;;2493   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2507   *******************************************************************************/
;;;2508   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
0008ec  8902              LDRH     r2,[r0,#8]
;;;2509   {
;;;2510     /* Check the parameters */
;;;2511     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2512     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2513   
;;;2514     /* Reset the SMS Bits */
;;;2515     TIMx->SMCR &= SMCR_SMS_Mask;
0008ee  f0220207          BIC      r2,r2,#7
0008f2  8102              STRH     r2,[r0,#8]
;;;2516   
;;;2517     /* Select the Slave Mode */
;;;2518     TIMx->SMCR |= TIM_SlaveMode;
0008f4  8902              LDRH     r2,[r0,#8]
0008f6  4311              ORRS     r1,r1,r2
0008f8  8101              STRH     r1,[r0,#8]
;;;2519   }
0008fa  4770              BX       lr
;;;2520   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2533   *******************************************************************************/
;;;2534   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
0008fc  8902              LDRH     r2,[r0,#8]
;;;2535   {
;;;2536     /* Check the parameters */
;;;2537     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2538     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2539   
;;;2540     /* Reset the MSM Bit */
;;;2541     TIMx->SMCR &= SMCR_MSM_Reset;
0008fe  f0220280          BIC      r2,r2,#0x80
000902  8102              STRH     r2,[r0,#8]
;;;2542     
;;;2543     /* Set or Reset the MSM Bit */
;;;2544     TIMx->SMCR |= TIM_MasterSlaveMode;
000904  8902              LDRH     r2,[r0,#8]
000906  4311              ORRS     r1,r1,r2
000908  8101              STRH     r1,[r0,#8]
;;;2545   }
00090a  4770              BX       lr
;;;2546   
                          ENDP

                  TIM_SetCounter PROC
;;;2554   *******************************************************************************/
;;;2555   void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
00090c  8481              STRH     r1,[r0,#0x24]
;;;2556   {
;;;2557     /* Check the parameters */
;;;2558     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2559   
;;;2560     /* Set the Counter Register value */
;;;2561     TIMx->CNT = Counter;
;;;2562   }
00090e  4770              BX       lr
;;;2563   
                          ENDP

                  TIM_SetAutoreload PROC
;;;2571   *******************************************************************************/
;;;2572   void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
000910  8581              STRH     r1,[r0,#0x2c]
;;;2573   {
;;;2574     /* Check the parameters */
;;;2575     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2576   
;;;2577     /* Set the Autoreload Register value */
;;;2578     TIMx->ARR = Autoreload;
;;;2579   }
000912  4770              BX       lr
;;;2580   
                          ENDP

                  TIM_SetCompare1 PROC
;;;2589   *******************************************************************************/
;;;2590   void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
000914  8681              STRH     r1,[r0,#0x34]
;;;2591   {
;;;2592     /* Check the parameters */
;;;2593     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2594   
;;;2595     /* Set the Capture Compare1 Register value */
;;;2596     TIMx->CCR1 = Compare1;
;;;2597   }
000916  4770              BX       lr
;;;2598   
                          ENDP

                  TIM_SetCompare2 PROC
;;;2607   *******************************************************************************/
;;;2608   void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
000918  8701              STRH     r1,[r0,#0x38]
;;;2609   {
;;;2610     /* Check the parameters */
;;;2611     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2612   
;;;2613     /* Set the Capture Compare2 Register value */
;;;2614     TIMx->CCR2 = Compare2;
;;;2615   }
00091a  4770              BX       lr
;;;2616   
                          ENDP

                  TIM_SetCompare3 PROC
;;;2625   *******************************************************************************/
;;;2626   void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
00091c  8781              STRH     r1,[r0,#0x3c]
;;;2627   {
;;;2628     /* Check the parameters */
;;;2629     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2630   
;;;2631     /* Set the Capture Compare3 Register value */
;;;2632     TIMx->CCR3 = Compare3;
;;;2633   }
00091e  4770              BX       lr
;;;2634   
                          ENDP

                  TIM_SetCompare4 PROC
;;;2643   *******************************************************************************/
;;;2644   void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
000920  f8a01040          STRH     r1,[r0,#0x40]
;;;2645   {
;;;2646     /* Check the parameters */
;;;2647     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2648   
;;;2649     /* Set the Capture Compare4 Register value */
;;;2650     TIMx->CCR4 = Compare4;
;;;2651   }
000924  4770              BX       lr
;;;2652   
                          ENDP

                  TIM_SetClockDivision PROC
;;;2777   *******************************************************************************/
;;;2778   void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
000926  8802              LDRH     r2,[r0,#0]
;;;2779   {
;;;2780     /* Check the parameters */
;;;2781     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2782     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2783   
;;;2784     /* Reset the CKD Bits */
;;;2785     TIMx->CR1 &= CR1_CKD_Mask;
000928  b2d2              UXTB     r2,r2
00092a  8002              STRH     r2,[r0,#0]
;;;2786   
;;;2787     /* Set the CKD value */
;;;2788     TIMx->CR1 |= TIM_CKD;
00092c  8802              LDRH     r2,[r0,#0]
00092e  4311              ORRS     r1,r1,r2
000930  8001              STRH     r1,[r0,#0]
;;;2789   }
000932  4770              BX       lr
;;;2790   /*******************************************************************************
                          ENDP

                  TIM_GetCapture1 PROC
;;;2797   *******************************************************************************/
;;;2798   u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
000934  8e80              LDRH     r0,[r0,#0x34]
;;;2799   {
;;;2800     /* Check the parameters */
;;;2801     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2802   
;;;2803     /* Get the Capture 1 Register value */
;;;2804     return TIMx->CCR1;
;;;2805   }
000936  4770              BX       lr
;;;2806   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2814   *******************************************************************************/
;;;2815   u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
000938  8f00              LDRH     r0,[r0,#0x38]
;;;2816   {
;;;2817     /* Check the parameters */
;;;2818     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2819   
;;;2820     /* Get the Capture 2 Register value */
;;;2821     return TIMx->CCR2;
;;;2822   }
00093a  4770              BX       lr
;;;2823   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2831   *******************************************************************************/
;;;2832   u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
00093c  8f80              LDRH     r0,[r0,#0x3c]
;;;2833   {
;;;2834     /* Check the parameters */
;;;2835     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2836   
;;;2837     /* Get the Capture 3 Register value */
;;;2838     return TIMx->CCR3;
;;;2839   }
00093e  4770              BX       lr
;;;2840   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2848   *******************************************************************************/
;;;2849   u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
000940  f8b00040          LDRH     r0,[r0,#0x40]
;;;2850   {
;;;2851     /* Check the parameters */
;;;2852     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2853   
;;;2854     /* Get the Capture 4 Register value */
;;;2855     return TIMx->CCR4;
;;;2856   }
000944  4770              BX       lr
;;;2857   
                          ENDP

                  TIM_GetCounter PROC
;;;2864   *******************************************************************************/
;;;2865   u16 TIM_GetCounter(TIM_TypeDef* TIMx)
000946  8c80              LDRH     r0,[r0,#0x24]
;;;2866   {
;;;2867     /* Check the parameters */
;;;2868     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2869   
;;;2870     /* Get the Counter Register value */
;;;2871     return TIMx->CNT;
;;;2872   }
000948  4770              BX       lr
;;;2873   
                          ENDP

                  TIM_GetPrescaler PROC
;;;2880   *******************************************************************************/
;;;2881   u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
00094a  8d00              LDRH     r0,[r0,#0x28]
;;;2882   {
;;;2883     /* Check the parameters */
;;;2884     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2885   
;;;2886     /* Get the Prescaler Register value */
;;;2887     return TIMx->PSC;
;;;2888   }
00094c  4770              BX       lr
;;;2889   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2910   *******************************************************************************/
;;;2911   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
00094e  4602              MOV      r2,r0
;;;2912   { 
;;;2913     ITStatus bitstatus = RESET;  
000950  2000              MOVS     r0,#0
;;;2914   
;;;2915     /* Check the parameters */
;;;2916     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2917     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2918     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2919     
;;;2920     if ((TIMx->SR & TIM_FLAG) != (u16)RESET)
000952  8a12              LDRH     r2,[r2,#0x10]
000954  420a              TST      r2,r1
000956  d000              BEQ      |L1.2394|
;;;2921     {
;;;2922       bitstatus = SET;
000958  2001              MOVS     r0,#1
                  |L1.2394|
;;;2923     }
;;;2924     else
;;;2925     {
;;;2926       bitstatus = RESET;
;;;2927     }
;;;2928     return bitstatus;
;;;2929   }
00095a  4770              BX       lr
;;;2930   
                          ENDP

                  TIM_ClearFlag PROC
;;;2951   *******************************************************************************/
;;;2952   void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
00095c  43c9              MVNS     r1,r1
;;;2953   {  
;;;2954     /* Check the parameters */
;;;2955     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2956     assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
;;;2957     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2958      
;;;2959     /* Clear the flags */
;;;2960     TIMx->SR = (u16)~TIM_FLAG;
00095e  8201              STRH     r1,[r0,#0x10]
;;;2961   }
000960  4770              BX       lr
;;;2962   
                          ENDP

                  TIM_GetITStatus PROC
;;;2980   *******************************************************************************/
;;;2981   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
000962  2200              MOVS     r2,#0
;;;2982   {
;;;2983     ITStatus bitstatus = RESET;  
;;;2984     u16 itstatus = 0x0, itenable = 0x0;
;;;2985   
;;;2986     /* Check the parameters */
;;;2987     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2988     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2989     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2990      
;;;2991     itstatus = TIMx->SR & TIM_IT;
000964  8a03              LDRH     r3,[r0,#0x10]
000966  400b              ANDS     r3,r3,r1
;;;2992     
;;;2993     itenable = TIMx->DIER & TIM_IT;
000968  8980              LDRH     r0,[r0,#0xc]
00096a  4008              ANDS     r0,r0,r1
;;;2994   
;;;2995     if ((itstatus != (u16)RESET) && (itenable != (u16)RESET))
00096c  b10b              CBZ      r3,|L1.2418|
00096e  b100              CBZ      r0,|L1.2418|
;;;2996     {
;;;2997       bitstatus = SET;
000970  2201              MOVS     r2,#1
                  |L1.2418|
;;;2998     }
;;;2999     else
;;;3000     {
;;;3001       bitstatus = RESET;
;;;3002     }
;;;3003     return bitstatus;
000972  4610              MOV      r0,r2
;;;3004   }
000974  4770              BX       lr
;;;3005   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;3023   *******************************************************************************/
;;;3024   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
000976  43c9              MVNS     r1,r1
;;;3025   {
;;;3026     /* Check the parameters */
;;;3027     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3028     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;3029   
;;;3030     /* Clear the IT pending Bit */
;;;3031     TIMx->SR = (u16)~TIM_IT;
000978  8201              STRH     r1,[r0,#0x10]
;;;3032   }
00097a  4770              BX       lr
;;;3033   
                          ENDP

