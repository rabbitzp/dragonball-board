; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\guialloc.o --depend=.\rvmdk\guialloc.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\guialloc.crf ..\..\..\..\..\uCGUI\GUI\Core\GUIAlloc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _Size2LegalSize PROC
;;;132    */
;;;133    static GUI_ALLOC_DATATYPE _Size2LegalSize(GUI_ALLOC_DATATYPE size) {
000000  1cc0              ADDS     r0,r0,#3
;;;134      return (size + ((1 << GUI_BLOCK_ALIGN) - 1)) & ~((1 << GUI_BLOCK_ALIGN) - 1);
000002  f0200003          BIC      r0,r0,#3
000006  b200              SXTH     r0,r0
;;;135    }
000008  4770              BX       lr
;;;136      
                          ENDP

                  _GetSize PROC
;;;140    */
;;;141    static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
00000a  49e0              LDR      r1,|L1.908|
;;;142      return aBlock[hMem].Size;
00000c  eb0100c0          ADD      r0,r1,r0,LSL #3
000010  f9b00002          LDRSH    r0,[r0,#2]
;;;143    }
000014  4770              BX       lr
;;;144    
                          ENDP

                  _Free PROC
;;;148    */
;;;149    static void _Free(GUI_HMEM hMem) {
000016  b410              PUSH     {r4}
;;;150      GUI_ALLOC_DATATYPE Size;
;;;151      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;152      /* Do some error checking ... */
;;;153      #if GUI_DEBUG_LEVEL>0
;;;154        /* Block not allocated ? */
;;;155        if (aBlock[hMem].Size == 0) {
000018  f8dfc370          LDR      r12,|L1.908|
00001c  eb0c01c0          ADD      r1,r12,r0,LSL #3
000020  f9b12002          LDRSH    r2,[r1,#2]
000024  2a00              CMP      r2,#0
000026  d01d              BEQ      |L1.100|
;;;156          GUI_DEBUG_ERROROUT("GUI_ALLOC_Free(): Invalid hMem");
;;;157          return;
;;;158        }
;;;159      #endif
;;;160      Size = aBlock[hMem].Size;
;;;161      #ifdef WIN32
;;;162        GUI_MEMSET(&GUI_Heap.abHeap[aBlock[hMem].Off], 0xcc, Size);
;;;163      #endif
;;;164      GUI_ALLOC.NumFreeBytes += Size;
000028  f50c6344          ADD      r3,r12,#0xc40
00002c  89dc              LDRH     r4,[r3,#0xe]  ; GUI_ALLOC
00002e  4414              ADD      r4,r4,r2
000030  81dc              STRH     r4,[r3,#0xe]
;;;165      GUI_ALLOC.NumUsedBytes -= Size;
000032  899c              LDRH     r4,[r3,#0xc]  ; GUI_ALLOC
000034  1aa2              SUBS     r2,r4,r2
000036  819a              STRH     r2,[r3,#0xc]
;;;166      aBlock[hMem].Size = 0;
000038  2200              MOVS     r2,#0
00003a  804a              STRH     r2,[r1,#2]
;;;167      if (_FirstFreeHandle > hMem) {
00003c  4ad4              LDR      r2,|L1.912|
00003e  6854              LDR      r4,[r2,#4]  ; _FirstFreeHandle
000040  4284              CMP      r4,r0
000042  dd00              BLE      |L1.70|
;;;168        _FirstFreeHandle = hMem;
000044  6050              STR      r0,[r2,#4]  ; _FirstFreeHandle
                  |L1.70|
;;;169      }
;;;170      {
;;;171        int Next = aBlock[hMem].Next;
000046  8888              LDRH     r0,[r1,#4]
;;;172        int Prev = aBlock[hMem].Prev;
000048  88c9              LDRH     r1,[r1,#6]
;;;173        aBlock[Prev].Next = Next;
00004a  eb0c02c1          ADD      r2,r12,r1,LSL #3
00004e  8090              STRH     r0,[r2,#4]
;;;174        if (Next) {
000050  b110              CBZ      r0,|L1.88|
;;;175          aBlock[Next].Prev = Prev;
000052  eb0c00c0          ADD      r0,r12,r0,LSL #3
000056  80c1              STRH     r1,[r0,#6]
                  |L1.88|
;;;176        }
;;;177      }  
;;;178      GUI_ALLOC.NumFreeBlocks++;
000058  6858              LDR      r0,[r3,#4]  ; GUI_ALLOC
00005a  1c40              ADDS     r0,r0,#1
00005c  6058              STR      r0,[r3,#4]  ; GUI_ALLOC
;;;179      GUI_ALLOC.NumUsedBlocks--;
00005e  6818              LDR      r0,[r3,#0]  ; GUI_ALLOC
000060  1e40              SUBS     r0,r0,#1
000062  6018              STR      r0,[r3,#0]  ; GUI_ALLOC
                  |L1.100|
;;;180    }
000064  bc10              POP      {r4}
000066  4770              BX       lr
;;;181    
                          ENDP

                  _FindFreeHandle PROC
;;;188    */
;;;189    static GUI_HMEM _FindFreeHandle(void) {
000068  4bc9              LDR      r3,|L1.912|
;;;190      int i;
;;;191      for (i = _FirstFreeHandle; i < GUI_MAXBLOCKS; i++) {
00006a  6858              LDR      r0,[r3,#4]  ; _FirstFreeHandle
00006c  f5b07fc4          CMP      r0,#0x188
000070  da08              BGE      |L1.132|
;;;192        if (aBlock[i].Size == 0) {
000072  49c6              LDR      r1,|L1.908|
                  |L1.116|
000074  eb0102c0          ADD      r2,r1,r0,LSL #3
000078  8852              LDRH     r2,[r2,#2]
00007a  b12a              CBZ      r2,|L1.136|
00007c  1c40              ADDS     r0,r0,#1              ;191
00007e  f5b07fc4          CMP      r0,#0x188             ;191
000082  dbf7              BLT      |L1.116|
                  |L1.132|
;;;193          _FirstFreeHandle = i;
;;;194          return i;
;;;195        }
;;;196      }
;;;197      GUI_DEBUG_ERROROUT1("Insufficient memory handles configured (GUI_MAXBLOCKS == %d (See GUIConf.h))", GUI_MAXBLOCKS);
;;;198      return GUI_HMEM_NULL;
000084  2000              MOVS     r0,#0
;;;199    }
000086  4770              BX       lr
                  |L1.136|
000088  6058              STR      r0,[r3,#4]            ;193  ; _FirstFreeHandle
00008a  b200              SXTH     r0,r0                 ;194
00008c  4770              BX       lr
;;;200    
                          ENDP

                  _FindHole PROC
;;;208    */
;;;209    static GUI_HMEM _FindHole(GUI_ALLOC_DATATYPE Size) {
00008e  b410              PUSH     {r4}
;;;210      int i, iNext;
;;;211      for (i=0; (iNext = aBlock[i].Next) != 0; i = iNext) {
000090  2100              MOVS     r1,#0
000092  f8dfc2f8          LDR      r12,|L1.908|
000096  f8bc2004          LDRH     r2,[r12,#4]
00009a  b1a2              CBZ      r2,|L1.198|
                  |L1.156|
;;;212        GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
00009c  eb0c04c1          ADD      r4,r12,r1,LSL #3
0000a0  f83c3031          LDRH     r3,[r12,r1,LSL #3]
0000a4  8864              LDRH     r4,[r4,#2]
0000a6  4423              ADD      r3,r3,r4
0000a8  f83c4032          LDRH     r4,[r12,r2,LSL #3]
0000ac  1ae3              SUBS     r3,r4,r3
0000ae  b21b              SXTH     r3,r3
;;;213        if (NumFreeBytes>=Size) {
0000b0  4283              CMP      r3,r0
0000b2  db02              BLT      |L1.186|
;;;214          return i;
;;;215        }
;;;216      }
;;;217      /* Check last block */
;;;218      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
;;;219        return i;
;;;220      }
;;;221      return -1;
;;;222    }
0000b4  bc10              POP      {r4}
0000b6  b208              SXTH     r0,r1                 ;214
0000b8  4770              BX       lr
                  |L1.186|
0000ba  4611              MOV      r1,r2                 ;211
0000bc  eb0c02c1          ADD      r2,r12,r1,LSL #3      ;211
0000c0  8892              LDRH     r2,[r2,#4]            ;211
0000c2  2a00              CMP      r2,#0                 ;211
0000c4  d1ea              BNE      |L1.156|
                  |L1.198|
0000c6  eb0c03c1          ADD      r3,r12,r1,LSL #3      ;218
0000ca  f93c2031          LDRSH    r2,[r12,r1,LSL #3]    ;218
0000ce  f9b33002          LDRSH    r3,[r3,#2]            ;218
0000d2  441a              ADD      r2,r2,r3              ;218
0000d4  f24303d4          MOV      r3,#0x30d4            ;218
0000d8  1a9a              SUBS     r2,r3,r2              ;218
0000da  4282              CMP      r2,r0                 ;218
0000dc  db02              BLT      |L1.228|
0000de  bc10              POP      {r4}
0000e0  b208              SXTH     r0,r1                 ;219
0000e2  4770              BX       lr
                  |L1.228|
0000e4  bc10              POP      {r4}
0000e6  f04f30ff          MOV      r0,#0xffffffff        ;221
0000ea  4770              BX       lr
;;;223    
                          ENDP

                  _CreateHole PROC
;;;231    */
;;;232    static GUI_HMEM _CreateHole(GUI_ALLOC_DATATYPE Size) {
0000ec  e92d47f0          PUSH     {r4-r10,lr}
0000f0  4607              MOV      r7,r0
;;;233      int i, iNext;
;;;234      int r = -1;
0000f2  f04f38ff          MOV      r8,#0xffffffff
;;;235      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
0000f6  2100              MOVS     r1,#0
0000f8  4ea4              LDR      r6,|L1.908|
0000fa  88b4              LDRH     r4,[r6,#4]
0000fc  b314              CBZ      r4,|L1.324|
;;;236        GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
;;;237        if (NumFreeBytes < Size) {
;;;238          GUI_ALLOC_DATATYPE NumBytesBeforeBlock = aBlock[iNext].Off - (aBlock[i].Off+aBlock[i].Size);
;;;239          if (NumBytesBeforeBlock) {
;;;240            U8* pData = &GUI_Heap.abHeap[aBlock[iNext].Off];
0000fe  f8df9294          LDR      r9,|L1.916|
                  |L1.258|
000102  f8360031          LDRH     r0,[r6,r1,LSL #3]     ;236
000106  eb0601c1          ADD      r1,r6,r1,LSL #3       ;236
00010a  8849              LDRH     r1,[r1,#2]            ;236
00010c  4401              ADD      r1,r1,r0              ;236
00010e  f9360034          LDRSH    r0,[r6,r4,LSL #3]     ;236
000112  1a41              SUBS     r1,r0,r1              ;236
000114  b20d              SXTH     r5,r1                 ;236
000116  42bd              CMP      r5,r7                 ;237
000118  da0e              BGE      |L1.312|
00011a  b16d              CBZ      r5,|L1.312|
00011c  eb000109          ADD      r1,r0,r9
;;;241            memmove(pData-NumBytesBeforeBlock, pData, aBlock[iNext].Size);
000120  eb0600c4          ADD      r0,r6,r4,LSL #3
000124  f9b02002          LDRSH    r2,[r0,#2]
000128  1b48              SUBS     r0,r1,r5
00012a  f7fffffe          BL       __aeabi_memmove
;;;242            aBlock[iNext].Off -=NumBytesBeforeBlock;
00012e  f8360034          LDRH     r0,[r6,r4,LSL #3]
000132  1b40              SUBS     r0,r0,r5
000134  f8260034          STRH     r0,[r6,r4,LSL #3]
                  |L1.312|
000138  4621              MOV      r1,r4                 ;235
00013a  eb0600c1          ADD      r0,r6,r1,LSL #3       ;235
00013e  8884              LDRH     r4,[r0,#4]            ;235
000140  2c00              CMP      r4,#0                 ;235
000142  d1de              BNE      |L1.258|
                  |L1.324|
;;;243          }
;;;244        }
;;;245      }
;;;246      /* Check last block */
;;;247      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
000144  eb0602c1          ADD      r2,r6,r1,LSL #3
000148  f9360031          LDRSH    r0,[r6,r1,LSL #3]
00014c  f9b22002          LDRSH    r2,[r2,#2]
000150  4410              ADD      r0,r0,r2
000152  f24302d4          MOV      r2,#0x30d4
000156  1a10              SUBS     r0,r2,r0
000158  42b8              CMP      r0,r7
00015a  db00              BLT      |L1.350|
;;;248        r = i;
00015c  4688              MOV      r8,r1
                  |L1.350|
;;;249      }
;;;250      return r;
00015e  fa0ff088          SXTH     r0,r8
;;;251    }
000162  e8bd87f0          POP      {r4-r10,pc}
;;;252    
                          ENDP

                  GUI_ALLOC_Init PROC
;;;340    */
;;;341    void GUI_ALLOC_Init(void) {
000166  498c              LDR      r1,|L1.920|
;;;342      GUI_DEBUG_LOG("\nGUI_ALLOC_Init...");
;;;343      GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks = GUI_MAXBLOCKS-1;
000168  f2401087          MOV      r0,#0x187
00016c  6048              STR      r0,[r1,#4]  ; GUI_ALLOC
00016e  6088              STR      r0,[r1,#8]  ; GUI_ALLOC
;;;344      GUI_ALLOC.NumFreeBytesMin  = GUI_ALLOC.NumFreeBytes  = GUI_ALLOC_SIZE;
000170  f24300d4          MOV      r0,#0x30d4
000174  81c8              STRH     r0,[r1,#0xe]
000176  8208              STRH     r0,[r1,#0x10]
;;;345      GUI_ALLOC.NumUsedBlocks = 0;
000178  2000              MOVS     r0,#0
00017a  6008              STR      r0,[r1,#0]  ; GUI_ALLOC
;;;346      GUI_ALLOC.NumUsedBytes = 0;
00017c  8188              STRH     r0,[r1,#0xc]
;;;347      aBlock[0].Size = (1<<GUI_BLOCK_ALIGN);  /* occupy minimum for a block */
00017e  f5a16144          SUB      r1,r1,#0xc40
000182  2204              MOVS     r2,#4
000184  804a              STRH     r2,[r1,#2]
;;;348      aBlock[0].Off  = 0;
000186  8008              STRH     r0,[r1,#0]
;;;349      aBlock[0].Next = 0;
000188  8088              STRH     r0,[r1,#4]
;;;350      IsInitialized =1;
00018a  4981              LDR      r1,|L1.912|
00018c  2001              MOVS     r0,#1
00018e  7008              STRB     r0,[r1,#0]
;;;351    }
000190  4770              BX       lr
;;;352    
                          ENDP

                  _CheckInit PROC
;;;256    */
;;;257    static void _CheckInit(void) {
000192  487f              LDR      r0,|L1.912|
;;;258      if (!IsInitialized) {
000194  7800              LDRB     r0,[r0,#0]  ; IsInitialized
000196  2800              CMP      r0,#0
000198  d100              BNE      |L1.412|
;;;259        GUI_ALLOC_Init();
00019a  e7fe              B        GUI_ALLOC_Init
                  |L1.412|
;;;260      }
;;;261    }
00019c  4770              BX       lr
;;;262    
                          ENDP

                  GUI_ALLOC_GetMaxSize PROC
;;;431    */
;;;432    GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
00019e  b510              PUSH     {r4,lr}
;;;433      GUI_ALLOC_DATATYPE r = 0;
0001a0  2400              MOVS     r4,#0
;;;434      GUI_ALLOC_DATATYPE NumFreeBytes;
;;;435      int i, iNext;
;;;436    
;;;437      GUI_LOCK();
0001a2  f7fffffe          BL       GUI_Lock
;;;438      _CheckInit();
0001a6  f7fffffe          BL       _CheckInit
;;;439      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
0001aa  2100              MOVS     r1,#0
0001ac  4a77              LDR      r2,|L1.908|
0001ae  8890              LDRH     r0,[r2,#4]
0001b0  b190              CBZ      r0,|L1.472|
                  |L1.434|
;;;440        NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
0001b2  f8323031          LDRH     r3,[r2,r1,LSL #3]
0001b6  eb0201c1          ADD      r1,r2,r1,LSL #3
0001ba  8849              LDRH     r1,[r1,#2]
0001bc  4419              ADD      r1,r1,r3
0001be  f8323030          LDRH     r3,[r2,r0,LSL #3]
0001c2  1a59              SUBS     r1,r3,r1
0001c4  b209              SXTH     r1,r1
;;;441        if (NumFreeBytes > r) {
0001c6  42a1              CMP      r1,r4
0001c8  dd00              BLE      |L1.460|
;;;442          r = NumFreeBytes;
0001ca  460c              MOV      r4,r1
                  |L1.460|
0001cc  4601              MOV      r1,r0                 ;439
0001ce  eb0200c1          ADD      r0,r2,r1,LSL #3       ;439
0001d2  8880              LDRH     r0,[r0,#4]            ;439
0001d4  2800              CMP      r0,#0                 ;439
0001d6  d1ec              BNE      |L1.434|
                  |L1.472|
;;;443        }
;;;444      }
;;;445      /* Check last block */
;;;446      NumFreeBytes = (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size));
0001d8  f8320031          LDRH     r0,[r2,r1,LSL #3]
0001dc  eb0201c1          ADD      r1,r2,r1,LSL #3
0001e0  8849              LDRH     r1,[r1,#2]
0001e2  4408              ADD      r0,r0,r1
0001e4  f24301d4          MOV      r1,#0x30d4
0001e8  1a08              SUBS     r0,r1,r0
0001ea  b200              SXTH     r0,r0
;;;447      if (NumFreeBytes > r) {
0001ec  42a0              CMP      r0,r4
0001ee  dd00              BLE      |L1.498|
;;;448        r = NumFreeBytes;
0001f0  4604              MOV      r4,r0
                  |L1.498|
;;;449      }
;;;450      GUI_UNLOCK();
0001f2  f7fffffe          BL       GUI_Unlock
;;;451      return r;
0001f6  4620              MOV      r0,r4
;;;452    }
0001f8  bd10              POP      {r4,pc}
;;;453    
                          ENDP

                  _GetNumFreeBytes PROC
;;;266    */
;;;267    static GUI_ALLOC_DATATYPE _GetNumFreeBytes(void) {
0001fa  4865              LDR      r0,|L1.912|
;;;268      if (_LockCnt) {
0001fc  6880              LDR      r0,[r0,#8]  ; _LockCnt
0001fe  b100              CBZ      r0,|L1.514|
;;;269        return GUI_ALLOC_GetMaxSize();
000200  e7fe              B        GUI_ALLOC_GetMaxSize
                  |L1.514|
;;;270      } else {
;;;271        return GUI_ALLOC.NumFreeBytes;  
000202  4865              LDR      r0,|L1.920|
000204  f9b0000e          LDRSH    r0,[r0,#0xe]  ; GUI_ALLOC
;;;272      }
;;;273    }
000208  4770              BX       lr
;;;274    
                          ENDP

                  _Alloc PROC
;;;278    */
;;;279    static GUI_HMEM _Alloc(GUI_ALLOC_DATATYPE size) {
00020a  b570              PUSH     {r4-r6,lr}
00020c  4604              MOV      r4,r0
;;;280      GUI_HMEM hMemNew, hMemIns;
;;;281      _CheckInit();
00020e  f7fffffe          BL       _CheckInit
;;;282      size = _Size2LegalSize(size);
000212  4620              MOV      r0,r4
000214  f7fffffe          BL       _Size2LegalSize
000218  4605              MOV      r5,r0
;;;283      /* Check if memory is available at all ...*/
;;;284      if (size > _GetNumFreeBytes()) {
00021a  f7fffffe          BL       _GetNumFreeBytes
00021e  42a8              CMP      r0,r5
000220  da01              BGE      |L1.550|
;;;285        GUI_DEBUG_WARN1("GUI_ALLOC_Alloc: Insufficient memory configured (Trying to alloc % bytes)", size);
;;;286        return 0;
000222  2000              MOVS     r0,#0
;;;287      }
;;;288      /* Locate free handle */
;;;289      if ((hMemNew = _FindFreeHandle()) == 0) {
;;;290        return 0;
;;;291      }
;;;292      /* Locate or Create hole of sufficient size */
;;;293      hMemIns = _FindHole(size);
;;;294      #if GUI_ALLOC_AUTDEFRAG
;;;295        if (hMemIns == -1) {
;;;296          if (_LockCnt == 0) {
;;;297            hMemIns = _CreateHole(size);
;;;298          }
;;;299        }
;;;300      #endif
;;;301      /* Occupy hole */
;;;302      if (hMemIns==-1) {
;;;303        GUI_DEBUG_ERROROUT1("GUI_ALLOC_Alloc: Could not allocate %d bytes",size);
;;;304        return 0;
;;;305    	}
;;;306      {
;;;307        GUI_ALLOC_DATATYPE Off = aBlock[hMemIns].Off + aBlock[hMemIns].Size;
;;;308        int Next = aBlock[hMemIns].Next;
;;;309        aBlock[hMemNew].Size  = size;
;;;310        aBlock[hMemNew].Off   = Off;
;;;311        if ((aBlock[hMemNew].Next  = Next) >0) {
;;;312          aBlock[Next].Prev = hMemNew;  
;;;313        }
;;;314        aBlock[hMemNew].Prev  = hMemIns;
;;;315        aBlock[hMemIns].Next  = hMemNew;
;;;316      }
;;;317      /* Keep track of number of blocks and av. memory */
;;;318      GUI_ALLOC.NumUsedBlocks++;
;;;319      GUI_ALLOC.NumFreeBlocks--;
;;;320      if (GUI_ALLOC.NumFreeBlocksMin > GUI_ALLOC.NumFreeBlocks) {
;;;321        GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks;
;;;322      }
;;;323      GUI_ALLOC.NumUsedBytes += size;
;;;324      GUI_ALLOC.NumFreeBytes -= size;
;;;325      if (GUI_ALLOC.NumFreeBytesMin > GUI_ALLOC.NumFreeBytes) {
;;;326        GUI_ALLOC.NumFreeBytesMin = GUI_ALLOC.NumFreeBytes;
;;;327      }
;;;328      return hMemNew;
;;;329    }
000224  bd70              POP      {r4-r6,pc}
                  |L1.550|
000226  f7fffffe          BL       _FindFreeHandle
00022a  0004              MOVS     r4,r0                 ;289
00022c  d005              BEQ      |L1.570|
00022e  4628              MOV      r0,r5                 ;293
000230  f7fffffe          BL       _FindHole
000234  1c41              ADDS     r1,r0,#1              ;295
000236  d002              BEQ      |L1.574|
000238  e007              B        |L1.586|
                  |L1.570|
00023a  2000              MOVS     r0,#0                 ;290
00023c  bd70              POP      {r4-r6,pc}
                  |L1.574|
00023e  4954              LDR      r1,|L1.912|
000240  6889              LDR      r1,[r1,#8]            ;296  ; _LockCnt
000242  b911              CBNZ     r1,|L1.586|
000244  4628              MOV      r0,r5                 ;297
000246  f7fffffe          BL       _CreateHole
                  |L1.586|
00024a  1c41              ADDS     r1,r0,#1              ;302
00024c  d02d              BEQ      |L1.682|
00024e  f8dfc13c          LDR      r12,|L1.908|
000252  eb0c01c0          ADD      r1,r12,r0,LSL #3      ;307
000256  f83c2030          LDRH     r2,[r12,r0,LSL #3]    ;307
00025a  884b              LDRH     r3,[r1,#2]            ;307
00025c  18d6              ADDS     r6,r2,r3              ;307
00025e  888b              LDRH     r3,[r1,#4]            ;308
000260  eb0c02c4          ADD      r2,r12,r4,LSL #3      ;309
000264  8055              STRH     r5,[r2,#2]            ;309
000266  f82c6034          STRH     r6,[r12,r4,LSL #3]    ;310
00026a  8093              STRH     r3,[r2,#4]            ;311
00026c  b113              CBZ      r3,|L1.628|
00026e  eb0c03c3          ADD      r3,r12,r3,LSL #3      ;312
000272  80dc              STRH     r4,[r3,#6]            ;312
                  |L1.628|
000274  80d0              STRH     r0,[r2,#6]            ;314
000276  808c              STRH     r4,[r1,#4]            ;315
000278  4947              LDR      r1,|L1.920|
00027a  6808              LDR      r0,[r1,#0]            ;318  ; GUI_ALLOC
00027c  1c40              ADDS     r0,r0,#1              ;318
00027e  6008              STR      r0,[r1,#0]            ;318  ; GUI_ALLOC
000280  6848              LDR      r0,[r1,#4]            ;319  ; GUI_ALLOC
000282  1e40              SUBS     r0,r0,#1              ;319
000284  6048              STR      r0,[r1,#4]            ;319  ; GUI_ALLOC
000286  688a              LDR      r2,[r1,#8]            ;320  ; GUI_ALLOC
000288  4282              CMP      r2,r0                 ;320
00028a  dd00              BLE      |L1.654|
00028c  6088              STR      r0,[r1,#8]            ;321  ; GUI_ALLOC
                  |L1.654|
00028e  8988              LDRH     r0,[r1,#0xc]          ;323  ; GUI_ALLOC
000290  4428              ADD      r0,r0,r5              ;323
000292  8188              STRH     r0,[r1,#0xc]          ;323
000294  89c8              LDRH     r0,[r1,#0xe]          ;324  ; GUI_ALLOC
000296  1b40              SUBS     r0,r0,r5              ;324
000298  b200              SXTH     r0,r0                 ;324
00029a  81c8              STRH     r0,[r1,#0xe]          ;324
00029c  f9b12010          LDRSH    r2,[r1,#0x10]         ;325  ; GUI_ALLOC
0002a0  4282              CMP      r2,r0                 ;325
0002a2  dd00              BLE      |L1.678|
0002a4  8208              STRH     r0,[r1,#0x10]         ;326
                  |L1.678|
0002a6  4620              MOV      r0,r4                 ;328
0002a8  bd70              POP      {r4-r6,pc}
                  |L1.682|
0002aa  2000              MOVS     r0,#0                 ;304
0002ac  bd70              POP      {r4-r6,pc}
;;;330    
                          ENDP

                  GUI_ALLOC_AllocNoInit PROC
;;;356    */
;;;357    GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
0002ae  b510              PUSH     {r4,lr}
0002b0  4604              MOV      r4,r0
;;;358      GUI_HMEM hMem;
;;;359      if (Size == 0) {
0002b2  b14c              CBZ      r4,|L1.712|
;;;360        return (GUI_HMEM)0;
;;;361      }
;;;362      GUI_LOCK();
0002b4  f7fffffe          BL       GUI_Lock
;;;363      GUI_DEBUG_LOG2("\nGUI_ALLOC_AllocNoInit... requesting %d, %d avail", Size, GUI_ALLOC.NumFreeBytes);
;;;364      hMem = _Alloc(Size);
0002b8  4620              MOV      r0,r4
0002ba  f7fffffe          BL       _Alloc
0002be  4604              MOV      r4,r0
;;;365      GUI_DEBUG_LOG1("\nGUI_ALLOC_AllocNoInit : Handle", hMem);
;;;366      GUI_UNLOCK();
0002c0  f7fffffe          BL       GUI_Unlock
;;;367      return hMem;
0002c4  4620              MOV      r0,r4
;;;368    }
0002c6  bd10              POP      {r4,pc}
                  |L1.712|
0002c8  2000              MOVS     r0,#0                 ;360
0002ca  bd10              POP      {r4,pc}
;;;369    
                          ENDP

                  GUI_ALLOC_h2p PROC
;;;373    */
;;;374    void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
0002cc  b128              CBZ      r0,|L1.730|
;;;375      GUI_ASSERT_LOCK();
;;;376      #if GUI_DEBUG_LEVEL > 0
;;;377        if (!hMem) {
;;;378          GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
;;;379          return 0;
;;;380        }
;;;381        if (aBlock[hMem].Size == 0) {
;;;382          GUI_DEBUG_ERROROUT("Dereferencing free block");
;;;383        }
;;;384    
;;;385      #endif
;;;386      return HMEM2PTR(hMem);
0002ce  492f              LDR      r1,|L1.908|
0002d0  f9310030          LDRSH    r0,[r1,r0,LSL #3]
0002d4  492f              LDR      r1,|L1.916|
0002d6  4408              ADD      r0,r0,r1
;;;387    }
0002d8  4770              BX       lr
                  |L1.730|
0002da  2000              MOVS     r0,#0                 ;379
0002dc  4770              BX       lr
;;;388    
                          ENDP

                  GUI_ALLOC_GetNumFreeBytes PROC
;;;392    */
;;;393    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes(void) {
0002de  b510              PUSH     {r4,lr}
;;;394      _CheckInit();
0002e0  f7fffffe          BL       _CheckInit
;;;395      return GUI_ALLOC.NumFreeBytes;
0002e4  482c              LDR      r0,|L1.920|
0002e6  f9b0000e          LDRSH    r0,[r0,#0xe]  ; GUI_ALLOC
;;;396    }
0002ea  bd10              POP      {r4,pc}
;;;397    
                          ENDP

                  GUI_ALLOC_GetNumFreeBlocks PROC
;;;401    */
;;;402    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void) {
0002ec  b510              PUSH     {r4,lr}
;;;403      _CheckInit();
0002ee  f7fffffe          BL       _CheckInit
;;;404      return GUI_ALLOC.NumFreeBlocks;
0002f2  4829              LDR      r0,|L1.920|
0002f4  6840              LDR      r0,[r0,#4]  ; GUI_ALLOC
0002f6  b200              SXTH     r0,r0
;;;405    }
0002f8  bd10              POP      {r4,pc}
;;;406    
                          ENDP

                  GUI_ALLOC_GetNumUsedBytes PROC
;;;410    */
;;;411    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes(void) {
0002fa  b510              PUSH     {r4,lr}
;;;412      _CheckInit();
0002fc  f7fffffe          BL       _CheckInit
;;;413      return GUI_ALLOC.NumUsedBytes;
000300  4825              LDR      r0,|L1.920|
000302  f9b0000c          LDRSH    r0,[r0,#0xc]  ; GUI_ALLOC
;;;414    }
000306  bd10              POP      {r4,pc}
;;;415    
                          ENDP

                  GUI_ALLOC_GetNumUsedBlocks PROC
;;;419    */
;;;420    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void) {
000308  b510              PUSH     {r4,lr}
;;;421      _CheckInit();
00030a  f7fffffe          BL       _CheckInit
;;;422      return GUI_ALLOC.NumUsedBlocks;
00030e  4822              LDR      r0,|L1.920|
000310  6800              LDR      r0,[r0,#0]  ; GUI_ALLOC
000312  b200              SXTH     r0,r0
;;;423    }
000314  bd10              POP      {r4,pc}
;;;424    
                          ENDP

                  GUI_ALLOC_Lock PROC
;;;461    */
;;;462    void GUI_ALLOC_Lock(void) {
000316  481e              LDR      r0,|L1.912|
;;;463      _LockCnt++;
000318  6881              LDR      r1,[r0,#8]  ; _LockCnt
00031a  1c49              ADDS     r1,r1,#1
00031c  6081              STR      r1,[r0,#8]  ; _LockCnt
;;;464    }
00031e  4770              BX       lr
;;;465    
                          ENDP

                  GUI_ALLOC_Unlock PROC
;;;473    */
;;;474    void GUI_ALLOC_Unlock(void) {
000320  481b              LDR      r0,|L1.912|
;;;475      _LockCnt--;
000322  6881              LDR      r1,[r0,#8]  ; _LockCnt
000324  1e49              SUBS     r1,r1,#1
000326  6081              STR      r1,[r0,#8]  ; _LockCnt
;;;476    }
000328  4770              BX       lr
;;;477    
                          ENDP

                  GUI_ALLOC_GetSize PROC
;;;594    */
;;;595    GUI_ALLOC_DATATYPE GUI_ALLOC_GetSize(GUI_HMEM  hMem) {
00032a  4601              MOV      r1,r0
;;;596      GUI_ALLOC_DATATYPE r;
;;;597    
;;;598      r = 0;
00032c  2000              MOVS     r0,#0
;;;599      if (hMem) {
00032e  2900              CMP      r1,#0
000330  d001              BEQ      |L1.822|
;;;600        r = _GetSize(hMem);
000332  4608              MOV      r0,r1
000334  e7fe              B        _GetSize
                  |L1.822|
;;;601      }
;;;602      return r;
;;;603    }
000336  4770              BX       lr
;;;604    
                          ENDP

                  GUI_ALLOC_Free PROC
;;;608    */
;;;609    void GUI_ALLOC_Free(GUI_HMEM hMem) {
000338  b510              PUSH     {r4,lr}
00033a  4604              MOV      r4,r0
;;;610      if (hMem == GUI_HMEM_NULL) { /* Note: This is not an error, it is permitted */
00033c  2c00              CMP      r4,#0
00033e  d008              BEQ      |L1.850|
;;;611        return;
;;;612      }
;;;613      GUI_LOCK();
000340  f7fffffe          BL       GUI_Lock
;;;614      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;615      _Free(hMem);
000344  4620              MOV      r0,r4
000346  f7fffffe          BL       _Free
;;;616      GUI_UNLOCK();
00034a  e8bd4010          POP      {r4,lr}
00034e  f7ffbffe          B.W      GUI_Unlock
                  |L1.850|
;;;617    }
000352  bd10              POP      {r4,pc}
;;;618    
                          ENDP

                  GUI_ALLOC_FreePtr PROC
;;;623    */
;;;624    void GUI_ALLOC_FreePtr(GUI_HMEM *ph) {
000354  b510              PUSH     {r4,lr}
000356  4604              MOV      r4,r0
;;;625      GUI_LOCK();
000358  f7fffffe          BL       GUI_Lock
;;;626      GUI_ALLOC_Free(*ph);
00035c  f9b40000          LDRSH    r0,[r4,#0]
000360  f7fffffe          BL       GUI_ALLOC_Free
;;;627      *ph =0;
000364  2000              MOVS     r0,#0
000366  8020              STRH     r0,[r4,#0]
;;;628      GUI_UNLOCK();
000368  e8bd4010          POP      {r4,lr}
00036c  f7ffbffe          B.W      GUI_Unlock
;;;629    }
;;;630    
                          ENDP

                  GUI_ALLOC_FreePtrArray PROC
;;;634    */
;;;635    void GUI_ALLOC_FreePtrArray(GUI_HMEM * pArray, int NumElems) {
000370  b570              PUSH     {r4-r6,lr}
000372  4606              MOV      r6,r0
000374  460d              MOV      r5,r1
;;;636      int i;
;;;637      for (i = 0; i < NumElems; i++) {
000376  2400              MOVS     r4,#0
000378  2d00              CMP      r5,#0
00037a  dd06              BLE      |L1.906|
                  |L1.892|
;;;638        GUI_ALLOC_FreePtr(&pArray[i]);
00037c  eb060044          ADD      r0,r6,r4,LSL #1
000380  f7fffffe          BL       GUI_ALLOC_FreePtr
000384  1c64              ADDS     r4,r4,#1              ;637
000386  42ac              CMP      r4,r5                 ;637
000388  dbf8              BLT      |L1.892|
                  |L1.906|
;;;639      }
;;;640    }
00038a  bd70              POP      {r4-r6,pc}
;;;641    
                          ENDP

                  |L1.908|
                          DCD      ||.bss||+0x30d4
                  |L1.912|
                          DCD      ||.data||
                  |L1.916|
                          DCD      ||.bss||
                  |L1.920|
                          DCD      ||.bss||+0x3d14

                          AREA ||.bss||, DATA, NOINIT, ALIGN=6

                  GUI_Heap
                          %        12500
                  aBlock
                          %        3136
                  GUI_ALLOC
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  IsInitialized
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  _FirstFreeHandle
                          DCD      0x00000001
                  _LockCnt
                          DCD      0x00000000
