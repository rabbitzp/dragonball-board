; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\stm32f10x_rcc.o --depend=.\rvmdk\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\stm32f10x_rcc.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;126    *******************************************************************************/
;;;127    void RCC_DeInit(void)
000000  48b6              LDR      r0,|L1.732|
;;;128    {
;;;129      /* Set HSION bit */
;;;130      RCC->CR |= (u32)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;131    
;;;132      /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
;;;133      RCC->CFGR &= (u32)0xF8FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4ab4              LDR      r2,|L1.736|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;134      
;;;135      /* Reset HSEON, CSSON and PLLON bits */
;;;136      RCC->CR &= (u32)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  f4212110          BIC      r1,r1,#0x90000
000018  f0217180          BIC      r1,r1,#0x1000000
00001c  6001              STR      r1,[r0,#0]
;;;137    
;;;138      /* Reset HSEBYP bit */
;;;139      RCC->CR &= (u32)0xFFFBFFFF;
00001e  6801              LDR      r1,[r0,#0]
000020  f4212180          BIC      r1,r1,#0x40000
000024  6001              STR      r1,[r0,#0]
;;;140    
;;;141      /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
;;;142      RCC->CFGR &= (u32)0xFF80FFFF;
000026  6841              LDR      r1,[r0,#4]
000028  f42101fe          BIC      r1,r1,#0x7f0000
00002c  6041              STR      r1,[r0,#4]
;;;143    
;;;144      /* Disable all interrupts */
;;;145      RCC->CIR = 0x00000000;
00002e  2100              MOVS     r1,#0
000030  6081              STR      r1,[r0,#8]
;;;146    }
000032  4770              BX       lr
;;;147    
                          ENDP

                  RCC_HSEConfig PROC
;;;161    *******************************************************************************/
;;;162    void RCC_HSEConfig(u32 RCC_HSE)
000034  49a9              LDR      r1,|L1.732|
;;;163    {
;;;164      /* Check the parameters */
;;;165      assert_param(IS_RCC_HSE(RCC_HSE));
;;;166    
;;;167      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;168      /* Reset HSEON bit */
;;;169      RCC->CR &= CR_HSEON_Reset;
000036  680a              LDR      r2,[r1,#0]
000038  f4223280          BIC      r2,r2,#0x10000
00003c  600a              STR      r2,[r1,#0]
;;;170    
;;;171      /* Reset HSEBYP bit */
;;;172      RCC->CR &= CR_HSEBYP_Reset;
00003e  680a              LDR      r2,[r1,#0]
000040  f4222280          BIC      r2,r2,#0x40000
000044  600a              STR      r2,[r1,#0]
;;;173    
;;;174      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;175      switch(RCC_HSE)
000046  f5b03f80          CMP      r0,#0x10000
00004a  d007              BEQ      |L1.92|
00004c  f5b02f80          CMP      r0,#0x40000
000050  d103              BNE      |L1.90|
;;;176      {
;;;177        case RCC_HSE_ON:
;;;178          /* Set HSEON bit */
;;;179          RCC->CR |= CR_HSEON_Set;
;;;180          break;
;;;181          
;;;182        case RCC_HSE_Bypass:
;;;183          /* Set HSEBYP and HSEON bits */
;;;184          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000052  6808              LDR      r0,[r1,#0]
000054  f44020a0          ORR      r0,r0,#0x50000
000058  6008              STR      r0,[r1,#0]
                  |L1.90|
;;;185          break;            
;;;186          
;;;187        default:
;;;188          break;      
;;;189      }
;;;190    }
00005a  4770              BX       lr
                  |L1.92|
00005c  6808              LDR      r0,[r1,#0]            ;179
00005e  f4403080          ORR      r0,r0,#0x10000        ;179
000062  6008              STR      r0,[r1,#0]            ;179
000064  4770              BX       lr
;;;191    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;989    *******************************************************************************/
;;;990    FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)
000066  2200              MOVS     r2,#0
;;;991    {
;;;992      u32 tmp = 0;
;;;993      u32 statusreg = 0;
;;;994      FlagStatus bitstatus = RESET;
;;;995    
;;;996      /* Check the parameters */
;;;997      assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;998    
;;;999      /* Get the RCC register index */
;;;1000     tmp = RCC_FLAG >> 5;
000068  0941              LSRS     r1,r0,#5
;;;1001   
;;;1002     if (tmp == 1)               /* The flag to check is in CR register */
;;;1003     {
;;;1004       statusreg = RCC->CR;
00006a  4b9c              LDR      r3,|L1.732|
00006c  2901              CMP      r1,#1                 ;1002
00006e  d00c              BEQ      |L1.138|
;;;1005     }
;;;1006     else if (tmp == 2)          /* The flag to check is in BDCR register */
000070  2902              CMP      r1,#2
000072  d00c              BEQ      |L1.142|
;;;1007     {
;;;1008       statusreg = RCC->BDCR;
;;;1009     }
;;;1010     else                       /* The flag to check is in CSR register */
;;;1011     {
;;;1012       statusreg = RCC->CSR;
000074  6a59              LDR      r1,[r3,#0x24]
                  |L1.118|
;;;1013     }
;;;1014   
;;;1015     /* Get the flag position */
;;;1016     tmp = RCC_FLAG & FLAG_Mask;
000076  f000001f          AND      r0,r0,#0x1f
;;;1017   
;;;1018     if ((statusreg & ((u32)1 << tmp)) != (u32)RESET)
00007a  2301              MOVS     r3,#1
00007c  fa03f000          LSL      r0,r3,r0
000080  4208              TST      r0,r1
000082  d000              BEQ      |L1.134|
;;;1019     {
;;;1020       bitstatus = SET;
000084  2201              MOVS     r2,#1
                  |L1.134|
;;;1021     }
;;;1022     else
;;;1023     {
;;;1024       bitstatus = RESET;
;;;1025     }
;;;1026   
;;;1027     /* Return the flag status */
;;;1028     return bitstatus;
000086  4610              MOV      r0,r2
;;;1029   }
000088  4770              BX       lr
                  |L1.138|
00008a  6819              LDR      r1,[r3,#0]            ;1004
00008c  e7f3              B        |L1.118|
                  |L1.142|
00008e  6a19              LDR      r1,[r3,#0x20]         ;1008
000090  e7f1              B        |L1.118|
;;;1030   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;200    *******************************************************************************/
;;;201    ErrorStatus RCC_WaitForHSEStartUp(void)
000092  b530              PUSH     {r4,r5,lr}
;;;202    {
;;;203      ErrorStatus status = ERROR;
;;;204    
;;;205      /* Wait till HSE is ready and if Time out is reached exit */
;;;206      do
;;;207      {
;;;208        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
000094  4c93              LDR      r4,|L1.740|
;;;209        StartUpCounter++;  
;;;210      } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
000096  f24015ff          MOV      r5,#0x1ff
                  |L1.154|
00009a  2031              MOVS     r0,#0x31              ;208
00009c  f7fffffe          BL       RCC_GetFlagStatus
0000a0  7020              STRB     r0,[r4,#0]            ;208
0000a2  6860              LDR      r0,[r4,#4]            ;209  ; StartUpCounter
0000a4  1c40              ADDS     r0,r0,#1              ;209
0000a6  6060              STR      r0,[r4,#4]            ;209  ; StartUpCounter
0000a8  7820              LDRB     r0,[r4,#0]  ; HSEStatus
0000aa  b910              CBNZ     r0,|L1.178|
0000ac  6860              LDR      r0,[r4,#4]  ; StartUpCounter
0000ae  42a8              CMP      r0,r5
0000b0  d1f3              BNE      |L1.154|
                  |L1.178|
;;;211    
;;;212    
;;;213      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
0000b2  2031              MOVS     r0,#0x31
0000b4  f7fffffe          BL       RCC_GetFlagStatus
0000b8  b108              CBZ      r0,|L1.190|
;;;214      {
;;;215        status = SUCCESS;
0000ba  2001              MOVS     r0,#1
;;;216      }
;;;217      else
;;;218      {
;;;219        status = ERROR;
;;;220      }  
;;;221    
;;;222      return (status);
;;;223    }
0000bc  bd30              POP      {r4,r5,pc}
                  |L1.190|
0000be  2000              MOVS     r0,#0                 ;219
0000c0  bd30              POP      {r4,r5,pc}
;;;224    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;233    *******************************************************************************/
;;;234    void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue)
0000c2  4a86              LDR      r2,|L1.732|
;;;235    {
;;;236      u32 tmpreg = 0;
;;;237    
;;;238      /* Check the parameters */
;;;239      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;240    
;;;241      tmpreg = RCC->CR;
0000c4  6811              LDR      r1,[r2,#0]
;;;242    
;;;243      /* Clear HSITRIM[4:0] bits */
;;;244      tmpreg &= CR_HSITRIM_Mask;
0000c6  f02101f8          BIC      r1,r1,#0xf8
;;;245    
;;;246      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;247      tmpreg |= (u32)HSICalibrationValue << 3;
0000ca  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;248    
;;;249      /* Store the new value */
;;;250      RCC->CR = tmpreg;
0000ce  6010              STR      r0,[r2,#0]
;;;251    }
0000d0  4770              BX       lr
;;;252    
                          ENDP

                  RCC_HSICmd PROC
;;;262    *******************************************************************************/
;;;263    void RCC_HSICmd(FunctionalState NewState)
0000d2  4985              LDR      r1,|L1.744|
;;;264    {
;;;265      /* Check the parameters */
;;;266      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;267    
;;;268      *(vu32 *) CR_HSION_BB = (u32)NewState;
0000d4  6008              STR      r0,[r1,#0]
;;;269    }
0000d6  4770              BX       lr
;;;270    
                          ENDP

                  RCC_PLLConfig PROC
;;;287    *******************************************************************************/
;;;288    void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul)
0000d8  4b80              LDR      r3,|L1.732|
;;;289    {
;;;290      u32 tmpreg = 0;
;;;291    
;;;292      /* Check the parameters */
;;;293      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;294      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;295    
;;;296      tmpreg = RCC->CFGR;
0000da  685a              LDR      r2,[r3,#4]
;;;297    
;;;298      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;299      tmpreg &= CFGR_PLL_Mask;
0000dc  f422127c          BIC      r2,r2,#0x3f0000
;;;300    
;;;301      /* Set the PLL configuration bits */
;;;302      tmpreg |= RCC_PLLSource | RCC_PLLMul;
0000e0  4308              ORRS     r0,r0,r1
0000e2  4310              ORRS     r0,r0,r2
;;;303    
;;;304      /* Store the new value */
;;;305      RCC->CFGR = tmpreg;
0000e4  6058              STR      r0,[r3,#4]
;;;306    }
0000e6  4770              BX       lr
;;;307    
                          ENDP

                  RCC_PLLCmd PROC
;;;316    *******************************************************************************/
;;;317    void RCC_PLLCmd(FunctionalState NewState)
0000e8  497f              LDR      r1,|L1.744|
;;;318    {
;;;319      /* Check the parameters */
;;;320      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;321    
;;;322      *(vu32 *) CR_PLLON_BB = (u32)NewState;
0000ea  6608              STR      r0,[r1,#0x60]
;;;323    }
0000ec  4770              BX       lr
;;;324    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;335    *******************************************************************************/
;;;336    void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource)
0000ee  4a7b              LDR      r2,|L1.732|
;;;337    {
;;;338      u32 tmpreg = 0;
;;;339    
;;;340      /* Check the parameters */
;;;341      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;342    
;;;343      tmpreg = RCC->CFGR;
0000f0  6851              LDR      r1,[r2,#4]
;;;344    
;;;345      /* Clear SW[1:0] bits */
;;;346      tmpreg &= CFGR_SW_Mask;
0000f2  f0210103          BIC      r1,r1,#3
;;;347    
;;;348      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;349      tmpreg |= RCC_SYSCLKSource;
0000f6  4308              ORRS     r0,r0,r1
;;;350    
;;;351      /* Store the new value */
;;;352      RCC->CFGR = tmpreg;
0000f8  6050              STR      r0,[r2,#4]
;;;353    }
0000fa  4770              BX       lr
;;;354    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;365    *******************************************************************************/
;;;366    u8 RCC_GetSYSCLKSource(void)
0000fc  4877              LDR      r0,|L1.732|
;;;367    {
;;;368      return ((u8)(RCC->CFGR & CFGR_SWS_Mask));
0000fe  6840              LDR      r0,[r0,#4]
000100  f000000c          AND      r0,r0,#0xc
;;;369    }
000104  4770              BX       lr
;;;370    
                          ENDP

                  RCC_HCLKConfig PROC
;;;388    *******************************************************************************/
;;;389    void RCC_HCLKConfig(u32 RCC_SYSCLK)
000106  4a75              LDR      r2,|L1.732|
;;;390    {
;;;391      u32 tmpreg = 0;
;;;392    
;;;393      /* Check the parameters */
;;;394      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;395    
;;;396      tmpreg = RCC->CFGR;
000108  6851              LDR      r1,[r2,#4]
;;;397    
;;;398      /* Clear HPRE[3:0] bits */
;;;399      tmpreg &= CFGR_HPRE_Reset_Mask;
00010a  f02101f0          BIC      r1,r1,#0xf0
;;;400    
;;;401      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;402      tmpreg |= RCC_SYSCLK;
00010e  4308              ORRS     r0,r0,r1
;;;403    
;;;404      /* Store the new value */
;;;405      RCC->CFGR = tmpreg;
000110  6050              STR      r0,[r2,#4]
;;;406    }
000112  4770              BX       lr
;;;407    
                          ENDP

                  RCC_PCLK1Config PROC
;;;421    *******************************************************************************/
;;;422    void RCC_PCLK1Config(u32 RCC_HCLK)
000114  4a71              LDR      r2,|L1.732|
;;;423    {
;;;424      u32 tmpreg = 0;
;;;425    
;;;426      /* Check the parameters */
;;;427      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;428    
;;;429      tmpreg = RCC->CFGR;
000116  6851              LDR      r1,[r2,#4]
;;;430    
;;;431      /* Clear PPRE1[2:0] bits */
;;;432      tmpreg &= CFGR_PPRE1_Reset_Mask;
000118  f42161e0          BIC      r1,r1,#0x700
;;;433    
;;;434      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;435      tmpreg |= RCC_HCLK;
00011c  4308              ORRS     r0,r0,r1
;;;436    
;;;437      /* Store the new value */
;;;438      RCC->CFGR = tmpreg;
00011e  6050              STR      r0,[r2,#4]
;;;439    }
000120  4770              BX       lr
;;;440    
                          ENDP

                  RCC_PCLK2Config PROC
;;;454    *******************************************************************************/
;;;455    void RCC_PCLK2Config(u32 RCC_HCLK)
000122  4a6e              LDR      r2,|L1.732|
;;;456    {
;;;457      u32 tmpreg = 0;
;;;458    
;;;459      /* Check the parameters */
;;;460      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;461    
;;;462      tmpreg = RCC->CFGR;
000124  6851              LDR      r1,[r2,#4]
;;;463    
;;;464      /* Clear PPRE2[2:0] bits */
;;;465      tmpreg &= CFGR_PPRE2_Reset_Mask;
000126  f4215160          BIC      r1,r1,#0x3800
;;;466    
;;;467      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;468      tmpreg |= RCC_HCLK << 3;
00012a  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;469    
;;;470      /* Store the new value */
;;;471      RCC->CFGR = tmpreg;
00012e  6050              STR      r0,[r2,#4]
;;;472    }
000130  4770              BX       lr
;;;473    
                          ENDP

                  RCC_ITConfig PROC
;;;489    *******************************************************************************/
;;;490    void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState)
000132  4a6a              LDR      r2,|L1.732|
;;;491    {
;;;492      /* Check the parameters */
;;;493      assert_param(IS_RCC_IT(RCC_IT));
;;;494      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;495    
;;;496      if (NewState != DISABLE)
000134  b119              CBZ      r1,|L1.318|
;;;497      {
;;;498        /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
;;;499        *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
000136  7a51              LDRB     r1,[r2,#9]
000138  4308              ORRS     r0,r0,r1
00013a  7250              STRB     r0,[r2,#9]
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
;;;504        *(vu8 *) CIR_BYTE2_ADDRESS &= (u8)~RCC_IT;
;;;505      }
;;;506    }
00013c  4770              BX       lr
                  |L1.318|
00013e  7a51              LDRB     r1,[r2,#9]            ;504
000140  ea210000          BIC      r0,r1,r0              ;504
000144  7250              STRB     r0,[r2,#9]            ;504
000146  4770              BX       lr
;;;507    
                          ENDP

                  RCC_USBCLKConfig PROC
;;;520    *******************************************************************************/
;;;521    void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
000148  4968              LDR      r1,|L1.748|
;;;522    {
;;;523      /* Check the parameters */
;;;524      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;525    
;;;526      *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
00014a  6008              STR      r0,[r1,#0]
;;;527    }
00014c  4770              BX       lr
;;;528    
                          ENDP

                  RCC_ADCCLKConfig PROC
;;;541    *******************************************************************************/
;;;542    void RCC_ADCCLKConfig(u32 RCC_PCLK2)
00014e  4a63              LDR      r2,|L1.732|
;;;543    {
;;;544      u32 tmpreg = 0;
;;;545    
;;;546      /* Check the parameters */
;;;547      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;548    
;;;549      tmpreg = RCC->CFGR;
000150  6851              LDR      r1,[r2,#4]
;;;550    
;;;551      /* Clear ADCPRE[1:0] bits */
;;;552      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000152  f4214140          BIC      r1,r1,#0xc000
;;;553    
;;;554      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;555      tmpreg |= RCC_PCLK2;
000156  4308              ORRS     r0,r0,r1
;;;556    
;;;557      /* Store the new value */
;;;558      RCC->CFGR = tmpreg;
000158  6050              STR      r0,[r2,#4]
;;;559    }
00015a  4770              BX       lr
;;;560    
                          ENDP

                  RCC_LSEConfig PROC
;;;572    *******************************************************************************/
;;;573    void RCC_LSEConfig(u8 RCC_LSE)
00015c  495f              LDR      r1,|L1.732|
;;;574    {
;;;575      /* Check the parameters */
;;;576      assert_param(IS_RCC_LSE(RCC_LSE));
;;;577    
;;;578      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;579      /* Reset LSEON bit */
;;;580      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
00015e  2200              MOVS     r2,#0
000160  f8812020          STRB     r2,[r1,#0x20]
;;;581    
;;;582      /* Reset LSEBYP bit */
;;;583      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
000164  f8812020          STRB     r2,[r1,#0x20]
;;;584    
;;;585      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;586      switch(RCC_LSE)
000168  2801              CMP      r0,#1
00016a  d005              BEQ      |L1.376|
00016c  2804              CMP      r0,#4
00016e  d102              BNE      |L1.374|
;;;587      {
;;;588        case RCC_LSE_ON:
;;;589          /* Set LSEON bit */
;;;590          *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
;;;591          break;
;;;592          
;;;593        case RCC_LSE_Bypass:
;;;594          /* Set LSEBYP and LSEON bits */
;;;595          *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000170  2005              MOVS     r0,#5
000172  f8810020          STRB     r0,[r1,#0x20]
                  |L1.374|
;;;596          break;            
;;;597          
;;;598        default:
;;;599          break;      
;;;600      }
;;;601    }
000176  4770              BX       lr
                  |L1.376|
000178  2001              MOVS     r0,#1                 ;590
00017a  f8810020          STRB     r0,[r1,#0x20]         ;590
00017e  4770              BX       lr
;;;602    
                          ENDP

                  RCC_LSICmd PROC
;;;611    *******************************************************************************/
;;;612    void RCC_LSICmd(FunctionalState NewState)
000180  495b              LDR      r1,|L1.752|
;;;613    {
;;;614      /* Check the parameters */
;;;615      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;616    
;;;617      *(vu32 *) CSR_LSION_BB = (u32)NewState;
000182  6008              STR      r0,[r1,#0]
;;;618    }
000184  4770              BX       lr
;;;619    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;633    *******************************************************************************/
;;;634    void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource)
000186  4955              LDR      r1,|L1.732|
;;;635    {
;;;636      /* Check the parameters */
;;;637      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;638    
;;;639      /* Select the RTC clock source */
;;;640      RCC->BDCR |= RCC_RTCCLKSource;
000188  6a0a              LDR      r2,[r1,#0x20]
00018a  4310              ORRS     r0,r0,r2
00018c  6208              STR      r0,[r1,#0x20]
;;;641    }
00018e  4770              BX       lr
;;;642    
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;652    *******************************************************************************/
;;;653    void RCC_RTCCLKCmd(FunctionalState NewState)
000190  4958              LDR      r1,|L1.756|
;;;654    {
;;;655      /* Check the parameters */
;;;656      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;657    
;;;658      *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
000192  6008              STR      r0,[r1,#0]
;;;659    }
000194  4770              BX       lr
;;;660    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;668    *******************************************************************************/
;;;669    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000196  4a51              LDR      r2,|L1.732|
;;;670    {
;;;671      u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
;;;672    
;;;673      /* Get SYSCLK source -------------------------------------------------------*/
;;;674      tmp = RCC->CFGR & CFGR_SWS_Mask;
000198  6851              LDR      r1,[r2,#4]
00019a  f001010c          AND      r1,r1,#0xc
;;;675    
;;;676      switch (tmp)
;;;677      {
;;;678        case 0x00:  /* HSI used as system clock */
;;;679          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
00019e  4b56              LDR      r3,|L1.760|
0001a0  b361              CBZ      r1,|L1.508|
0001a2  2904              CMP      r1,#4                 ;676
0001a4  d02c              BEQ      |L1.512|
0001a6  2908              CMP      r1,#8                 ;676
0001a8  d02c              BEQ      |L1.516|
;;;680          break;
;;;681    
;;;682        case 0x04:  /* HSE used as system clock */
;;;683          RCC_Clocks->SYSCLK_Frequency = HSE_Value;
;;;684          break;
;;;685    
;;;686        case 0x08:  /* PLL used as system clock */
;;;687          /* Get PLL clock source and multiplication factor ----------------------*/
;;;688          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
;;;689          pllmull = ( pllmull >> 18) + 2;
;;;690    
;;;691          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
;;;692    
;;;693          if (pllsource == 0x00)
;;;694          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;695            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
;;;696          }
;;;697          else
;;;698          {/* HSE selected as PLL clock entry */
;;;699    
;;;700            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
;;;701            {/* HSE oscillator clock divided by 2 */
;;;702    
;;;703              RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
;;;704            }
;;;705            else
;;;706            {
;;;707              RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
;;;708            }
;;;709          }
;;;710          break;
;;;711    
;;;712        default:
;;;713          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
0001aa  6003              STR      r3,[r0,#0]
                  |L1.428|
;;;714          break;
;;;715      }
;;;716    
;;;717      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;718      /* Get HCLK prescaler */
;;;719      tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
0001ac  6851              LDR      r1,[r2,#4]
0001ae  f00101f0          AND      r1,r1,#0xf0
;;;720      tmp = tmp >> 4;
0001b2  0909              LSRS     r1,r1,#4
;;;721      presc = APBAHBPrescTable[tmp];
0001b4  f8dfc144          LDR      r12,|L1.764|
0001b8  f81c1001          LDRB     r1,[r12,r1]
;;;722    
;;;723      /* HCLK clock frequency */
;;;724      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
0001bc  6803              LDR      r3,[r0,#0]
0001be  fa23f101          LSR      r1,r3,r1
0001c2  6041              STR      r1,[r0,#4]
;;;725    
;;;726      /* Get PCLK1 prescaler */
;;;727      tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
0001c4  6853              LDR      r3,[r2,#4]
0001c6  f40363e0          AND      r3,r3,#0x700
;;;728      tmp = tmp >> 8;
0001ca  0a1b              LSRS     r3,r3,#8
;;;729      presc = APBAHBPrescTable[tmp];
0001cc  f81c3003          LDRB     r3,[r12,r3]
;;;730    
;;;731      /* PCLK1 clock frequency */
;;;732      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0001d0  fa21f303          LSR      r3,r1,r3
0001d4  6083              STR      r3,[r0,#8]
;;;733    
;;;734      /* Get PCLK2 prescaler */
;;;735      tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
0001d6  6853              LDR      r3,[r2,#4]
0001d8  f4035360          AND      r3,r3,#0x3800
;;;736      tmp = tmp >> 11;
0001dc  0adb              LSRS     r3,r3,#11
;;;737      presc = APBAHBPrescTable[tmp];
0001de  f81c3003          LDRB     r3,[r12,r3]
;;;738    
;;;739      /* PCLK2 clock frequency */
;;;740      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0001e2  40d9              LSRS     r1,r1,r3
0001e4  60c1              STR      r1,[r0,#0xc]
;;;741    
;;;742      /* Get ADCCLK prescaler */
;;;743      tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
0001e6  6852              LDR      r2,[r2,#4]
0001e8  f4024240          AND      r2,r2,#0xc000
;;;744      tmp = tmp >> 14;
0001ec  0b92              LSRS     r2,r2,#14
;;;745      presc = ADCPrescTable[tmp];
0001ee  f1ac0304          SUB      r3,r12,#4
0001f2  5c9a              LDRB     r2,[r3,r2]
;;;746    
;;;747      /* ADCCLK clock frequency */
;;;748      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
0001f4  fbb1f1f2          UDIV     r1,r1,r2
0001f8  6101              STR      r1,[r0,#0x10]
;;;749    }
0001fa  4770              BX       lr
                  |L1.508|
0001fc  6003              STR      r3,[r0,#0]            ;679
0001fe  e7d5              B        |L1.428|
                  |L1.512|
000200  6003              STR      r3,[r0,#0]            ;683
000202  e7d3              B        |L1.428|
                  |L1.516|
000204  6851              LDR      r1,[r2,#4]            ;688
000206  f4011170          AND      r1,r1,#0x3c0000       ;688
00020a  2302              MOVS     r3,#2                 ;689
00020c  eb034191          ADD      r1,r3,r1,LSR #18      ;689
000210  6853              LDR      r3,[r2,#4]            ;691
000212  f4033380          AND      r3,r3,#0x10000        ;691
000216  b13b              CBZ      r3,|L1.552|
000218  6853              LDR      r3,[r2,#4]            ;700
00021a  f4133f00          TST      r3,#0x20000           ;700
00021e  d007              BEQ      |L1.560|
000220  4b37              LDR      r3,|L1.768|
000222  4359              MULS     r1,r3,r1              ;703
000224  6001              STR      r1,[r0,#0]            ;703
000226  e7c1              B        |L1.428|
                  |L1.552|
000228  4b35              LDR      r3,|L1.768|
00022a  4359              MULS     r1,r3,r1              ;695
00022c  6001              STR      r1,[r0,#0]            ;695
00022e  e7bd              B        |L1.428|
                  |L1.560|
000230  4b31              LDR      r3,|L1.760|
000232  4359              MULS     r1,r3,r1              ;707
000234  6001              STR      r1,[r0,#0]            ;707
000236  e7b9              B        |L1.428|
;;;750    
                          ENDP

                  RCC_AHBPeriphClockCmd PROC
;;;768    *******************************************************************************/
;;;769    void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState)
000238  4a28              LDR      r2,|L1.732|
;;;770    {
;;;771      /* Check the parameters */
;;;772      assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;773      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;774    
;;;775      if (NewState != DISABLE)
00023a  b119              CBZ      r1,|L1.580|
;;;776      {
;;;777        RCC->AHBENR |= RCC_AHBPeriph;
00023c  6951              LDR      r1,[r2,#0x14]
00023e  4308              ORRS     r0,r0,r1
000240  6150              STR      r0,[r2,#0x14]
;;;778      }
;;;779      else
;;;780      {
;;;781        RCC->AHBENR &= ~RCC_AHBPeriph;
;;;782      }
;;;783    }
000242  4770              BX       lr
                  |L1.580|
000244  6951              LDR      r1,[r2,#0x14]         ;781
000246  ea210000          BIC      r0,r1,r0              ;781
00024a  6150              STR      r0,[r2,#0x14]         ;781
00024c  4770              BX       lr
;;;784    
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;801    *******************************************************************************/
;;;802    void RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState)
00024e  4a23              LDR      r2,|L1.732|
;;;803    {
;;;804      /* Check the parameters */
;;;805      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;806      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;807    
;;;808      if (NewState != DISABLE)
000250  b119              CBZ      r1,|L1.602|
;;;809      {
;;;810        RCC->APB2ENR |= RCC_APB2Periph;
000252  6991              LDR      r1,[r2,#0x18]
000254  4308              ORRS     r0,r0,r1
000256  6190              STR      r0,[r2,#0x18]
;;;811      }
;;;812      else
;;;813      {
;;;814        RCC->APB2ENR &= ~RCC_APB2Periph;
;;;815      }
;;;816    }
000258  4770              BX       lr
                  |L1.602|
00025a  6991              LDR      r1,[r2,#0x18]         ;814
00025c  ea210000          BIC      r0,r1,r0              ;814
000260  6190              STR      r0,[r2,#0x18]         ;814
000262  4770              BX       lr
;;;817    
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;835    *******************************************************************************/
;;;836    void RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState)
000264  4a1d              LDR      r2,|L1.732|
;;;837    {
;;;838      /* Check the parameters */
;;;839      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;840      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;841    
;;;842      if (NewState != DISABLE)
000266  b119              CBZ      r1,|L1.624|
;;;843      {
;;;844        RCC->APB1ENR |= RCC_APB1Periph;
000268  69d1              LDR      r1,[r2,#0x1c]
00026a  4308              ORRS     r0,r0,r1
00026c  61d0              STR      r0,[r2,#0x1c]
;;;845      }
;;;846      else
;;;847      {
;;;848        RCC->APB1ENR &= ~RCC_APB1Periph;
;;;849      }
;;;850    }
00026e  4770              BX       lr
                  |L1.624|
000270  69d1              LDR      r1,[r2,#0x1c]         ;848
000272  ea210000          BIC      r0,r1,r0              ;848
000276  61d0              STR      r0,[r2,#0x1c]         ;848
000278  4770              BX       lr
;;;851    
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;867    *******************************************************************************/
;;;868    void RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState)
00027a  4a18              LDR      r2,|L1.732|
;;;869    {
;;;870      /* Check the parameters */
;;;871      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;872      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;873    
;;;874      if (NewState != DISABLE)
00027c  b119              CBZ      r1,|L1.646|
;;;875      {
;;;876        RCC->APB2RSTR |= RCC_APB2Periph;
00027e  68d1              LDR      r1,[r2,#0xc]
000280  4308              ORRS     r0,r0,r1
000282  60d0              STR      r0,[r2,#0xc]
;;;877      }
;;;878      else
;;;879      {
;;;880        RCC->APB2RSTR &= ~RCC_APB2Periph;
;;;881      }
;;;882    }
000284  4770              BX       lr
                  |L1.646|
000286  68d1              LDR      r1,[r2,#0xc]          ;880
000288  ea210000          BIC      r0,r1,r0              ;880
00028c  60d0              STR      r0,[r2,#0xc]          ;880
00028e  4770              BX       lr
;;;883    
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;900    *******************************************************************************/
;;;901    void RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState)
000290  4a12              LDR      r2,|L1.732|
;;;902    {
;;;903      /* Check the parameters */
;;;904      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;905      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;906    
;;;907      if (NewState != DISABLE)
000292  b119              CBZ      r1,|L1.668|
;;;908      {
;;;909        RCC->APB1RSTR |= RCC_APB1Periph;
000294  6911              LDR      r1,[r2,#0x10]
000296  4308              ORRS     r0,r0,r1
000298  6110              STR      r0,[r2,#0x10]
;;;910      }
;;;911      else
;;;912      {
;;;913        RCC->APB1RSTR &= ~RCC_APB1Periph;
;;;914      }
;;;915    }
00029a  4770              BX       lr
                  |L1.668|
00029c  6911              LDR      r1,[r2,#0x10]         ;913
00029e  ea210000          BIC      r0,r1,r0              ;913
0002a2  6110              STR      r0,[r2,#0x10]         ;913
0002a4  4770              BX       lr
;;;916    
                          ENDP

                  RCC_BackupResetCmd PROC
;;;924    *******************************************************************************/
;;;925    void RCC_BackupResetCmd(FunctionalState NewState)
0002a6  4917              LDR      r1,|L1.772|
;;;926    {
;;;927      /* Check the parameters */
;;;928      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;929    
;;;930      *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
0002a8  6008              STR      r0,[r1,#0]
;;;931    }
0002aa  4770              BX       lr
;;;932    
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;940    *******************************************************************************/
;;;941    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
0002ac  490e              LDR      r1,|L1.744|
;;;942    {
;;;943      /* Check the parameters */
;;;944      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;945    
;;;946      *(vu32 *) CR_CSSON_BB = (u32)NewState;
0002ae  64c8              STR      r0,[r1,#0x4c]
;;;947    }
0002b0  4770              BX       lr
;;;948    
                          ENDP

                  RCC_MCOConfig PROC
;;;961    *******************************************************************************/
;;;962    void RCC_MCOConfig(u8 RCC_MCO)
0002b2  490a              LDR      r1,|L1.732|
;;;963    {
;;;964      /* Check the parameters */
;;;965      assert_param(IS_RCC_MCO(RCC_MCO));
;;;966    
;;;967      /* Perform Byte access to MCO[2:0] bits to select the MCO source */
;;;968      *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
0002b4  71c8              STRB     r0,[r1,#7]
;;;969    }
0002b6  4770              BX       lr
;;;970    
                          ENDP

                  RCC_ClearFlag PROC
;;;1040   *******************************************************************************/
;;;1041   void RCC_ClearFlag(void)
0002b8  4808              LDR      r0,|L1.732|
;;;1042   {
;;;1043     /* Set RMVF bit to clear the reset flags */
;;;1044     RCC->CSR |= CSR_RMVF_Set;
0002ba  6a41              LDR      r1,[r0,#0x24]
0002bc  f0417180          ORR      r1,r1,#0x1000000
0002c0  6241              STR      r1,[r0,#0x24]
;;;1045   }
0002c2  4770              BX       lr
;;;1046   
                          ENDP

                  RCC_GetITStatus PROC
;;;1060   *******************************************************************************/
;;;1061   ITStatus RCC_GetITStatus(u8 RCC_IT)
0002c4  4601              MOV      r1,r0
;;;1062   {
;;;1063     ITStatus bitstatus = RESET;
0002c6  2000              MOVS     r0,#0
;;;1064   
;;;1065     /* Check the parameters */
;;;1066     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1067   
;;;1068     /* Check the status of the specified RCC interrupt */
;;;1069     if ((RCC->CIR & RCC_IT) != (u32)RESET)
0002c8  4a04              LDR      r2,|L1.732|
0002ca  6892              LDR      r2,[r2,#8]
0002cc  420a              TST      r2,r1
0002ce  d000              BEQ      |L1.722|
;;;1070     {
;;;1071       bitstatus = SET;
0002d0  2001              MOVS     r0,#1
                  |L1.722|
;;;1072     }
;;;1073     else
;;;1074     {
;;;1075       bitstatus = RESET;
;;;1076     }
;;;1077   
;;;1078     /* Return the RCC_IT status */
;;;1079     return  bitstatus;
;;;1080   }
0002d2  4770              BX       lr
;;;1081   
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1095   *******************************************************************************/
;;;1096   void RCC_ClearITPendingBit(u8 RCC_IT)
0002d4  4901              LDR      r1,|L1.732|
;;;1097   {
;;;1098     /* Check the parameters */
;;;1099     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1100   
;;;1101     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1102        pending bits */
;;;1103     *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
0002d6  7288              STRB     r0,[r1,#0xa]
;;;1104   }
0002d8  4770              BX       lr
;;;1105   
                          ENDP

0002da  0000              DCW      0x0000
                  |L1.732|
                          DCD      0x40021000
                  |L1.736|
                          DCD      0xf8ff0000
                  |L1.740|
                          DCD      ||.data||
                  |L1.744|
                          DCD      0x42420000
                  |L1.748|
                          DCD      0x424200d8
                  |L1.752|
                          DCD      0x42420480
                  |L1.756|
                          DCD      0x4242043c
                  |L1.760|
                          DCD      0x007a1200
                  |L1.764|
                          DCD      ||.constdata||+0x4
                  |L1.768|
                          DCD      0x003d0900
                  |L1.772|
                          DCD      0x42420440

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ADCPrescTable
000000  02040608          DCB      0x02,0x04,0x06,0x08
                  APBAHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09

                          AREA ||.data||, DATA, ALIGN=2

                  HSEStatus
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  StartUpCounter
                          DCD      0x00000000
