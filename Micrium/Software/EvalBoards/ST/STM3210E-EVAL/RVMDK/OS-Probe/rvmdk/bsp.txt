; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\bsp.o --depend=.\rvmdk\bsp.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\bsp.crf ..\BSP\bsp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  _sys_exit PROC
;;;165    //定义_sys_exit()以避免使用半主机模式    
;;;166    _sys_exit(int x) 
000000  4770              BX       lr
;;;167    { 
;;;168    	x = x; 
;;;169    } 
;;;170    //重定义fputc函数 
                          ENDP

                  fputc PROC
;;;171    int fputc(int ch, FILE *f)
000002  b570              PUSH     {r4-r6,lr}
;;;172    {      
000004  4604              MOV      r4,r0
;;;173      USART_SendData(USART1, (u8) ch);
000006  b2e1              UXTB     r1,r4
000008  4dff              LDR      r5,|L1.1032|
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       USART_SendData
                  |L1.16|
;;;174    
;;;175      /* Loop until the end of transmission */
;;;176      while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET)
000010  2180              MOVS     r1,#0x80
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L1.16|
;;;177      {
;;;178      }
;;;179    
;;;180      return ch;
00001c  4620              MOV      r0,r4
;;;181    }
00001e  bd70              POP      {r4-r6,pc}
;;;182    #ifdef EN_USART1_RX   //如果使能了接收
                          ENDP

                  USART1_IRQHandler PROC
;;;201    ******************************************************************************/
;;;202    void USART1_IRQHandler(void)
000020  b510              PUSH     {r4,lr}
;;;203    {
;;;204    	u8 res;
;;;205    
;;;206    	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收到数据
000022  4cf9              LDR      r4,|L1.1032|
000024  f2405125          MOV      r1,#0x525
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       USART_GetITStatus
00002e  2800              CMP      r0,#0
000030  d01f              BEQ      |L1.114|
;;;207    	{
;;;208    		res = USART_ReceiveData(USART1);	//读取接收到的数据
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       USART_ReceiveData
000038  b2c4              UXTB     r4,r0
;;;209    		printf("%c", res);
00003a  4621              MOV      r1,r4
00003c  a0f3              ADR      r0,|L1.1036|
00003e  f7fffffe          BL       __2printf
;;;210    		
;;;211    		if((USART_RX_STA & 0x8000) == 0)//接收未完成
000042  49f3              LDR      r1,|L1.1040|
000044  8808              LDRH     r0,[r1,#0]  ; USART_RX_STA
000046  f4104f00          TST      r0,#0x8000
00004a  d112              BNE      |L1.114|
;;;212    		{
;;;213    			if(USART_RX_STA & 0x4000)//接收到了0x0d
;;;214    			{
;;;215    				/***********************************************
;;;216                                      修改内容如下
;;;217                        当用户数据当中有0x0d的时候修正的错误的判断
;;;218    				***********************************************/
;;;219    				
;;;220    				if(res != 0x0a)
;;;221    				{
;;;222    					USART_RX_BUF[USART_RX_STA & 0x3fff] = 0x0d;	//补上丢失的0x0d数据
00004c  4af1              LDR      r2,|L1.1044|
00004e  f4104f80          TST      r0,#0x4000            ;213
000052  d013              BEQ      |L1.124|
000054  2c0a              CMP      r4,#0xa               ;220
000056  d00d              BEQ      |L1.116|
000058  f3c00c0d          UBFX     r12,r0,#0,#14
00005c  230d              MOVS     r3,#0xd
00005e  f802300c          STRB     r3,[r2,r12]
;;;223    					USART_RX_STA++;
000062  1c40              ADDS     r0,r0,#1
;;;224    					USART_RX_BUF[USART_RX_STA & 0x3fff] = res;	//继续接收数据
000064  f3c0030d          UBFX     r3,r0,#0,#14
000068  54d4              STRB     r4,[r2,r3]
;;;225    					USART_RX_STA++;
00006a  1c40              ADDS     r0,r0,#1
;;;226    					USART_RX_STA &= 0xbfff;						//清除0x0d标志
00006c  f4204080          BIC      r0,r0,#0x4000
000070  8008              STRH     r0,[r1,#0]
                  |L1.114|
;;;227    				}
;;;228    				
;;;229    				/***********************************************
;;;230                                          修改完成
;;;231    				***********************************************/
;;;232    				
;;;233    				else	USART_RX_STA |= 0x8000;	//接收完成了
;;;234    			}
;;;235    			else //还没收到0x0d
;;;236    			{	
;;;237    				if(res == 0x0d)	USART_RX_STA |= 0x4000;
;;;238    				else
;;;239    				{
;;;240    					USART_RX_BUF[USART_RX_STA & 0x3fff] = res;
;;;241    					USART_RX_STA++;
;;;242    					if(USART_RX_STA > (USART_REC_LEN - 1))	USART_RX_STA = 0;//接收数据错误,重新开始接收	  
;;;243    				}		 
;;;244    			}
;;;245    		}	//end 接收未完成   		 
;;;246    	}	//end 接收到数据
;;;247    }
000072  bd10              POP      {r4,pc}
                  |L1.116|
000074  f4404000          ORR      r0,r0,#0x8000         ;233
000078  8008              STRH     r0,[r1,#0]            ;233
                  |L1.122|
00007a  bd10              POP      {r4,pc}
                  |L1.124|
00007c  2c0d              CMP      r4,#0xd               ;237
00007e  d00a              BEQ      |L1.150|
000080  f3c0030d          UBFX     r3,r0,#0,#14          ;240
000084  54d4              STRB     r4,[r2,r3]            ;240
000086  1c40              ADDS     r0,r0,#1              ;241
000088  b280              UXTH     r0,r0                 ;241
00008a  8008              STRH     r0,[r1,#0]            ;241
00008c  283e              CMP      r0,#0x3e              ;242
00008e  d9f4              BLS      |L1.122|
000090  2000              MOVS     r0,#0                 ;242
000092  8008              STRH     r0,[r1,#0]            ;242
000094  bd10              POP      {r4,pc}
                  |L1.150|
000096  f4404080          ORR      r0,r0,#0x4000         ;237
00009a  8008              STRH     r0,[r1,#0]            ;237
00009c  bd10              POP      {r4,pc}
;;;248    
                          ENDP

                  db_usart1_init PROC
;;;252    
;;;253    void db_usart1_init(u32 bound)
00009e  b570              PUSH     {r4-r6,lr}
;;;254    {
0000a0  b086              SUB      sp,sp,#0x18
0000a2  4604              MOV      r4,r0
;;;255    	GPIO_InitTypeDef GPIO_InitStructure;
;;;256    	USART_InitTypeDef USART_InitStructure;
;;;257    	 
;;;258    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟
0000a4  2101              MOVS     r1,#1
0000a6  f2440004          MOV      r0,#0x4004
0000aa  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;259    		
;;;260    	USART_DeInit(USART1);  //复位串口1
0000ae  4dd6              LDR      r5,|L1.1032|
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       USART_DeInit
;;;261    	
;;;262    	//USART1_TX   PA.9
;;;263    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
0000b6  1568              ASRS     r0,r5,#21
0000b8  f8ad0010          STRH     r0,[sp,#0x10]
;;;264    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000bc  2003              MOVS     r0,#3
0000be  f88d0012          STRB     r0,[sp,#0x12]
;;;265    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
0000c2  2018              MOVS     r0,#0x18
0000c4  f88d0013          STRB     r0,[sp,#0x13]
;;;266    	GPIO_Init(GPIOA, &GPIO_InitStructure); //初始化PA9
0000c8  4ed3              LDR      r6,|L1.1048|
0000ca  a904              ADD      r1,sp,#0x10
0000cc  4630              MOV      r0,r6
0000ce  f7fffffe          BL       GPIO_Init
;;;267       
;;;268    	//USART1_RX	  PA.10
;;;269    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
0000d2  1528              ASRS     r0,r5,#20
0000d4  f8ad0010          STRH     r0,[sp,#0x10]
;;;270    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
0000d8  2004              MOVS     r0,#4
0000da  f88d0013          STRB     r0,[sp,#0x13]
;;;271    	GPIO_Init(GPIOA, &GPIO_InitStructure);  //初始化PA10
0000de  a904              ADD      r1,sp,#0x10
0000e0  4630              MOV      r0,r6
0000e2  f7fffffe          BL       GPIO_Init
;;;272      
;;;273    	//USART 初始化设置
;;;274    	USART_InitStructure.USART_BaudRate = bound;	//设置波特率，一般设置为9600;
0000e6  9400              STR      r4,[sp,#0]
;;;275    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;	//字长为8位数据格式
0000e8  2000              MOVS     r0,#0
0000ea  f8ad0004          STRH     r0,[sp,#4]
;;;276    	USART_InitStructure.USART_StopBits = USART_StopBits_1;	//一个停止位
0000ee  f8ad0006          STRH     r0,[sp,#6]
;;;277    	USART_InitStructure.USART_Parity = USART_Parity_No;	//无奇偶校验位
0000f2  f8ad0008          STRH     r0,[sp,#8]
;;;278    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	//无硬件数据流控制
0000f6  f8ad000c          STRH     r0,[sp,#0xc]
;;;279    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
0000fa  200c              MOVS     r0,#0xc
0000fc  f8ad000a          STRH     r0,[sp,#0xa]
;;;280    	
;;;281    	USART_Init(USART1, &USART_InitStructure); //初始化串口
000100  4669              MOV      r1,sp
000102  4628              MOV      r0,r5
000104  f7fffffe          BL       USART_Init
;;;282    #ifdef EN_USART1_RX	//如果使能了接收中断
;;;283    		
;;;284    	USART1->CR1 |= 1 << 8;	//PE中断使能
000108  48c4              LDR      r0,|L1.1052|
00010a  8801              LDRH     r1,[r0,#0]
00010c  f4417180          ORR      r1,r1,#0x100
000110  8001              STRH     r1,[r0,#0]
;;;285    	USART1->CR1 |= 1 << 5;	//接收缓冲区非空中断使能
000112  8801              LDRH     r1,[r0,#0]
000114  f0410120          ORR      r1,r1,#0x20
000118  8001              STRH     r1,[r0,#0]
;;;286    
;;;287    	BSP_IntVectSet(BSP_INT_ID_USART1, USART1_IRQHandler);
00011a  f2af01fb          ADR      r1,USART1_IRQHandler + 1
00011e  f04f0025          MOV      r0,#0x25
000122  f7fffffe          BL       BSP_IntVectSet
;;;288    	BSP_IntPrioSet(BSP_INT_ID_USART1, 2);
000126  2102              MOVS     r1,#2
000128  2025              MOVS     r0,#0x25
00012a  f7fffffe          BL       BSP_IntPrioSet
;;;289    	BSP_IntEn(BSP_INT_ID_USART1);
00012e  2025              MOVS     r0,#0x25
000130  f7fffffe          BL       BSP_IntEn
;;;290    #endif
;;;291    	
;;;292    	USART_Cmd(USART1, ENABLE);                    //使能串口
000134  2101              MOVS     r1,#1
000136  4628              MOV      r0,r5
000138  f7fffffe          BL       USART_Cmd
;;;293    
;;;294    	printf("\n%s\n", __FUNCTION__);
00013c  49b8              LDR      r1,|L1.1056|
00013e  a0b9              ADR      r0,|L1.1060|
000140  f7fffffe          BL       __2printf
;;;295    	
;;;296    }
000144  b006              ADD      sp,sp,#0x18
000146  bd70              POP      {r4-r6,pc}
;;;297    
                          ENDP

                  BSP_Init PROC
;;;298    void  BSP_Init (void)
000148  b510              PUSH     {r4,lr}
;;;299    {
;;;300    	BSP_IntInit();
00014a  f7fffffe          BL       BSP_IntInit
;;;301    
;;;302        RCC_DeInit();
00014e  f7fffffe          BL       RCC_DeInit
;;;303        RCC_HSEConfig(RCC_HSE_ON);
000152  f44f3080          MOV      r0,#0x10000
000156  f7fffffe          BL       RCC_HSEConfig
;;;304        RCC_WaitForHSEStartUp();
00015a  f7fffffe          BL       RCC_WaitForHSEStartUp
;;;305    
;;;306    
;;;307        RCC_HCLKConfig(RCC_SYSCLK_Div1);
00015e  2000              MOVS     r0,#0
000160  f7fffffe          BL       RCC_HCLKConfig
;;;308        RCC_PCLK2Config(RCC_HCLK_Div1);
000164  2000              MOVS     r0,#0
000166  f7fffffe          BL       RCC_PCLK2Config
;;;309        RCC_PCLK1Config(RCC_HCLK_Div2);
00016a  f44f6080          MOV      r0,#0x400
00016e  f7fffffe          BL       RCC_PCLK1Config
;;;310        RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000172  f44f4000          MOV      r0,#0x8000
000176  f7fffffe          BL       RCC_ADCCLKConfig
;;;311        FLASH_SetLatency(FLASH_Latency_2);
00017a  2002              MOVS     r0,#2
00017c  f7fffffe          BL       FLASH_SetLatency
;;;312        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000180  2010              MOVS     r0,#0x10
000182  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;313        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000186  f44f11e0          MOV      r1,#0x1c0000
00018a  f44f3080          MOV      r0,#0x10000
00018e  f7fffffe          BL       RCC_PLLConfig
;;;314        RCC_PLLCmd(ENABLE);
000192  2001              MOVS     r0,#1
000194  f7fffffe          BL       RCC_PLLCmd
                  |L1.408|
;;;315    
;;;316        while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) {
000198  2039              MOVS     r0,#0x39
00019a  f7fffffe          BL       RCC_GetFlagStatus
00019e  2800              CMP      r0,#0
0001a0  d0fa              BEQ      |L1.408|
;;;317            ;
;;;318        }
;;;319    
;;;320        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
0001a2  2002              MOVS     r0,#2
0001a4  f7fffffe          BL       RCC_SYSCLKConfig
                  |L1.424|
;;;321    
;;;322        while (RCC_GetSYSCLKSource() != 0x08) {
0001a8  f7fffffe          BL       RCC_GetSYSCLKSource
0001ac  2808              CMP      r0,#8
0001ae  d1fb              BNE      |L1.424|
;;;323            ;
;;;324        }
;;;325        return;
;;;326    }
0001b0  bd10              POP      {r4,pc}
;;;327    
                          ENDP

                  BSP_Init_post PROC
;;;346    
;;;347    void  BSP_Init_post (void)
0001b2  f44f30e1          MOV      r0,#0x1c200
;;;348    {
;;;349        db_usart1_init(115200);
0001b6  e7fe              B        db_usart1_init
;;;350    
;;;351    	// 不再需要
;;;352        //BSP_ADC_Init();                                             /* Initialize the I/Os for the ADC      controls.       */
;;;353        //BSP_LED_Init();                                             /* Initialize the I/Os for the LED      controls.       */
;;;354        //BSP_PB_Init();                                              /* Initialize the I/Os for the PB       control.        */
;;;355        //BSP_Joystick_Init();                                        /* Initialize the I/Os for the Joystick control.        */    
;;;356    }
;;;357    
                          ENDP

                  BSP_CPU_ClkFreq PROC
;;;374    
;;;375    CPU_INT32U  BSP_CPU_ClkFreq (void)
0001b8  b500              PUSH     {lr}
;;;376    {
0001ba  b085              SUB      sp,sp,#0x14
;;;377        RCC_ClocksTypeDef  rcc_clocks;
;;;378    
;;;379    
;;;380        RCC_GetClocksFreq(&rcc_clocks);
0001bc  4668              MOV      r0,sp
0001be  f7fffffe          BL       RCC_GetClocksFreq
;;;381    
;;;382        return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
0001c2  9801              LDR      r0,[sp,#4]
;;;383    }
0001c4  b005              ADD      sp,sp,#0x14
0001c6  bd00              POP      {pc}
;;;384    
                          ENDP

                  OS_CPU_SysTickClkFreq PROC
;;;408    
;;;409    INT32U  OS_CPU_SysTickClkFreq (void)
0001c8  e7fe              B        BSP_CPU_ClkFreq
;;;410    {
;;;411        INT32U  freq;
;;;412    
;;;413    
;;;414        freq = BSP_CPU_ClkFreq();
;;;415        return (freq);
;;;416    }
;;;417    
                          ENDP

                  BSP_ADC_GetStatus PROC
;;;486    
;;;487    CPU_INT16U  BSP_ADC_GetStatus (CPU_INT08U  adc)
0001ca  4601              MOV      r1,r0
;;;488    {
;;;489        CPU_INT16U  result;
;;;490    
;;;491    
;;;492        result = 0;
0001cc  2000              MOVS     r0,#0
;;;493    
;;;494        if (adc == 1) {
0001ce  2901              CMP      r1,#1
0001d0  d102              BNE      |L1.472|
;;;495            result = ADC_GetConversionValue(ADC1);
0001d2  4896              LDR      r0,|L1.1068|
0001d4  f7ffbffe          B.W      ADC_GetConversionValue
                  |L1.472|
;;;496        }
;;;497    
;;;498        return (result);
;;;499    }
0001d8  4770              BX       lr
;;;500    
                          ENDP

                  BSP_PB_GetStatus PROC
;;;564    
;;;565    CPU_BOOLEAN  BSP_PB_GetStatus (CPU_INT08U pb)
0001da  b510              PUSH     {r4,lr}
;;;566    {
;;;567        CPU_BOOLEAN  status;
;;;568        CPU_INT32U   pin;
;;;569    
;;;570    
;;;571        status = DEF_FALSE;
0001dc  2400              MOVS     r4,#0
;;;572    
;;;573        switch (pb) {
0001de  2801              CMP      r0,#1
0001e0  d004              BEQ      |L1.492|
0001e2  2802              CMP      r0,#2
0001e4  d00a              BEQ      |L1.508|
0001e6  2803              CMP      r0,#3
0001e8  d116              BNE      |L1.536|
0001ea  e00e              B        |L1.522|
                  |L1.492|
;;;574            case BSP_PB_ID_KEY:
;;;575                 pin = GPIO_ReadInputDataBit(GPIOG, BSP_GPIOG_PB_KEY);
0001ec  f44f7180          MOV      r1,#0x100
0001f0  488f              LDR      r0,|L1.1072|
0001f2  f7fffffe          BL       GPIO_ReadInputDataBit
;;;576                 if (pin == 0) {
0001f6  b978              CBNZ     r0,|L1.536|
;;;577                     status = DEF_TRUE;
0001f8  2401              MOVS     r4,#1
0001fa  e00d              B        |L1.536|
                  |L1.508|
;;;578                 }
;;;579                 break;
;;;580    
;;;581            case BSP_PB_ID_WAKEUP:
;;;582                 pin = GPIO_ReadInputDataBit(GPIOA, BSP_GPIOA_PB_WAKEUP);
0001fc  2101              MOVS     r1,#1
0001fe  4886              LDR      r0,|L1.1048|
000200  f7fffffe          BL       GPIO_ReadInputDataBit
;;;583                 if (pin == 0) {
000204  b940              CBNZ     r0,|L1.536|
;;;584                     status = DEF_TRUE;
000206  2401              MOVS     r4,#1
000208  e006              B        |L1.536|
                  |L1.522|
;;;585                 }
;;;586                 break;
;;;587    
;;;588            case BSP_PB_ID_TAMPER:
;;;589                 pin = GPIO_ReadInputDataBit(GPIOC, BSP_GPIOC_PB_TAMPER);
00020a  f44f5100          MOV      r1,#0x2000
00020e  4889              LDR      r0,|L1.1076|
000210  f7fffffe          BL       GPIO_ReadInputDataBit
;;;590                 if (pin == 0) {
000214  b900              CBNZ     r0,|L1.536|
;;;591                     status = DEF_TRUE;
000216  2401              MOVS     r4,#1
                  |L1.536|
;;;592                 }
;;;593                 break;
;;;594    
;;;595            default:
;;;596                 break;
;;;597        }
;;;598    
;;;599        return (status);
000218  4620              MOV      r0,r4
;;;600    }
00021a  bd10              POP      {r4,pc}
;;;601    
                          ENDP

                  BSP_Joystick_GetStatus PROC
;;;665    
;;;666    CPU_INT32U  BSP_Joystick_GetStatus (void)
00021c  b570              PUSH     {r4-r6,lr}
;;;667    {
;;;668        CPU_BOOLEAN  pin;
;;;669        CPU_BOOLEAN  status;
;;;670    
;;;671        status = 0;
00021e  2400              MOVS     r4,#0
;;;672    
;;;673        pin    = GPIO_ReadInputDataBit(GPIOG, BSP_GPIOG_JOY_RIGHT);
000220  4d83              LDR      r5,|L1.1072|
000222  f44f5100          MOV      r1,#0x2000
000226  4628              MOV      r0,r5
000228  f7fffffe          BL       GPIO_ReadInputDataBit
;;;674        if (pin == 0) {
00022c  b900              CBNZ     r0,|L1.560|
;;;675            status |= BSP_JOYSTICK_LEFT;
00022e  2404              MOVS     r4,#4
                  |L1.560|
;;;676        }
;;;677    
;;;678        pin    = GPIO_ReadInputDataBit(GPIOG, BSP_GPIOG_JOY_LEFT);
000230  f44f4180          MOV      r1,#0x4000
000234  4628              MOV      r0,r5
000236  f7fffffe          BL       GPIO_ReadInputDataBit
;;;679        if (pin == 0) {
00023a  b908              CBNZ     r0,|L1.576|
;;;680            status |= BSP_JOYSTICK_RIGHT;
00023c  f0440408          ORR      r4,r4,#8
                  |L1.576|
;;;681        }
;;;682    
;;;683        pin    = GPIO_ReadInputDataBit(GPIOG, BSP_GPIOG_JOY_UP);
000240  f44f4100          MOV      r1,#0x8000
000244  4628              MOV      r0,r5
000246  f7fffffe          BL       GPIO_ReadInputDataBit
;;;684        if (pin == 0) {
00024a  b908              CBNZ     r0,|L1.592|
;;;685            status |= BSP_JOYSTICK_UP;
00024c  f0440401          ORR      r4,r4,#1
                  |L1.592|
;;;686        }
;;;687    
;;;688        pin    = GPIO_ReadInputDataBit(GPIOD, BSP_GPIOD_JOY_DOWN);
000250  2108              MOVS     r1,#8
000252  4879              LDR      r0,|L1.1080|
000254  f7fffffe          BL       GPIO_ReadInputDataBit
;;;689        if (pin == 0) {
000258  b908              CBNZ     r0,|L1.606|
;;;690            status |= BSP_JOYSTICK_DOWN;
00025a  f0440402          ORR      r4,r4,#2
                  |L1.606|
;;;691        }
;;;692    
;;;693        pin    = GPIO_ReadInputDataBit(GPIOG, BSP_GPIOG_JOY_SEL);
00025e  2180              MOVS     r1,#0x80
000260  4628              MOV      r0,r5
000262  f7fffffe          BL       GPIO_ReadInputDataBit
;;;694        if (pin == 0) {
000266  b908              CBNZ     r0,|L1.620|
;;;695            status |= BSP_JOYSTICK_CENTER;
000268  f0440410          ORR      r4,r4,#0x10
                  |L1.620|
;;;696        }
;;;697    
;;;698        return (status);
00026c  4620              MOV      r0,r4
;;;699    }
00026e  bd70              POP      {r4-r6,pc}
;;;700    
                          ENDP

                  BSP_LED_On PROC
;;;759    
;;;760    void  BSP_LED_On (CPU_INT08U led)
000270  4601              MOV      r1,r0
;;;761    {
;;;762        switch (led) {
;;;763            case 0:
;;;764                 GPIO_SetBits(GPIOF, BSP_GPIOF_LED1 | BSP_GPIOF_LED2 | BSP_GPIOF_LED3 | BSP_GPIOF_LED4);
000272  4872              LDR      r0,|L1.1084|
000274  2905              CMP      r1,#5                 ;762
000276  d216              BCS      |L1.678|
000278  e8dff001          TBB      [pc,r1]               ;762
00027c  03070a0d          DCB      0x03,0x07,0x0a,0x0d
000280  1100              DCB      0x11,0x00
000282  f44f7170          MOV      r1,#0x3c0
000286  f7ffbffe          B.W      GPIO_SetBits
;;;765                 break;
;;;766    
;;;767            case 1:
;;;768                 GPIO_SetBits(GPIOF, BSP_GPIOF_LED1);
00028a  2140              MOVS     r1,#0x40
00028c  f7ffbffe          B.W      GPIO_SetBits
;;;769                 break;
;;;770    
;;;771            case 2:
;;;772                 GPIO_SetBits(GPIOF, BSP_GPIOF_LED2);
000290  2180              MOVS     r1,#0x80
000292  f7ffbffe          B.W      GPIO_SetBits
;;;773                 break;
;;;774    
;;;775            case 3:
;;;776                 GPIO_SetBits(GPIOF, BSP_GPIOF_LED3);
000296  f44f7180          MOV      r1,#0x100
00029a  f7ffbffe          B.W      GPIO_SetBits
;;;777                 break;
;;;778    
;;;779            case 4:
;;;780                 GPIO_SetBits(GPIOF, BSP_GPIOF_LED4);
00029e  f44f7100          MOV      r1,#0x200
0002a2  f7ffbffe          B.W      GPIO_SetBits
                  |L1.678|
;;;781                 break;
;;;782    
;;;783            default:
;;;784                 break;
;;;785        }
;;;786    }
0002a6  4770              BX       lr
;;;787    
                          ENDP

                  BSP_LED_Off PROC
;;;809    
;;;810    void  BSP_LED_Off (CPU_INT08U led)
0002a8  4601              MOV      r1,r0
;;;811    {
;;;812        switch (led) {
;;;813            case 0:
;;;814                 GPIO_ResetBits(GPIOF, BSP_GPIOF_LED1 | BSP_GPIOF_LED2 | BSP_GPIOF_LED3 | BSP_GPIOF_LED4);
0002aa  4864              LDR      r0,|L1.1084|
0002ac  2905              CMP      r1,#5                 ;812
0002ae  d216              BCS      |L1.734|
0002b0  e8dff001          TBB      [pc,r1]               ;812
0002b4  03070a0d          DCB      0x03,0x07,0x0a,0x0d
0002b8  1100              DCB      0x11,0x00
0002ba  f44f7170          MOV      r1,#0x3c0
0002be  f7ffbffe          B.W      GPIO_ResetBits
;;;815                 break;
;;;816    
;;;817            case 1:
;;;818                 GPIO_ResetBits(GPIOF, BSP_GPIOF_LED1);
0002c2  2140              MOVS     r1,#0x40
0002c4  f7ffbffe          B.W      GPIO_ResetBits
;;;819                 break;
;;;820    
;;;821            case 2:
;;;822                 GPIO_ResetBits(GPIOF, BSP_GPIOF_LED2);
0002c8  2180              MOVS     r1,#0x80
0002ca  f7ffbffe          B.W      GPIO_ResetBits
;;;823                 break;
;;;824    
;;;825            case 3:
;;;826                 GPIO_ResetBits(GPIOF, BSP_GPIOF_LED3);
0002ce  f44f7180          MOV      r1,#0x100
0002d2  f7ffbffe          B.W      GPIO_ResetBits
;;;827                 break;
;;;828    
;;;829            case 4:
;;;830                 GPIO_ResetBits(GPIOF, BSP_GPIOF_LED4);
0002d6  f44f7100          MOV      r1,#0x200
0002da  f7ffbffe          B.W      GPIO_ResetBits
                  |L1.734|
;;;831                 break;
;;;832    
;;;833            default:
;;;834                 break;
;;;835        }
;;;836    }
0002de  4770              BX       lr
;;;837    
                          ENDP

                  BSP_LED_Toggle PROC
;;;859    
;;;860    void  BSP_LED_Toggle (CPU_INT08U led)
0002e0  b510              PUSH     {r4,lr}
;;;861    {
0002e2  4604              MOV      r4,r0
;;;862        CPU_INT32U  pins;
;;;863    
;;;864    
;;;865        pins = GPIO_ReadOutputData(GPIOC);
0002e4  4853              LDR      r0,|L1.1076|
0002e6  f7fffffe          BL       GPIO_ReadOutputData
;;;866    
;;;867        switch (led) {
;;;868            case 0:
;;;869                 BSP_LED_Toggle(1);
;;;870                 BSP_LED_Toggle(2);
;;;871                 BSP_LED_Toggle(3);
;;;872                 BSP_LED_Toggle(4);
;;;873                 break;
;;;874    
;;;875            case 1:
;;;876                 if ((pins & BSP_GPIOF_LED1) == 0) {
;;;877                     GPIO_SetBits(  GPIOF, BSP_GPIOF_LED1);
0002ea  4a54              LDR      r2,|L1.1084|
0002ec  2c05              CMP      r4,#5                 ;867
0002ee  d251              BCS      |L1.916|
0002f0  e8dff004          TBB      [pc,r4]               ;867
0002f4  03101f2e          DCB      0x03,0x10,0x1f,0x2e
0002f8  3f00              DCB      0x3f,0x00
0002fa  2001              MOVS     r0,#1                 ;869
0002fc  f7fffffe          BL       BSP_LED_Toggle
000300  2002              MOVS     r0,#2                 ;870
000302  f7fffffe          BL       BSP_LED_Toggle
000306  2003              MOVS     r0,#3                 ;871
000308  f7fffffe          BL       BSP_LED_Toggle
00030c  e8bd4010          POP      {r4,lr}               ;872
000310  2004              MOVS     r0,#4                 ;872
000312  e7fe              B        BSP_LED_Toggle
000314  f0100f40          TST      r0,#0x40              ;876
000318  d005              BEQ      |L1.806|
;;;878                 } else {
;;;879                     GPIO_ResetBits(GPIOF, BSP_GPIOF_LED1);
00031a  e8bd4010          POP      {r4,lr}
00031e  2140              MOVS     r1,#0x40
000320  4610              MOV      r0,r2
000322  f7ffbffe          B.W      GPIO_ResetBits
                  |L1.806|
000326  e8bd4010          POP      {r4,lr}               ;877
00032a  2140              MOVS     r1,#0x40              ;877
00032c  4610              MOV      r0,r2                 ;877
00032e  f7ffbffe          B.W      GPIO_SetBits
;;;880                 }
;;;881                break;
;;;882    
;;;883            case 2:
;;;884                 if ((pins & BSP_GPIOF_LED2) == 0) {
000332  f0100f80          TST      r0,#0x80
000336  d005              BEQ      |L1.836|
;;;885                     GPIO_SetBits(  GPIOF, BSP_GPIOF_LED2);
;;;886                 } else {
;;;887                     GPIO_ResetBits(GPIOF, BSP_GPIOF_LED2);
000338  e8bd4010          POP      {r4,lr}
00033c  2180              MOVS     r1,#0x80
00033e  4610              MOV      r0,r2
000340  f7ffbffe          B.W      GPIO_ResetBits
                  |L1.836|
000344  e8bd4010          POP      {r4,lr}               ;885
000348  2180              MOVS     r1,#0x80              ;885
00034a  4610              MOV      r0,r2                 ;885
00034c  f7ffbffe          B.W      GPIO_SetBits
;;;888                 }
;;;889                break;
;;;890    
;;;891            case 3:
;;;892                 if ((pins & BSP_GPIOF_LED3) == 0) {
000350  f4107f80          TST      r0,#0x100
000354  d006              BEQ      |L1.868|
;;;893                     GPIO_SetBits(  GPIOF, BSP_GPIOF_LED3);
;;;894                 } else {
;;;895                     GPIO_ResetBits(GPIOF, BSP_GPIOF_LED3);
000356  e8bd4010          POP      {r4,lr}
00035a  f44f7180          MOV      r1,#0x100
00035e  4610              MOV      r0,r2
000360  f7ffbffe          B.W      GPIO_ResetBits
                  |L1.868|
000364  e8bd4010          POP      {r4,lr}               ;893
000368  f44f7180          MOV      r1,#0x100             ;893
00036c  4610              MOV      r0,r2                 ;893
00036e  f7ffbffe          B.W      GPIO_SetBits
;;;896                 }
;;;897                break;
;;;898    
;;;899            case 4:
;;;900                 if ((pins & BSP_GPIOF_LED4) == 0) {
000372  f4107f00          TST      r0,#0x200
000376  d006              BEQ      |L1.902|
;;;901                     GPIO_SetBits(  GPIOF, BSP_GPIOF_LED4);
;;;902                 } else {
;;;903                     GPIO_ResetBits(GPIOF, BSP_GPIOF_LED4);
000378  e8bd4010          POP      {r4,lr}
00037c  f44f7100          MOV      r1,#0x200
000380  4610              MOV      r0,r2
000382  f7ffbffe          B.W      GPIO_ResetBits
                  |L1.902|
000386  e8bd4010          POP      {r4,lr}               ;901
00038a  f44f7100          MOV      r1,#0x200             ;901
00038e  4610              MOV      r0,r2                 ;901
000390  f7ffbffe          B.W      GPIO_SetBits
                  |L1.916|
;;;904                 }
;;;905                break;
;;;906    
;;;907            default:
;;;908                 break;
;;;909        }
;;;910    }
000394  bd10              POP      {r4,pc}
;;;911    
                          ENDP

                  BSP_NAND_Init PROC
;;;935    
;;;936    void  BSP_NAND_Init (void)
000396  b570              PUSH     {r4-r6,lr}
;;;937    {
000398  b090              SUB      sp,sp,#0x40
;;;938        GPIO_InitTypeDef                   gpio_init;
;;;939        FSMC_NANDInitTypeDef               nand_init;
;;;940        FSMC_NAND_PCCARDTimingInitTypeDef  p;
;;;941    
;;;942    
;;;943        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG, ENABLE);
00039a  2101              MOVS     r1,#1
00039c  f44f70f0          MOV      r0,#0x1e0
0003a0  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;944    
;;;945                                                                    /* ---------------------- CFG GPIO -------------------- */
;;;946                                                                    /* CLE, ALE, D0..3, NOW, NWE & NCE2 NAND pin cfg.       */
;;;947        gpio_init.GPIO_Pin   =  GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_14 | GPIO_Pin_15 |
0003a4  f64d00b3          MOV      r0,#0xd8b3
0003a8  f8ad0038          STRH     r0,[sp,#0x38]
;;;948                                GPIO_Pin_0  | GPIO_Pin_1  | GPIO_Pin_4  | GPIO_Pin_5  | GPIO_Pin_7;
;;;949        gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
0003ac  2403              MOVS     r4,#3
0003ae  f88d403a          STRB     r4,[sp,#0x3a]
;;;950        gpio_init.GPIO_Mode  = GPIO_Mode_AF_PP;
0003b2  2018              MOVS     r0,#0x18
0003b4  f88d003b          STRB     r0,[sp,#0x3b]
;;;951    
;;;952        GPIO_Init(GPIOD, &gpio_init);
0003b8  4e1f              LDR      r6,|L1.1080|
0003ba  a90e              ADD      r1,sp,#0x38
0003bc  4630              MOV      r0,r6
0003be  f7fffffe          BL       GPIO_Init
;;;953    
;;;954                                                                    /* D4..7 NAND pin configuration.                        */
;;;955        gpio_init.GPIO_Pin   = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10;
0003c2  f44f61f0          MOV      r1,#0x780
0003c6  f8ad1038          STRH     r1,[sp,#0x38]
;;;956    
;;;957        GPIO_Init(GPIOE, &gpio_init);
0003ca  a90e              ADD      r1,sp,#0x38
0003cc  481c              LDR      r0,|L1.1088|
0003ce  f7fffffe          BL       GPIO_Init
;;;958    
;;;959    
;;;960                                                                    /* NWAIT NAND pin configuration.                        */
;;;961        gpio_init.GPIO_Pin   = GPIO_Pin_6;   							
0003d2  2540              MOVS     r5,#0x40
0003d4  f8ad5038          STRH     r5,[sp,#0x38]
;;;962        gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
0003d8  f88d403a          STRB     r4,[sp,#0x3a]
;;;963        gpio_init.GPIO_Mode  = GPIO_Mode_IPU;
0003dc  2148              MOVS     r1,#0x48
0003de  f88d103b          STRB     r1,[sp,#0x3b]
;;;964    
;;;965        GPIO_Init(GPIOD, &gpio_init);
0003e2  a90e              ADD      r1,sp,#0x38
0003e4  4630              MOV      r0,r6
0003e6  f7fffffe          BL       GPIO_Init
;;;966    
;;;967                                                                    /* INT2 NAND pin configuration.                         */
;;;968        gpio_init.GPIO_Pin   = GPIO_Pin_6;   							
0003ea  f8ad5038          STRH     r5,[sp,#0x38]
;;;969        GPIO_Init(GPIOG, &gpio_init);
0003ee  a90e              ADD      r1,sp,#0x38
0003f0  480f              LDR      r0,|L1.1072|
0003f2  f7fffffe          BL       GPIO_Init
;;;970    
;;;971                                                                    /* ---------------------- CFG FSMC -------------------- */
;;;972        p.FSMC_SetupTime                          = 0x1;
0003f6  2001              MOVS     r0,#1
0003f8  9000              STR      r0,[sp,#0]
;;;973        p.FSMC_WaitSetupTime                      = 0x3;
0003fa  9401              STR      r4,[sp,#4]
;;;974        p.FSMC_HoldSetupTime                      = 0x2;
0003fc  2102              MOVS     r1,#2
0003fe  9102              STR      r1,[sp,#8]
;;;975        p.FSMC_HiZSetupTime                       = 0x1;
000400  9003              STR      r0,[sp,#0xc]
;;;976    
;;;977        nand_init.FSMC_Bank                       = FSMC_Bank2_NAND;
000402  2010              MOVS     r0,#0x10
000404  9004              STR      r0,[sp,#0x10]
;;;978        nand_init.FSMC_Waitfeature                = FSMC_Waitfeature_Enable;
000406  e01d              B        |L1.1092|
                  |L1.1032|
                          DCD      0x40013800
                  |L1.1036|
00040c  256300            DCB      "%c",0
00040f  00                DCB      0
                  |L1.1040|
                          DCD      ||.data||
                  |L1.1044|
                          DCD      ||.bss||
                  |L1.1048|
                          DCD      0x40010800
                  |L1.1052|
                          DCD      0x4001380c
                  |L1.1056|
                          DCD      ||.constdata||
                  |L1.1060|
000424  0a25730a          DCB      "\n%s\n",0
000428  00      
000429  00                DCB      0
00042a  00                DCB      0
00042b  00                DCB      0
                  |L1.1068|
                          DCD      0x40012400
                  |L1.1072|
                          DCD      0x40012000
                  |L1.1076|
                          DCD      0x40011000
                  |L1.1080|
                          DCD      0x40011400
                  |L1.1084|
                          DCD      0x40011c00
                  |L1.1088|
                          DCD      0x40011800
                  |L1.1092|
000444  9105              STR      r1,[sp,#0x14]
;;;979        nand_init.FSMC_MemoryDataWidth            = FSMC_MemoryDataWidth_8b;
000446  2000              MOVS     r0,#0
000448  9006              STR      r0,[sp,#0x18]
;;;980        nand_init.FSMC_ECC                        = FSMC_ECC_Enable;
00044a  9507              STR      r5,[sp,#0x1c]
;;;981        nand_init.FSMC_ECCPageSize                = FSMC_ECCPageSize_512Bytes;
00044c  0409              LSLS     r1,r1,#16
00044e  9108              STR      r1,[sp,#0x20]
;;;982        nand_init.FSMC_AddressLowMapping          = FSMC_AddressLowMapping_Direct;
000450  9009              STR      r0,[sp,#0x24]
;;;983        nand_init.FSMC_TCLRSetupTime              = 0x00;
000452  900a              STR      r0,[sp,#0x28]
;;;984        nand_init.FSMC_TARSetupTime               = 0x00;
000454  900b              STR      r0,[sp,#0x2c]
;;;985        nand_init.FSMC_CommonSpaceTimingStruct    = &p;
000456  4668              MOV      r0,sp
000458  f8cdd030          STR      sp,[sp,#0x30]
;;;986        nand_init.FSMC_AttributeSpaceTimingStruct = &p;
00045c  900d              STR      r0,[sp,#0x34]
;;;987    
;;;988        FSMC_NANDInit(&nand_init);
00045e  a804              ADD      r0,sp,#0x10
000460  f7fffffe          BL       FSMC_NANDInit
;;;989    
;;;990        FSMC_NANDCmd(FSMC_Bank2_NAND, ENABLE);                      /* FSMC NAND bank cmd test.                             */
000464  2101              MOVS     r1,#1
000466  2010              MOVS     r0,#0x10
000468  f7fffffe          BL       FSMC_NANDCmd
;;;991    }
00046c  b010              ADD      sp,sp,#0x40
00046e  bd70              POP      {r4-r6,pc}
;;;992    
                          ENDP

                  BSP_NOR_Init PROC
;;;1008   
;;;1009   void  BSP_NOR_Init (void)
000470  b570              PUSH     {r4-r6,lr}
;;;1010   {
000472  b098              SUB      sp,sp,#0x60
;;;1011       GPIO_InitTypeDef               gpio_init;
;;;1012       FSMC_NORSRAMInitTypeDef        nor_init;
;;;1013       FSMC_NORSRAMTimingInitTypeDef  p;
;;;1014   
;;;1015   
;;;1016       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG, ENABLE);
000474  2101              MOVS     r1,#1
000476  f44f70f0          MOV      r0,#0x1e0
00047a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1017   
;;;1018                                                                   /* ---------------------- CFG GPIO -------------------- */
;;;1019                                                                   /* NOR data lines configuration.                        */
;;;1020       gpio_init.GPIO_Pin   = GPIO_Pin_0  | GPIO_Pin_1  | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 | GPIO_Pin_15;
00047e  f24c7003          MOV      r0,#0xc703
000482  f8ad005c          STRH     r0,[sp,#0x5c]
;;;1021       gpio_init.GPIO_Mode  = GPIO_Mode_AF_PP;
000486  2018              MOVS     r0,#0x18
000488  f88d005f          STRB     r0,[sp,#0x5f]
;;;1022       gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
00048c  2003              MOVS     r0,#3
00048e  f88d005e          STRB     r0,[sp,#0x5e]
;;;1023       GPIO_Init(GPIOD, &gpio_init);
000492  4c48              LDR      r4,|L1.1460|
000494  a917              ADD      r1,sp,#0x5c
000496  4620              MOV      r0,r4
000498  f7fffffe          BL       GPIO_Init
;;;1024   
;;;1025       gpio_init.GPIO_Pin   = GPIO_Pin_7  | GPIO_Pin_8  | GPIO_Pin_9  | GPIO_Pin_10 | GPIO_Pin_11 |
00049c  f64f7180          MOV      r1,#0xff80
0004a0  f8ad105c          STRH     r1,[sp,#0x5c]
;;;1026                              GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
;;;1027       GPIO_Init(GPIOE, &gpio_init);
0004a4  4d44              LDR      r5,|L1.1464|
0004a6  a917              ADD      r1,sp,#0x5c
0004a8  4628              MOV      r0,r5
0004aa  f7fffffe          BL       GPIO_Init
;;;1028   
;;;1029                                                                   /* NOR address lines configuration.                     */
;;;1030       gpio_init.GPIO_Pin   = GPIO_Pin_0  | GPIO_Pin_1  | GPIO_Pin_2  | GPIO_Pin_3  | GPIO_Pin_4 |
0004ae  f24f013f          MOV      r1,#0xf03f
0004b2  f8ad105c          STRH     r1,[sp,#0x5c]
;;;1031                              GPIO_Pin_5  | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
;;;1032       GPIO_Init(GPIOF, &gpio_init);
0004b6  a917              ADD      r1,sp,#0x5c
0004b8  4840              LDR      r0,|L1.1468|
0004ba  f7fffffe          BL       GPIO_Init
;;;1033   
;;;1034       gpio_init.GPIO_Pin   = GPIO_Pin_0  | GPIO_Pin_1  | GPIO_Pin_2  | GPIO_Pin_3  | GPIO_Pin_4 | GPIO_Pin_5;
0004be  213f              MOVS     r1,#0x3f
0004c0  f8ad105c          STRH     r1,[sp,#0x5c]
;;;1035       GPIO_Init(GPIOG, &gpio_init);
0004c4  4e3e              LDR      r6,|L1.1472|
0004c6  a917              ADD      r1,sp,#0x5c
0004c8  4630              MOV      r0,r6
0004ca  f7fffffe          BL       GPIO_Init
;;;1036   
;;;1037       gpio_init.GPIO_Pin   = GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13;
0004ce  f44f5160          MOV      r1,#0x3800
0004d2  f8ad105c          STRH     r1,[sp,#0x5c]
;;;1038       GPIO_Init(GPIOD, &gpio_init);
0004d6  a917              ADD      r1,sp,#0x5c
0004d8  4620              MOV      r0,r4
0004da  f7fffffe          BL       GPIO_Init
;;;1039   
;;;1040       gpio_init.GPIO_Pin   = GPIO_Pin_3  | GPIO_Pin_4  | GPIO_Pin_5  | GPIO_Pin_6;
0004de  2178              MOVS     r1,#0x78
0004e0  f8ad105c          STRH     r1,[sp,#0x5c]
;;;1041       GPIO_Init(GPIOE, &gpio_init);
0004e4  a917              ADD      r1,sp,#0x5c
0004e6  4628              MOV      r0,r5
0004e8  f7fffffe          BL       GPIO_Init
;;;1042   
;;;1043                                                                   /* NOE and NWE configuration.                           */
;;;1044       gpio_init.GPIO_Pin   = GPIO_Pin_4  | GPIO_Pin_5;
0004ec  2130              MOVS     r1,#0x30
0004ee  f8ad105c          STRH     r1,[sp,#0x5c]
;;;1045       GPIO_Init(GPIOD, &gpio_init);
0004f2  a917              ADD      r1,sp,#0x5c
0004f4  4620              MOV      r0,r4
0004f6  f7fffffe          BL       GPIO_Init
;;;1046   
;;;1047                                                                   /* NE2 configuration.                                   */
;;;1048       gpio_init.GPIO_Pin   = GPIO_Pin_9;
0004fa  1560              ASRS     r0,r4,#21
0004fc  f8ad005c          STRH     r0,[sp,#0x5c]
;;;1049       GPIO_Init(GPIOG, &gpio_init);
000500  a917              ADD      r1,sp,#0x5c
000502  4630              MOV      r0,r6
000504  f7fffffe          BL       GPIO_Init
;;;1050   
;;;1051                                                                   /* ---------------------- CFG FSMC -------------------- */
;;;1052       p.FSMC_AddressSetupTime             = 0x05;
000508  2005              MOVS     r0,#5
00050a  9001              STR      r0,[sp,#4]
;;;1053       p.FSMC_AddressHoldTime              = 0x00;
00050c  2000              MOVS     r0,#0
00050e  9002              STR      r0,[sp,#8]
;;;1054       p.FSMC_DataSetupTime                = 0x07;
000510  2107              MOVS     r1,#7
000512  9103              STR      r1,[sp,#0xc]
;;;1055       p.FSMC_BusTurnAroundDuration        = 0x00;
000514  9004              STR      r0,[sp,#0x10]
;;;1056       p.FSMC_CLKDivision                  = 0x00;
000516  9005              STR      r0,[sp,#0x14]
;;;1057       p.FSMC_DataLatency                  = 0x00;
000518  9006              STR      r0,[sp,#0x18]
;;;1058       p.FSMC_AccessMode                   = FSMC_AccessMode_B;
00051a  f04f5180          MOV      r1,#0x10000000
00051e  9107              STR      r1,[sp,#0x1c]
;;;1059   
;;;1060       nor_init.FSMC_Bank                  = FSMC_Bank1_NORSRAM2;
000520  2102              MOVS     r1,#2
000522  9108              STR      r1,[sp,#0x20]
;;;1061       nor_init.FSMC_DataAddressMux        = FSMC_DataAddressMux_Disable;
000524  9009              STR      r0,[sp,#0x24]
;;;1062       nor_init.FSMC_MemoryType            = FSMC_MemoryType_NOR;
000526  2108              MOVS     r1,#8
000528  910a              STR      r1,[sp,#0x28]
;;;1063       nor_init.FSMC_MemoryDataWidth       = FSMC_MemoryDataWidth_16b;
00052a  2110              MOVS     r1,#0x10
00052c  910b              STR      r1,[sp,#0x2c]
;;;1064       nor_init.FSMC_BurstAccessMode       = FSMC_BurstAccessMode_Disable;
00052e  900c              STR      r0,[sp,#0x30]
;;;1065       nor_init.FSMC_WaitSignalPolarity    = FSMC_WaitSignalPolarity_Low;
000530  900d              STR      r0,[sp,#0x34]
;;;1066       nor_init.FSMC_WrapMode              = FSMC_WrapMode_Disable;
000532  900e              STR      r0,[sp,#0x38]
;;;1067       nor_init.FSMC_WaitSignalActive      = FSMC_WaitSignalActive_BeforeWaitState;
000534  900f              STR      r0,[sp,#0x3c]
;;;1068       nor_init.FSMC_WriteOperation        = FSMC_WriteOperation_Enable;
000536  0209              LSLS     r1,r1,#8
000538  9110              STR      r1,[sp,#0x40]
;;;1069       nor_init.FSMC_WaitSignal            = FSMC_WaitSignal_Disable;
00053a  9011              STR      r0,[sp,#0x44]
;;;1070       nor_init.FSMC_ExtendedMode          = FSMC_ExtendedMode_Disable;
00053c  9012              STR      r0,[sp,#0x48]
;;;1071       nor_init.FSMC_AsyncWait             = FSMC_AsyncWait_Disable;
00053e  9013              STR      r0,[sp,#0x4c]
;;;1072       nor_init.FSMC_WriteBurst            = FSMC_WriteBurst_Disable;
000540  9014              STR      r0,[sp,#0x50]
;;;1073       nor_init.FSMC_ReadWriteTimingStruct = &p;
000542  a801              ADD      r0,sp,#4
000544  9015              STR      r0,[sp,#0x54]
;;;1074       nor_init.FSMC_WriteTimingStruct     = &p;
000546  9016              STR      r0,[sp,#0x58]
;;;1075   
;;;1076       FSMC_NORSRAMInit(&nor_init);
000548  a808              ADD      r0,sp,#0x20
00054a  f7fffffe          BL       FSMC_NORSRAMInit
;;;1077   
;;;1078                                                                   /* Enable FSMC Bank1_NOR Bank.                          */
;;;1079       FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM2, ENABLE);
00054e  2101              MOVS     r1,#1
000550  2002              MOVS     r0,#2
000552  f7fffffe          BL       FSMC_NORSRAMCmd
;;;1080   }
000556  b018              ADD      sp,sp,#0x60
000558  bd70              POP      {r4-r6,pc}
;;;1081   
                          ENDP

                  OSProbe_TmrInit PROC
;;;1107        (OS_PROBE_HOOKS_EN == 1))
;;;1108   void  OSProbe_TmrInit (void)
00055a  b500              PUSH     {lr}
;;;1109   {
00055c  b083              SUB      sp,sp,#0xc
;;;1110       TIM_TimeBaseInitTypeDef  tim_init;
;;;1111   
;;;1112   
;;;1113       tim_init.TIM_Period        = 0xFFFF;
00055e  f64f70ff          MOV      r0,#0xffff
000562  f8ad0004          STRH     r0,[sp,#4]
;;;1114       tim_init.TIM_Prescaler     = 256;
000566  f44f7080          MOV      r0,#0x100
00056a  f8ad0000          STRH     r0,[sp,#0]
;;;1115       tim_init.TIM_ClockDivision = TIM_CKD_DIV4;
00056e  0040              LSLS     r0,r0,#1
000570  f8ad0006          STRH     r0,[sp,#6]
;;;1116       tim_init.TIM_CounterMode   = TIM_CounterMode_Up;
000574  2000              MOVS     r0,#0
000576  f8ad0002          STRH     r0,[sp,#2]
;;;1117   
;;;1118   #if (OS_PROBE_TIMER_SEL == 2)
;;;1119       RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
00057a  2101              MOVS     r1,#1
00057c  4608              MOV      r0,r1
00057e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1120   
;;;1121       TIM_TimeBaseInit(TIM2, &tim_init);
000582  4669              MOV      r1,sp
000584  f04f4080          MOV      r0,#0x40000000
000588  f7fffffe          BL       TIM_TimeBaseInit
;;;1122       TIM_SetCounter(TIM2, 0);
00058c  2100              MOVS     r1,#0
00058e  f04f4080          MOV      r0,#0x40000000
000592  f7fffffe          BL       TIM_SetCounter
;;;1123       TIM_PrescalerConfig(TIM2, 256, TIM_PSCReloadMode_Immediate);
000596  2201              MOVS     r2,#1
000598  0211              LSLS     r1,r2,#8
00059a  0588              LSLS     r0,r1,#22
00059c  f7fffffe          BL       TIM_PrescalerConfig
;;;1124       TIM_Cmd(TIM2, ENABLE);
0005a0  2101              MOVS     r1,#1
0005a2  0788              LSLS     r0,r1,#30
0005a4  f7fffffe          BL       TIM_Cmd
;;;1125   #elif (OS_PROBE_TIMER_SEL == 3)
;;;1126       RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
;;;1127   
;;;1128       TIM_TimeBaseInit(TIM3, &tim_init);
;;;1129       TIM_SetCounter(TIM3, 0);
;;;1130       TIM_PrescalerConfig(TIM3, 256, TIM_PSCReloadMode_Immediate);
;;;1131       TIM_Cmd(TIM3, ENABLE);
;;;1132   #elif (OS_PROBE_TIMER_SEL == 4)
;;;1133       RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
;;;1134   
;;;1135       TIM_TimeBaseInit(TIM4, &tim_init);
;;;1136       TIM_SetCounter(TIM4, 0);
;;;1137       TIM_PrescalerConfig(TIM4, 256, TIM_PSCReloadMode_Immediate);
;;;1138       TIM_Cmd(TIM4, ENABLE);
;;;1139   #endif
;;;1140   }
0005a8  b003              ADD      sp,sp,#0xc
0005aa  bd00              POP      {pc}
;;;1141   #endif
                          ENDP

                  OSProbe_TmrRd PROC
;;;1160        (OS_PROBE_HOOKS_EN == 1))
;;;1161   CPU_INT32U  OSProbe_TmrRd (void)
0005ac  f04f4080          MOV      r0,#0x40000000
;;;1162   {
;;;1163   #if (OS_PROBE_TIMER_SEL == 2)
;;;1164   
;;;1165       return ((CPU_INT32U)TIM_GetCounter(TIM2));
0005b0  f7ffbffe          B.W      TIM_GetCounter
;;;1166   
;;;1167   #elif (OS_PROBE_TIMER_SEL == 3)
;;;1168   
;;;1169       return ((CPU_INT32U)TIM_GetCounter(TIM3));
;;;1170   
;;;1171   #elif (OS_PROBE_TIMER_SEL == 4)
;;;1172   
;;;1173       return ((CPU_INT32U)TIM_GetCounter(TIM4));
;;;1174   
;;;1175   #endif
;;;1176   }
;;;1177   #endif
                          ENDP

                  |L1.1460|
                          DCD      0x40011400
                  |L1.1464|
                          DCD      0x40011800
                  |L1.1468|
                          DCD      0x40011c00
                  |L1.1472|
                          DCD      0x40012000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=6

                  USART_RX_BUF
                          %        63

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  64625f75          DCB      0x64,0x62,0x5f,0x75
000004  73617274          DCB      0x73,0x61,0x72,0x74
000008  315f696e          DCB      0x31,0x5f,0x69,0x6e
00000c  697400            DCB      0x69,0x74,0x00

                          AREA ||.data||, DATA, ALIGN=1

                  USART_RX_STA
000000  0000              DCW      0x0000

                          AREA ||area_number.7||, DATA, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.data||
                  __stdout
                          DCD      0x00000000
