; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\guidev.o --depend=.\rvmdk\guidev.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\guidev.crf ..\..\..\..\..\uCGUI\GUI\MemDev\GUIDEV.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__GetRect PROC
;;;43     */
;;;44     void GUI_MEMDEV__GetRect(GUI_RECT* pRect) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;45       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  48f8              LDR      r0,|L1.1000|
000006  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
;;;46       pRect->x0 = pDev->x0;
00000e  8801              LDRH     r1,[r0,#0]
000010  8021              STRH     r1,[r4,#0]
;;;47       pRect->y0 = pDev->y0;
000012  8841              LDRH     r1,[r0,#2]
000014  8061              STRH     r1,[r4,#2]
;;;48       pRect->x1 = pDev->x0 + pDev->XSize-1;
000016  8801              LDRH     r1,[r0,#0]
000018  8882              LDRH     r2,[r0,#4]
00001a  4411              ADD      r1,r1,r2
00001c  1e49              SUBS     r1,r1,#1
00001e  80a1              STRH     r1,[r4,#4]
;;;49       pRect->y1 = pDev->y0 + pDev->YSize-1;
000020  8841              LDRH     r1,[r0,#2]
000022  88c0              LDRH     r0,[r0,#6]
000024  4408              ADD      r0,r0,r1
000026  1e40              SUBS     r0,r0,#1
000028  80e0              STRH     r0,[r4,#6]
;;;50     }
00002a  bd10              POP      {r4,pc}
;;;51     
                          ENDP

                  GUI_MEMDEV__Color2Index PROC
;;;55     */
;;;56     unsigned int GUI_MEMDEV__Color2Index(LCD_COLOR Color) {
00002c  b510              PUSH     {r4,lr}
00002e  4604              MOV      r4,r0
;;;57       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000030  48ed              LDR      r0,|L1.1000|
000032  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
000036  f7fffffe          BL       GUI_ALLOC_h2p
;;;58       return pDev->pfColor2Index(Color);
00003a  69c1              LDR      r1,[r0,#0x1c]
00003c  4620              MOV      r0,r4
00003e  e8bd4010          POP      {r4,lr}
000042  4708              BX       r1
;;;59     }
;;;60     
                          ENDP

                  GUI_MEMDEV__Index2Color PROC
;;;64     */
;;;65     LCD_COLOR GUI_MEMDEV__Index2Color(int Index) {
000044  b510              PUSH     {r4,lr}
000046  4604              MOV      r4,r0
;;;66       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000048  48e7              LDR      r0,|L1.1000|
00004a  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
00004e  f7fffffe          BL       GUI_ALLOC_h2p
;;;67       return pDev->pfIndex2Color(Index);
000052  6a01              LDR      r1,[r0,#0x20]
000054  4620              MOV      r0,r4
000056  e8bd4010          POP      {r4,lr}
00005a  4708              BX       r1
;;;68     }
;;;69     
                          ENDP

                  GUI_MEMDEV__GetIndexMask PROC
;;;73     */
;;;74     unsigned int GUI_MEMDEV__GetIndexMask(void) {
00005c  b510              PUSH     {r4,lr}
;;;75       GUI_MEMDEV * pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
00005e  48e2              LDR      r0,|L1.1000|
000060  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
000064  f7fffffe          BL       GUI_ALLOC_h2p
;;;76       return pDev->pfGetIndexMask();
000068  6a40              LDR      r0,[r0,#0x24]
00006a  e8bd4010          POP      {r4,lr}
00006e  4700              BX       r0
;;;77     }
;;;78     
                          ENDP

                  GUI_MEMDEV_Delete PROC
;;;88     */
;;;89     void GUI_MEMDEV_Delete(GUI_MEMDEV_Handle hMemDev) {
000070  b510              PUSH     {r4,lr}
000072  4604              MOV      r4,r0
;;;90     /* Make sure memory device is not used */
;;;91       GUI_LOCK();
000074  f7fffffe          BL       GUI_Lock
;;;92       if (hMemDev) {
000078  b18c              CBZ      r4,|L1.158|
;;;93         GUI_MEMDEV* pDev;
;;;94         if (GUI_Context.hDevData == hMemDev) {
00007a  48db              LDR      r0,|L1.1000|
00007c  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
000080  42a0              CMP      r0,r4
000082  d101              BNE      |L1.136|
;;;95     	    GUI_SelectLCD();
000084  f7fffffe          BL       GUI_SelectLCD
                  |L1.136|
;;;96         }
;;;97         pDev = GUI_MEMDEV_H2P(hMemDev);
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       GUI_ALLOC_h2p
;;;98         /* Delete the associated usage device */
;;;99         if (pDev->hUsage)
00008e  f9b00018          LDRSH    r0,[r0,#0x18]
000092  b108              CBZ      r0,|L1.152|
;;;100          GUI_USAGE_DecUseCnt(pDev->hUsage);
000094  f7fffffe          BL       GUI_USAGE_DecUseCnt
                  |L1.152|
;;;101        GUI_ALLOC_Free(hMemDev);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       GUI_ALLOC_Free
                  |L1.158|
;;;102      }
;;;103      GUI_UNLOCK();
00009e  e8bd4010          POP      {r4,lr}
0000a2  f7ffbffe          B.W      GUI_Unlock
;;;104    }
;;;105    
                          ENDP

                  GUI_MEMDEV__CreateFixed PROC
;;;109    */
;;;110    GUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xsize, int ysize, int Flags
0000a6  e92d4fff          PUSH     {r0-r11,lr}
;;;111                                            ,const tLCDDEV_APIList * pMemDevAPI
;;;112                                            ,tLCDDEV_Color2Index*        pfColor2Index
;;;113                                            ,tLCDDEV_Index2Color*        pfIndex2Color
;;;114                                            ,tLCDDEV_GetIndexMask*       pfGetIndexMask) {
0000aa  b083              SUB      sp,sp,#0xc
0000ac  4692              MOV      r10,r2
0000ae  f8ddb048          LDR      r11,[sp,#0x48]
0000b2  f8dd9044          LDR      r9,[sp,#0x44]
0000b6  9c10              LDR      r4,[sp,#0x40]
0000b8  461d              MOV      r5,r3
;;;115      I32 MemSize;
;;;116      GUI_USAGE_Handle hUsage = 0;
0000ba  2600              MOVS     r6,#0
;;;117      unsigned int BitsPerPixel, BytesPerLine;
;;;118      GUI_MEMDEV_Handle hMemDev;
;;;119      BitsPerPixel = pMemDevAPI->BitsPerPixel;
0000bc  f8d98040          LDR      r8,[r9,#0x40]
;;;120      BytesPerLine = (xsize * BitsPerPixel + 7) >> 3;     /* Note: This code works with 8 and 16 bit memory devices. If other BPPs are introduced for MemDevs, it needs to be changed */
0000c0  fb0af008          MUL      r0,r10,r8
0000c4  1dc0              ADDS     r0,r0,#7
0000c6  08c7              LSRS     r7,r0,#3
;;;121      /* Calc available MemSize */
;;;122      MemSize = GUI_ALLOC_GetMaxSize();
0000c8  f7fffffe          BL       GUI_ALLOC_GetMaxSize
;;;123      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
0000cc  f0140f01          TST      r4,#1
0000d0  d105              BNE      |L1.222|
;;;124        MemSize = (MemSize / 4) * 3;   /* We need to reserve some memory for usage object ... TBD: This can be optimized as we do not use memory perfectly. */
0000d2  17c1              ASRS     r1,r0,#31
0000d4  eb007091          ADD      r0,r0,r1,LSR #30
0000d8  1080              ASRS     r0,r0,#2
0000da  eb000040          ADD      r0,r0,r0,LSL #1
                  |L1.222|
;;;125      }
;;;126      if (ysize<=0) {
0000de  2d00              CMP      r5,#0
0000e0  dc07              BGT      |L1.242|
;;;127        int MaxLines = (MemSize - sizeof(GUI_MEMDEV)) / BytesPerLine;
0000e2  382c              SUBS     r0,r0,#0x2c
0000e4  fbb0f0f7          UDIV     r0,r0,r7
;;;128        ysize = (MaxLines > -ysize) ? -ysize : MaxLines;
0000e8  4269              RSBS     r1,r5,#0
0000ea  4288              CMP      r0,r1
0000ec  dd00              BLE      |L1.240|
0000ee  4608              MOV      r0,r1
                  |L1.240|
0000f0  4605              MOV      r5,r0
                  |L1.242|
;;;129      }
;;;130      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
0000f2  f0140f01          TST      r4,#1
0000f6  d108              BNE      |L1.266|
;;;131        /* Create the usage map */
;;;132        hUsage = GUI_USAGE_BM_Create(x0, y0, xsize, ysize, 0);
0000f8  2300              MOVS     r3,#0
0000fa  9300              STR      r3,[sp,#0]
0000fc  462b              MOV      r3,r5
0000fe  4652              MOV      r2,r10
000100  9904              LDR      r1,[sp,#0x10]
000102  9803              LDR      r0,[sp,#0xc]
000104  f7fffffe          BL       GUI_USAGE_BM_Create
000108  4606              MOV      r6,r0
                  |L1.266|
;;;133      }
;;;134      /* Check if we can alloc sufficient memory */
;;;135      if (ysize <= 0) {
00010a  2d00              CMP      r5,#0
00010c  dc05              BGT      |L1.282|
;;;136        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Too little memory");
;;;137        GUI_UNLOCK();
00010e  f7fffffe          BL       GUI_Unlock
;;;138        return 0;    
;;;139      }
;;;140      MemSize = ysize * BytesPerLine + sizeof(GUI_MEMDEV);
;;;141      if (Flags & GUI_MEMDEV_NOTRANS) {
;;;142        hMemDev = GUI_ALLOC_AllocNoInit(MemSize);
;;;143      } else {
;;;144        hMemDev = GUI_ALLOC_AllocZero(MemSize);
;;;145      }
;;;146      if (hMemDev) {
;;;147        GUI_MEMDEV* pDevData;
;;;148        pDevData = GUI_MEMDEV_H2P(hMemDev);
;;;149        pDevData->x0            = x0;
;;;150        pDevData->y0            = y0;
;;;151        pDevData->XSize         = xsize;
;;;152        pDevData->YSize         = ysize;
;;;153        pDevData->NumColors     = 
;;;154        #if GUI_NUM_LAYERS == 1
;;;155          LCD_GET_NUMCOLORS();
;;;156        #else
;;;157          LCD_GetNumColorsEx(GUI_Context.SelLayer);
;;;158        #endif
;;;159        pDevData->BytesPerLine  = BytesPerLine;
;;;160        pDevData->hUsage        = hUsage;
;;;161        /* Set color conversion routine pointers */
;;;162        pDevData->pfColor2Index = pfColor2Index;    /* LCD_L0_Color2Index; */
;;;163        pDevData->pfIndex2Color = pfIndex2Color;    /* LCD_L0_Index2Color; */
;;;164        pDevData->pfGetIndexMask= pfGetIndexMask;   /* LCD_L0_GetIndexMask */
;;;165    
;;;166        pDevData->pAPIList      = pMemDevAPI;
;;;167        pDevData->BitsPerPixel  = BitsPerPixel;
;;;168        #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;169          pDevData->LayerIndex  = GUI_Context.SelLayer;
;;;170        #else
;;;171          pDevData->LayerIndex  = 0;
;;;172        #endif
;;;173      } else {
;;;174        if (hUsage) {
;;;175          GUI_ALLOC_Free(hUsage);
;;;176        }
;;;177        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Alloc failed");
;;;178      }
;;;179      return hMemDev;
;;;180    }
000112  b007              ADD      sp,sp,#0x1c
000114  2000              MOVS     r0,#0                 ;138
000116  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.282|
00011a  fb05f007          MUL      r0,r5,r7              ;140
00011e  302c              ADDS     r0,r0,#0x2c           ;140
000120  f0140f01          TST      r4,#1                 ;141
000124  d004              BEQ      |L1.304|
000126  b200              SXTH     r0,r0                 ;142
000128  f7fffffe          BL       GUI_ALLOC_AllocNoInit
00012c  9002              STR      r0,[sp,#8]            ;142
00012e  e003              B        |L1.312|
                  |L1.304|
000130  b200              SXTH     r0,r0                 ;144
000132  f7fffffe          BL       GUI_ALLOC_AllocZero
000136  9002              STR      r0,[sp,#8]            ;144
                  |L1.312|
000138  9802              LDR      r0,[sp,#8]            ;146
00013a  b1e0              CBZ      r0,|L1.374|
00013c  9802              LDR      r0,[sp,#8]            ;148
00013e  f7fffffe          BL       GUI_ALLOC_h2p
000142  4604              MOV      r4,r0                 ;148
000144  9903              LDR      r1,[sp,#0xc]          ;149
000146  8021              STRH     r1,[r4,#0]            ;149
000148  9904              LDR      r1,[sp,#0x10]         ;150
00014a  8061              STRH     r1,[r4,#2]            ;150
00014c  f8a4a004          STRH     r10,[r4,#4]           ;151
000150  80e5              STRH     r5,[r4,#6]            ;152
000152  f7fffffe          BL       LCD_GetNumColors
000156  60a0              STR      r0,[r4,#8]            ;153
000158  60e7              STR      r7,[r4,#0xc]          ;159
00015a  8326              STRH     r6,[r4,#0x18]         ;160
00015c  f8c4b01c          STR      r11,[r4,#0x1c]        ;162
000160  9813              LDR      r0,[sp,#0x4c]         ;163
000162  6220              STR      r0,[r4,#0x20]         ;163
000164  9814              LDR      r0,[sp,#0x50]         ;164
000166  6260              STR      r0,[r4,#0x24]         ;164
000168  f8c49028          STR      r9,[r4,#0x28]         ;166
00016c  f8c48010          STR      r8,[r4,#0x10]         ;167
000170  2000              MOVS     r0,#0                 ;171
000172  6160              STR      r0,[r4,#0x14]         ;171
000174  e003              B        |L1.382|
                  |L1.374|
000176  b116              CBZ      r6,|L1.382|
000178  4630              MOV      r0,r6                 ;175
00017a  f7fffffe          BL       GUI_ALLOC_Free
                  |L1.382|
00017e  9802              LDR      r0,[sp,#8]            ;179
000180  b007              ADD      sp,sp,#0x1c
000182  e8bd8ff0          POP      {r4-r11,pc}
;;;181    
                          ENDP

                  GUI_MEMDEV_CreateEx PROC
;;;185    */
;;;186    GUI_MEMDEV_Handle GUI_MEMDEV_CreateEx(int x0, int y0, int xSize, int ySize, int Flags) {
000186  e92d43f0          PUSH     {r4-r9,lr}
00018a  b085              SUB      sp,sp,#0x14
00018c  4606              MOV      r6,r0
00018e  460f              MOV      r7,r1
000190  4690              MOV      r8,r2
000192  4699              MOV      r9,r3
000194  9d0c              LDR      r5,[sp,#0x30]
;;;187      GUI_MEMDEV_Handle hMemDev;
;;;188      const tLCDDEV_APIList * pDeviceAPI;
;;;189      tLCDDEV_Color2Index   * pfColor2Index;
;;;190      tLCDDEV_Index2Color   * pfIndex2Color;
;;;191      tLCDDEV_GetIndexMask  * pfGetIndexMask;
;;;192      GUI_LOCK();
000196  f7fffffe          BL       GUI_Lock
;;;193      #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;194        pDeviceAPI = LCD_aAPI[GUI_Context.SelLayer];
;;;195      #else
;;;196        pDeviceAPI = LCD_aAPI[0];
00019a  4894              LDR      r0,|L1.1004|
00019c  6804              LDR      r4,[r0,#0]  ; LCD_aAPI
;;;197      #endif
;;;198      if (GUI_Context.hDevData == 0) {
00019e  4992              LDR      r1,|L1.1000|
0001a0  f9b10050          LDRSH    r0,[r1,#0x50]  ; GUI_Context
0001a4  b1a8              CBZ      r0,|L1.466|
;;;199        pfColor2Index = GUI_Context.pDeviceAPI->pfColor2Index;    /* LCD_L0_Color2Index; */
;;;200        pfIndex2Color = GUI_Context.pDeviceAPI->pfIndex2Color;    /* LCD_L0_Index2Color; */
;;;201        pfGetIndexMask= GUI_Context.pDeviceAPI->pfGetIndexMask;   /* LCD_L0_GetIndexMask */
;;;202      } else {
;;;203        /* If a memory device is already selected, we create a compatible one by copying its data */
;;;204        GUI_MEMDEV* pDevSel;
;;;205        pDevSel = GUI_MEMDEV_H2P(GUI_Context.hDevData);
0001a6  f7fffffe          BL       GUI_ALLOC_h2p
;;;206        pfColor2Index = pDevSel->pfColor2Index;
0001aa  69c1              LDR      r1,[r0,#0x1c]
;;;207        pfIndex2Color = pDevSel->pfIndex2Color;
0001ac  6a02              LDR      r2,[r0,#0x20]
;;;208        pfGetIndexMask= pDevSel->pfGetIndexMask;
0001ae  6a43              LDR      r3,[r0,#0x24]
                  |L1.432|
;;;209      }
;;;210      hMemDev = GUI_MEMDEV__CreateFixed(x0, y0, xSize, ySize, Flags, pDeviceAPI->pMemDevAPI, 
0001b0  6be0              LDR      r0,[r4,#0x3c]
0001b2  ac01              ADD      r4,sp,#4
0001b4  9500              STR      r5,[sp,#0]
0001b6  c40f              STM      r4!,{r0-r3}
0001b8  464b              MOV      r3,r9
0001ba  4642              MOV      r2,r8
0001bc  4639              MOV      r1,r7
0001be  4630              MOV      r0,r6
0001c0  f7fffffe          BL       GUI_MEMDEV__CreateFixed
0001c4  4604              MOV      r4,r0
;;;211                                        pfColor2Index, pfIndex2Color ,pfGetIndexMask);
;;;212      GUI_UNLOCK();
0001c6  f7fffffe          BL       GUI_Unlock
;;;213      return hMemDev;
;;;214    }
0001ca  b005              ADD      sp,sp,#0x14
0001cc  4620              MOV      r0,r4                 ;213
0001ce  e8bd83f0          POP      {r4-r9,pc}
                  |L1.466|
0001d2  6cc8              LDR      r0,[r1,#0x4c]         ;199  ; GUI_Context
0001d4  6801              LDR      r1,[r0,#0]            ;199
0001d6  6842              LDR      r2,[r0,#4]            ;200
0001d8  6883              LDR      r3,[r0,#8]            ;201
0001da  e7e9              B        |L1.432|
;;;215    /*********************************************************************
                          ENDP

                  GUI_MEMDEV_Create PROC
;;;218    */
;;;219    GUI_MEMDEV_Handle GUI_MEMDEV_Create(int x0, int y0, int xsize, int ysize) {
0001dc  b508              PUSH     {r3,lr}
0001de  469c              MOV      r12,r3
;;;220      return GUI_MEMDEV_CreateEx(x0, y0, xsize, ysize, GUI_MEMDEV_HASTRANS);
0001e0  2300              MOVS     r3,#0
0001e2  9300              STR      r3,[sp,#0]
0001e4  4663              MOV      r3,r12
0001e6  f7fffffe          BL       GUI_MEMDEV_CreateEx
;;;221    }
0001ea  bd08              POP      {r3,pc}
;;;222    
                          ENDP

                  GUI_MEMDEV_Select PROC
;;;226    */
;;;227    GUI_MEMDEV_Handle GUI_MEMDEV_Select(GUI_MEMDEV_Handle hMem) {
0001ec  e92d41f0          PUSH     {r4-r8,lr}
0001f0  4605              MOV      r5,r0
;;;228      GUI_MEMDEV_Handle r;
;;;229      GUI_LOCK();
0001f2  f7fffffe          BL       GUI_Lock
;;;230      r = GUI_Context.hDevData;
0001f6  4c7c              LDR      r4,|L1.1000|
0001f8  f9b46050          LDRSH    r6,[r4,#0x50]  ; GUI_Context
;;;231      if (hMem == 0) {
0001fc  b14d              CBZ      r5,|L1.530|
;;;232        GUI_SelectLCD();
;;;233      } else {
;;;234        GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
0001fe  4628              MOV      r0,r5
000200  f7fffffe          BL       GUI_ALLOC_h2p
000204  4607              MOV      r7,r0
;;;235        #if GUI_WINSUPPORT
;;;236          WM_Deactivate();
000206  f7fffffe          BL       WM_Deactivate
;;;237        #endif
;;;238        /* If LCD was selected Save cliprect */
;;;239        if (GUI_Context.hDevData == 0) {
00020a  f8b40050          LDRH     r0,[r4,#0x50]  ; GUI_Context
00020e  b118              CBZ      r0,|L1.536|
000210  e008              B        |L1.548|
                  |L1.530|
000212  f7fffffe          BL       GUI_SelectLCD
000216  e00b              B        |L1.560|
                  |L1.536|
;;;240          GUI_Context.ClipRectPrev = GUI_Context.ClipRect;
000218  68a0              LDR      r0,[r4,#8]  ; GUI_Context
00021a  f8c40052          STR      r0,[r4,#0x52]  ; GUI_Context
00021e  68e0              LDR      r0,[r4,#0xc]  ; GUI_Context
000220  f8c40056          STR      r0,[r4,#0x56]  ; GUI_Context
                  |L1.548|
;;;241        }
;;;242        GUI_Context.hDevData = hMem;
000224  f8a45050          STRH     r5,[r4,#0x50]
;;;243        GUI_Context.pDeviceAPI = pDev->pAPIList;
000228  6ab8              LDR      r0,[r7,#0x28]
00022a  64e0              STR      r0,[r4,#0x4c]  ; GUI_Context
;;;244        LCD_SetClipRectMax();
00022c  f7fffffe          BL       LCD_SetClipRectMax
                  |L1.560|
;;;245      }
;;;246      GUI_UNLOCK();
000230  f7fffffe          BL       GUI_Unlock
;;;247      return r;
000234  4630              MOV      r0,r6
;;;248    }
000236  e8bd81f0          POP      {r4-r8,pc}
;;;249    
                          ENDP

                  GUI_MEMDEV__WriteToActiveAt PROC
;;;253    */
;;;254    void GUI_MEMDEV__WriteToActiveAt(GUI_MEMDEV_Handle hMem,int x, int y) {
00023a  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
00023e  b08a              SUB      sp,sp,#0x28
;;;255      GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
000240  f7fffffe          BL       GUI_ALLOC_h2p
000244  4680              MOV      r8,r0
;;;256      GUI_USAGE_h hUsage = pDev->hUsage; 
000246  f9b80018          LDRSH    r0,[r8,#0x18]
;;;257      GUI_USAGE*  pUsage;
;;;258      int YSize = pDev->YSize;
00024a  f9b81006          LDRSH    r1,[r8,#6]
00024e  9109              STR      r1,[sp,#0x24]
;;;259      int yi;
;;;260      unsigned int BytesPerLine = pDev->BytesPerLine;
000250  f8d8900c          LDR      r9,[r8,#0xc]
;;;261      unsigned int BitsPerPixel = pDev->BitsPerPixel;
000254  f8d81010          LDR      r1,[r8,#0x10]
000258  9108              STR      r1,[sp,#0x20]
;;;262      int BytesPerPixel = BitsPerPixel >> 3;
00025a  9908              LDR      r1,[sp,#0x20]
00025c  ea4f0ad1          LSR      r10,r1,#3
;;;263      U8* pData = (U8*)(pDev+1);
000260  f108062c          ADD      r6,r8,#0x2c
;;;264      if (hUsage) {
000264  b3f0              CBZ      r0,|L1.740|
;;;265        pUsage = GUI_USAGE_H2P(hUsage);
000266  f7fffffe          BL       GUI_ALLOC_h2p
00026a  4607              MOV      r7,r0
;;;266        for (yi = 0; yi < YSize; yi++) {
00026c  2400              MOVS     r4,#0
00026e  9809              LDR      r0,[sp,#0x24]
000270  2800              CMP      r0,#0
000272  dd61              BLE      |L1.824|
                  |L1.628|
;;;267          int xOff = 0;
000274  2000              MOVS     r0,#0
000276  9007              STR      r0,[sp,#0x1c]
;;;268          int XSize;
;;;269          XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
000278  68b8              LDR      r0,[r7,#8]
00027a  4622              MOV      r2,r4
00027c  a907              ADD      r1,sp,#0x1c
00027e  6943              LDR      r3,[r0,#0x14]
000280  4638              MOV      r0,r7
000282  4798              BLX      r3
000284  4605              MOV      r5,r0
;;;270          if (XSize == pDev->XSize) {
000286  f9b81004          LDRSH    r1,[r8,#4]
00028a  42a9              CMP      r1,r5
00028c  d12b              BNE      |L1.742|
;;;271            /* If the entire line is affected, calculate the number of entire lines */
;;;272            int y0 = yi;
00028e  46a3              MOV      r11,r4
;;;273            while ((GUI_USAGE_GetNextDirty(pUsage, &xOff, yi + 1)) == XSize) {
000290  68b8              LDR      r0,[r7,#8]
000292  1c62              ADDS     r2,r4,#1
000294  a907              ADD      r1,sp,#0x1c
000296  6943              LDR      r3,[r0,#0x14]
000298  4638              MOV      r0,r7
00029a  4798              BLX      r3
00029c  42a8              CMP      r0,r5
00029e  d108              BNE      |L1.690|
                  |L1.672|
;;;274              yi++;
0002a0  1c64              ADDS     r4,r4,#1
0002a2  68b8              LDR      r0,[r7,#8]            ;273
0002a4  1c62              ADDS     r2,r4,#1              ;273
0002a6  a907              ADD      r1,sp,#0x1c           ;273
0002a8  6943              LDR      r3,[r0,#0x14]         ;273
0002aa  4638              MOV      r0,r7                 ;273
0002ac  4798              BLX      r3                    ;273
0002ae  42a8              CMP      r0,r5                 ;273
0002b0  d0f6              BEQ      |L1.672|
                  |L1.690|
;;;275            }
;;;276    		    LCD_DrawBitmap(x, y + y0, pDev->XSize, yi - y0 + 1, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
0002b2  2300              MOVS     r3,#0
0002b4  9808              LDR      r0,[sp,#0x20]
0002b6  9305              STR      r3,[sp,#0x14]
0002b8  2301              MOVS     r3,#1
0002ba  9002              STR      r0,[sp,#8]
0002bc  9301              STR      r3,[sp,#4]
0002be  980c              LDR      r0,[sp,#0x30]
0002c0  9300              STR      r3,[sp,#0]
0002c2  f8cd900c          STR      r9,[sp,#0xc]
0002c6  9604              STR      r6,[sp,#0x10]
0002c8  eba4050b          SUB      r5,r4,r11
0002cc  eb00010b          ADD      r1,r0,r11
0002d0  1c6b              ADDS     r3,r5,#1
0002d2  f9b82004          LDRSH    r2,[r8,#4]
0002d6  980b              LDR      r0,[sp,#0x2c]
0002d8  f7fffffe          BL       LCD_DrawBitmap
;;;277            pData += (yi - y0 + 1) * BytesPerLine;
0002dc  1c68              ADDS     r0,r5,#1
0002de  fb006609          MLA      r6,r0,r9,r6
;;;278          } else {
0002e2  e025              B        |L1.816|
                  |L1.740|
0002e4  e02b              B        |L1.830|
                  |L1.742|
;;;279            /* Draw the partial line which needs to be drawn */
;;;280            for (; XSize; ) {
0002e6  b315              CBZ      r5,|L1.814|
;;;281              LCD_DrawBitmap(x + xOff, y + yi, XSize, 1, 1, 1, BitsPerPixel, BytesPerLine, pData + xOff * BytesPerPixel, NULL);
0002e8  980c              LDR      r0,[sp,#0x30]
0002ea  eb000b04          ADD      r11,r0,r4
                  |L1.750|
0002ee  f8ddc01c          LDR      r12,[sp,#0x1c]
0002f2  2300              MOVS     r3,#0
0002f4  9305              STR      r3,[sp,#0x14]
0002f6  9808              LDR      r0,[sp,#0x20]
0002f8  2301              MOVS     r3,#1
0002fa  fb0c620a          MLA      r2,r12,r10,r6
0002fe  9002              STR      r0,[sp,#8]
000300  9301              STR      r3,[sp,#4]
000302  980b              LDR      r0,[sp,#0x2c]
000304  9204              STR      r2,[sp,#0x10]
000306  f8cd900c          STR      r9,[sp,#0xc]
00030a  9300              STR      r3,[sp,#0]
00030c  4460              ADD      r0,r0,r12
00030e  462a              MOV      r2,r5
000310  4659              MOV      r1,r11
000312  f7fffffe          BL       LCD_DrawBitmap
;;;282              xOff += XSize;
000316  9807              LDR      r0,[sp,#0x1c]
000318  4428              ADD      r0,r0,r5
00031a  9007              STR      r0,[sp,#0x1c]
;;;283              XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
00031c  68b8              LDR      r0,[r7,#8]
00031e  4622              MOV      r2,r4
000320  a907              ADD      r1,sp,#0x1c
000322  6943              LDR      r3,[r0,#0x14]
000324  4638              MOV      r0,r7
000326  4798              BLX      r3
000328  4605              MOV      r5,r0
00032a  2d00              CMP      r5,#0                 ;280
00032c  d1df              BNE      |L1.750|
                  |L1.814|
;;;284            }
;;;285            pData += BytesPerLine;
00032e  444e              ADD      r6,r6,r9
                  |L1.816|
000330  1c64              ADDS     r4,r4,#1              ;266
000332  9809              LDR      r0,[sp,#0x24]         ;266
000334  4284              CMP      r4,r0                 ;266
000336  db9d              BLT      |L1.628|
                  |L1.824|
;;;286          }
;;;287        }
;;;288      } else {
;;;289    		LCD_DrawBitmap(x, y, pDev->XSize, YSize, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
;;;290      }
;;;291    }
000338  b00d              ADD      sp,sp,#0x34
00033a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.830|
00033e  2300              MOVS     r3,#0                 ;289
000340  9305              STR      r3,[sp,#0x14]         ;289
000342  9808              LDR      r0,[sp,#0x20]         ;289
000344  2301              MOVS     r3,#1                 ;289
000346  9002              STR      r0,[sp,#8]            ;289
000348  9301              STR      r3,[sp,#4]            ;289
00034a  9604              STR      r6,[sp,#0x10]         ;289
00034c  9300              STR      r3,[sp,#0]            ;289
00034e  f8cd900c          STR      r9,[sp,#0xc]          ;289
000352  f9b82004          LDRSH    r2,[r8,#4]            ;289
000356  9b09              LDR      r3,[sp,#0x24]         ;289
000358  990c              LDR      r1,[sp,#0x30]         ;289
00035a  980b              LDR      r0,[sp,#0x2c]         ;289
00035c  f7fffffe          BL       LCD_DrawBitmap
000360  b00d              ADD      sp,sp,#0x34
000362  e8bd8ff0          POP      {r4-r11,pc}
;;;292    
                          ENDP

                  GUI_MEMDEV_CopyToLCDAt PROC
;;;296    */
;;;297    void GUI_MEMDEV_CopyToLCDAt(GUI_MEMDEV_Handle hMem, int x, int y) {
000366  e92d41f0          PUSH     {r4-r8,lr}
00036a  b082              SUB      sp,sp,#8
00036c  4607              MOV      r7,r0
00036e  460d              MOV      r5,r1
000370  4616              MOV      r6,r2
;;;298      if (hMem) {
000372  2f00              CMP      r7,#0
000374  d034              BEQ      |L1.992|
;;;299        GUI_MEMDEV_Handle hMemPrev;
;;;300        GUI_MEMDEV* pDevData;
;;;301      #if (GUI_WINSUPPORT)
;;;302        GUI_RECT r;
;;;303      #endif
;;;304      #if GUI_NUM_LAYERS > 1
;;;305        int PrevLayer;
;;;306      #endif
;;;307        GUI_LOCK();
000376  f7fffffe          BL       GUI_Lock
;;;308        hMemPrev = GUI_Context.hDevData;
00037a  481b              LDR      r0,|L1.1000|
00037c  f9b08050          LDRSH    r8,[r0,#0x50]  ; GUI_Context
;;;309        pDevData = (GUI_MEMDEV*) GUI_ALLOC_h2p(hMem);  /* Convert to pointer */
000380  4638              MOV      r0,r7
000382  f7fffffe          BL       GUI_ALLOC_h2p
000386  4604              MOV      r4,r0
;;;310        /* Make sure LCD is selected as device */
;;;311      #if GUI_NUM_LAYERS > 1
;;;312        PrevLayer = GUI_SelectLayer(pDevData->LayerIndex);
;;;313      #else
;;;314        GUI_SelectLCD();  /* Activate LCD */
000388  f7fffffe          BL       GUI_SelectLCD
;;;315      #endif
;;;316        if (x == GUI_POS_AUTO) {
00038c  f64070ff          MOV      r0,#0xfff
000390  1940              ADDS     r0,r0,r5
000392  d103              BNE      |L1.924|
;;;317          x = pDevData->x0;
000394  f9b45000          LDRSH    r5,[r4,#0]
;;;318          y = pDevData->y0;
000398  f9b46002          LDRSH    r6,[r4,#2]
                  |L1.924|
;;;319        }
;;;320      #if (GUI_WINSUPPORT)
;;;321        /* Calculate rectangle */
;;;322        r.x1 = (r.x0 = x) + pDevData->XSize-1;
00039c  88a0              LDRH     r0,[r4,#4]
00039e  1e69              SUBS     r1,r5,#1
0003a0  4408              ADD      r0,r0,r1
0003a2  f8ad5000          STRH     r5,[sp,#0]
0003a6  f8ad0004          STRH     r0,[sp,#4]
;;;323        r.y1 = (r.y0 = y) + pDevData->YSize-1;;
0003aa  88e0              LDRH     r0,[r4,#6]
0003ac  1e71              SUBS     r1,r6,#1
0003ae  4408              ADD      r0,r0,r1
0003b0  f8ad6002          STRH     r6,[sp,#2]
0003b4  f8ad0006          STRH     r0,[sp,#6]
;;;324        /* Do the drawing. Window manager has to be on */
;;;325        WM_Activate();
0003b8  f7fffffe          BL       WM_Activate
;;;326        WM_ITERATE_START(&r) {
0003bc  4668              MOV      r0,sp
0003be  f7fffffe          BL       WM__InitIVRSearch
0003c2  b140              CBZ      r0,|L1.982|
                  |L1.964|
;;;327      #endif
;;;328        GUI_MEMDEV__WriteToActiveAt(hMem, x, y);
0003c4  4632              MOV      r2,r6
0003c6  4629              MOV      r1,r5
0003c8  4638              MOV      r0,r7
0003ca  f7fffffe          BL       GUI_MEMDEV__WriteToActiveAt
;;;329      #if (GUI_WINSUPPORT)
;;;330        } WM_ITERATE_END();
0003ce  f7fffffe          BL       WM__GetNextIVR
0003d2  2800              CMP      r0,#0
0003d4  d1f6              BNE      |L1.964|
                  |L1.982|
;;;331      #endif
;;;332      #if GUI_NUM_LAYERS > 1
;;;333        GUI_SelectLayer(PrevLayer);
;;;334      #endif
;;;335        /* Reactivate previously used device */
;;;336        GUI_MEMDEV_Select(hMemPrev);
0003d6  4640              MOV      r0,r8
0003d8  f7fffffe          BL       GUI_MEMDEV_Select
;;;337        GUI_UNLOCK();
0003dc  f7fffffe          BL       GUI_Unlock
                  |L1.992|
;;;338      }
;;;339    }
0003e0  b002              ADD      sp,sp,#8
0003e2  e8bd81f0          POP      {r4-r8,pc}
0003e6  0000              DCW      0x0000
                  |L1.1000|
                          DCD      GUI_Context
                  |L1.1004|
                          DCD      LCD_aAPI
                          ENDP

                  GUI_MEMDEV_CopyToLCD PROC
;;;344    */
;;;345    void GUI_MEMDEV_CopyToLCD(GUI_MEMDEV_Handle hMem) {
0003f0  4901              LDR      r1,|L1.1016|
;;;346      GUI_MEMDEV_CopyToLCDAt(hMem, GUI_POS_AUTO, GUI_POS_AUTO);
0003f2  460a              MOV      r2,r1
0003f4  e7fe              B        GUI_MEMDEV_CopyToLCDAt
;;;347    }
;;;348    
                          ENDP

0003f6  0000              DCW      0x0000
                  |L1.1016|
                          DCD      0xfffff001
