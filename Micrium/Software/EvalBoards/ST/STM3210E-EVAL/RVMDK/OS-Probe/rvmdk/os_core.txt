; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\os_core.o --depend=.\rvmdk\os_core.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\os_core.crf ..\..\..\..\..\uCOS-II\Source\os_core.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OS_StrCopy PROC
;;;1695   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1696   INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
000000  2200              MOVS     r2,#0
;;;1697   {
;;;1698       INT8U  len;
;;;1699   
;;;1700   
;;;1701       len = 0;
;;;1702       while (*psrc != OS_ASCII_NUL) {
000002  780b              LDRB     r3,[r1,#0]
000004  b143              CBZ      r3,|L1.24|
                  |L1.6|
;;;1703           *pdest++ = *psrc++;
000006  f8113b01          LDRB     r3,[r1],#1
00000a  f8003b01          STRB     r3,[r0],#1
;;;1704           len++;
00000e  1c52              ADDS     r2,r2,#1
000010  b2d2              UXTB     r2,r2
000012  780b              LDRB     r3,[r1,#0]            ;1702
000014  2b00              CMP      r3,#0                 ;1702
000016  d1f6              BNE      |L1.6|
                  |L1.24|
;;;1705       }
;;;1706       *pdest = OS_ASCII_NUL;
000018  2100              MOVS     r1,#0
00001a  7001              STRB     r1,[r0,#0]
;;;1707       return (len);
00001c  4610              MOV      r0,r2
;;;1708   }
00001e  4770              BX       lr
;;;1709   #endif
                          ENDP

                  OSEventNameGet PROC
;;;108    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;109    INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
000020  e92d41f0          PUSH     {r4-r8,lr}
;;;110    {
000024  4605              MOV      r5,r0
000026  460e              MOV      r6,r1
000028  4614              MOV      r4,r2
;;;111        INT8U      len;
;;;112    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;113        OS_CPU_SR  cpu_sr = 0;
;;;114    #endif
;;;115    
;;;116    
;;;117    
;;;118    #if OS_ARG_CHK_EN > 0
;;;119        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;120            return (0);
;;;121        }
;;;122        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;123            *perr = OS_ERR_PEVENT_NULL;
;;;124            return (0);
;;;125        }
;;;126        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;127            *perr = OS_ERR_PNAME_NULL;
;;;128            return (0);
;;;129        }
;;;130    #endif
;;;131        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00002a  48ff              LDR      r0,|L1.1064|
00002c  7880              LDRB     r0,[r0,#2]  ; OSIntNesting
00002e  b120              CBZ      r0,|L1.58|
;;;132            *perr  = OS_ERR_NAME_GET_ISR;
000030  2011              MOVS     r0,#0x11
000032  7020              STRB     r0,[r4,#0]
;;;133            return (0);
000034  2000              MOVS     r0,#0
;;;134        }
;;;135        switch (pevent->OSEventType) {
;;;136            case OS_EVENT_TYPE_SEM:
;;;137            case OS_EVENT_TYPE_MUTEX:
;;;138            case OS_EVENT_TYPE_MBOX:
;;;139            case OS_EVENT_TYPE_Q:
;;;140                 break;
;;;141    
;;;142            default:
;;;143                 *perr = OS_ERR_EVENT_TYPE;
;;;144                 return (0);
;;;145        }
;;;146        OS_ENTER_CRITICAL();
;;;147        len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
;;;148        OS_EXIT_CRITICAL();
;;;149        *perr = OS_ERR_NONE;
;;;150        return (len);
;;;151    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L1.58|
00003a  7828              LDRB     r0,[r5,#0]            ;135
00003c  2801              CMP      r0,#1                 ;135
00003e  d00a              BEQ      |L1.86|
000040  2802              CMP      r0,#2                 ;135
000042  d008              BEQ      |L1.86|
000044  2803              CMP      r0,#3                 ;135
000046  d006              BEQ      |L1.86|
000048  2804              CMP      r0,#4                 ;135
00004a  d004              BEQ      |L1.86|
00004c  2001              MOVS     r0,#1                 ;143
00004e  7020              STRB     r0,[r4,#0]            ;143
000050  2000              MOVS     r0,#0                 ;144
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L1.86|
000056  f7fffffe          BL       OS_CPU_SR_Save
00005a  4607              MOV      r7,r0                 ;146
00005c  f105010f          ADD      r1,r5,#0xf            ;147
000060  4630              MOV      r0,r6                 ;147
000062  f7fffffe          BL       OS_StrCopy
000066  4605              MOV      r5,r0                 ;147
000068  4638              MOV      r0,r7                 ;148
00006a  f7fffffe          BL       OS_CPU_SR_Restore
00006e  2000              MOVS     r0,#0                 ;149
000070  7020              STRB     r0,[r4,#0]            ;149
000072  4628              MOV      r0,r5                 ;150
000074  e8bd81f0          POP      {r4-r8,pc}
;;;152    #endif
                          ENDP

                  OS_StrLen PROC
;;;1727   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1728   INT8U  OS_StrLen (INT8U *psrc)
000078  2100              MOVS     r1,#0
;;;1729   {
;;;1730       INT8U  len;
;;;1731   
;;;1732   
;;;1733       len = 0;
;;;1734       while (*psrc != OS_ASCII_NUL) {
00007a  7802              LDRB     r2,[r0,#0]
00007c  b12a              CBZ      r2,|L1.138|
                  |L1.126|
;;;1735           psrc++;
00007e  1c40              ADDS     r0,r0,#1
;;;1736           len++;
000080  1c49              ADDS     r1,r1,#1
000082  b2c9              UXTB     r1,r1
000084  7802              LDRB     r2,[r0,#0]            ;1734
000086  2a00              CMP      r2,#0                 ;1734
000088  d1f9              BNE      |L1.126|
                  |L1.138|
;;;1737       }
;;;1738       return (len);
00008a  4608              MOV      r0,r1
;;;1739   }
00008c  4770              BX       lr
;;;1740   #endif
                          ENDP

                  OSEventNameSet PROC
;;;182    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;183    void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
00008e  e92d41f0          PUSH     {r4-r8,lr}
;;;184    {
000092  4605              MOV      r5,r0
000094  460e              MOV      r6,r1
000096  4614              MOV      r4,r2
;;;185        INT8U      len;
;;;186    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;187        OS_CPU_SR  cpu_sr = 0;
;;;188    #endif
;;;189    
;;;190    
;;;191    
;;;192    #if OS_ARG_CHK_EN > 0
;;;193        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;194            return;
;;;195        }
;;;196        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;197            *perr = OS_ERR_PEVENT_NULL;
;;;198            return;
;;;199        }
;;;200        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;201            *perr = OS_ERR_PNAME_NULL;
;;;202            return;
;;;203        }
;;;204    #endif
;;;205        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
000098  48e3              LDR      r0,|L1.1064|
00009a  7880              LDRB     r0,[r0,#2]  ; OSIntNesting
00009c  b118              CBZ      r0,|L1.166|
;;;206            *perr = OS_ERR_NAME_SET_ISR;
00009e  2012              MOVS     r0,#0x12
0000a0  7020              STRB     r0,[r4,#0]
;;;207            return;
;;;208        }
;;;209        switch (pevent->OSEventType) {
;;;210            case OS_EVENT_TYPE_SEM:
;;;211            case OS_EVENT_TYPE_MUTEX:
;;;212            case OS_EVENT_TYPE_MBOX:
;;;213            case OS_EVENT_TYPE_Q:
;;;214                 break;
;;;215    
;;;216            default:
;;;217                 *perr = OS_ERR_EVENT_TYPE;
;;;218                 return;
;;;219        }
;;;220        OS_ENTER_CRITICAL();
;;;221        len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
;;;222        if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
;;;223            OS_EXIT_CRITICAL();
;;;224            *perr = OS_ERR_EVENT_NAME_TOO_LONG;
;;;225            return;
;;;226        }
;;;227        (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
;;;228        OS_EXIT_CRITICAL();
;;;229        *perr = OS_ERR_NONE;
;;;230    }
0000a2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.166|
0000a6  7828              LDRB     r0,[r5,#0]            ;209
0000a8  2801              CMP      r0,#1                 ;209
0000aa  d009              BEQ      |L1.192|
0000ac  2802              CMP      r0,#2                 ;209
0000ae  d007              BEQ      |L1.192|
0000b0  2803              CMP      r0,#3                 ;209
0000b2  d005              BEQ      |L1.192|
0000b4  2804              CMP      r0,#4                 ;209
0000b6  d003              BEQ      |L1.192|
0000b8  2001              MOVS     r0,#1                 ;217
0000ba  7020              STRB     r0,[r4,#0]            ;217
0000bc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.192|
0000c0  f7fffffe          BL       OS_CPU_SR_Save
0000c4  4607              MOV      r7,r0                 ;220
0000c6  4630              MOV      r0,r6                 ;221
0000c8  f7fffffe          BL       OS_StrLen
0000cc  280f              CMP      r0,#0xf               ;222
0000ce  d906              BLS      |L1.222|
0000d0  4638              MOV      r0,r7                 ;223
0000d2  f7fffffe          BL       OS_CPU_SR_Restore
0000d6  200b              MOVS     r0,#0xb               ;224
0000d8  7020              STRB     r0,[r4,#0]            ;224
0000da  e8bd81f0          POP      {r4-r8,pc}
                  |L1.222|
0000de  4631              MOV      r1,r6                 ;227
0000e0  f105000f          ADD      r0,r5,#0xf            ;227
0000e4  f7fffffe          BL       OS_StrCopy
0000e8  4638              MOV      r0,r7                 ;228
0000ea  f7fffffe          BL       OS_CPU_SR_Restore
0000ee  2000              MOVS     r0,#0                 ;229
0000f0  7020              STRB     r0,[r4,#0]            ;229
0000f2  e8bd81f0          POP      {r4-r8,pc}
;;;231    #endif
                          ENDP

                  OS_EventTaskRemoveMulti PROC
;;;1163   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;1164   void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
0000f6  b430              PUSH     {r4,r5}
;;;1165                                  OS_EVENT **pevents_multi)
;;;1166   {
;;;1167       OS_EVENT **pevents;
;;;1168       OS_EVENT  *pevent;
;;;1169       INT8U      y;
;;;1170   #if (OS_LOWEST_PRIO <= 63)
;;;1171       INT8U      bity;
;;;1172       INT8U      bitx;
;;;1173   #else
;;;1174       INT16U     bity;
;;;1175       INT16U     bitx;
;;;1176   #endif
;;;1177   
;;;1178   
;;;1179       y       =  ptcb->OSTCBY;
0000f8  f890c034          LDRB     r12,[r0,#0x34]
;;;1180       bity    =  ptcb->OSTCBBitY;
0000fc  f8904036          LDRB     r4,[r0,#0x36]
;;;1181       bitx    =  ptcb->OSTCBBitX;
000100  f8905035          LDRB     r5,[r0,#0x35]
;;;1182       pevents =  pevents_multi;
;;;1183       pevent  = *pevents;
000104  6808              LDR      r0,[r1,#0]
;;;1184       while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
000106  2800              CMP      r0,#0
000108  d00c              BEQ      |L1.292|
                  |L1.266|
;;;1185           pevent->OSEventTbl[y]  &= ~bitx;
00010a  eb00030c          ADD      r3,r0,r12
00010e  7ada              LDRB     r2,[r3,#0xb]
000110  43aa              BICS     r2,r2,r5
000112  72da              STRB     r2,[r3,#0xb]
;;;1186           if (pevent->OSEventTbl[y] == 0) {
000114  b912              CBNZ     r2,|L1.284|
;;;1187               pevent->OSEventGrp &= ~bity;
000116  7a82              LDRB     r2,[r0,#0xa]
000118  43a2              BICS     r2,r2,r4
00011a  7282              STRB     r2,[r0,#0xa]
                  |L1.284|
;;;1188           }
;;;1189           pevents++;
00011c  1d09              ADDS     r1,r1,#4
;;;1190           pevent = *pevents;
00011e  6808              LDR      r0,[r1,#0]
000120  2800              CMP      r0,#0                 ;1184
000122  d1f2              BNE      |L1.266|
                  |L1.292|
;;;1191       }
;;;1192   }
000124  bc30              POP      {r4,r5}
000126  4770              BX       lr
;;;1193   #endif
                          ENDP

                  OS_SchedNew PROC
;;;1647   
;;;1648   static  void  OS_SchedNew (void)
000128  49bf              LDR      r1,|L1.1064|
;;;1649   {
;;;1650   #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
;;;1651       INT8U   y;
;;;1652   
;;;1653   
;;;1654       y             = OSUnMapTbl[OSRdyGrp];
00012a  4ac0              LDR      r2,|L1.1068|
00012c  7988              LDRB     r0,[r1,#6]  ; OSRdyGrp
00012e  5c10              LDRB     r0,[r2,r0]
;;;1655       OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
000130  f101031c          ADD      r3,r1,#0x1c
000134  5c1b              LDRB     r3,[r3,r0]
000136  5cd2              LDRB     r2,[r2,r3]
000138  eb0200c0          ADD      r0,r2,r0,LSL #3
00013c  7148              STRB     r0,[r1,#5]
;;;1656   #else                                            /* We support up to 256 tasks                         */
;;;1657       INT8U   y;
;;;1658       INT16U *ptbl;
;;;1659   
;;;1660   
;;;1661       if ((OSRdyGrp & 0xFF) != 0) {
;;;1662           y = OSUnMapTbl[OSRdyGrp & 0xFF];
;;;1663       } else {
;;;1664           y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
;;;1665       }
;;;1666       ptbl = &OSRdyTbl[y];
;;;1667       if ((*ptbl & 0xFF) != 0) {
;;;1668           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
;;;1669       } else {
;;;1670           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
;;;1671       }
;;;1672   #endif
;;;1673   }
00013e  4770              BX       lr
;;;1674   
                          ENDP

                  OS_Sched PROC
;;;1605   
;;;1606   void  OS_Sched (void)
000140  b570              PUSH     {r4-r6,lr}
;;;1607   {
;;;1608   #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;1609       OS_CPU_SR  cpu_sr = 0;
;;;1610   #endif
;;;1611   
;;;1612   
;;;1613   
;;;1614       OS_ENTER_CRITICAL();
000142  f7fffffe          BL       OS_CPU_SR_Save
000146  4605              MOV      r5,r0
;;;1615       if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
000148  4cb7              LDR      r4,|L1.1064|
00014a  78a0              LDRB     r0,[r4,#2]  ; OSIntNesting
00014c  b998              CBNZ     r0,|L1.374|
;;;1616           if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
00014e  78e0              LDRB     r0,[r4,#3]  ; OSLockNesting
000150  b988              CBNZ     r0,|L1.374|
;;;1617               OS_SchedNew();
000152  f7fffffe          BL       OS_SchedNew
;;;1618               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
000156  7961              LDRB     r1,[r4,#5]  ; OSPrioHighRdy
000158  7920              LDRB     r0,[r4,#4]  ; OSPrioCur
00015a  4281              CMP      r1,r0
00015c  d00b              BEQ      |L1.374|
;;;1619                   OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00015e  48b4              LDR      r0,|L1.1072|
000160  f8501021          LDR      r1,[r0,r1,LSL #2]
000164  62e1              STR      r1,[r4,#0x2c]  ; OSTCBHighRdy
;;;1620   #if OS_TASK_PROFILE_EN > 0
;;;1621                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
000166  6b88              LDR      r0,[r1,#0x38]
000168  1c40              ADDS     r0,r0,#1
00016a  6388              STR      r0,[r1,#0x38]
;;;1622   #endif
;;;1623                   OSCtxSwCtr++;                          /* Increment context switch counter             */
00016c  68e0              LDR      r0,[r4,#0xc]  ; OSCtxSwCtr
00016e  1c40              ADDS     r0,r0,#1
000170  60e0              STR      r0,[r4,#0xc]  ; OSCtxSwCtr
;;;1624                   OS_TASK_SW();                          /* Perform a context switch                     */
000172  f7fffffe          BL       OSCtxSw
                  |L1.374|
;;;1625               }
;;;1626           }
;;;1627       }
;;;1628       OS_EXIT_CRITICAL();
000176  4628              MOV      r0,r5
000178  e8bd4070          POP      {r4-r6,lr}
00017c  f7ffbffe          B.W      OS_CPU_SR_Restore
;;;1629   }
;;;1630   
                          ENDP

                  OS_EventTaskWaitMulti PROC
;;;1090   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;1091   void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
000180  b430              PUSH     {r4,r5}
;;;1092   {
;;;1093       OS_EVENT **pevents;
;;;1094       OS_EVENT  *pevent;
;;;1095       INT8U      y;
;;;1096   
;;;1097   
;;;1098       OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
000182  4ca9              LDR      r4,|L1.1064|
000184  2200              MOVS     r2,#0
000186  6a61              LDR      r1,[r4,#0x24]  ; OSTCBCur
000188  61ca              STR      r2,[r1,#0x1c]
;;;1099       OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
00018a  6208              STR      r0,[r1,#0x20]
;;;1100   
;;;1101       pevents =  pevents_wait;
;;;1102       pevent  = *pevents;
00018c  6801              LDR      r1,[r0,#0]
;;;1103       while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
00018e  b1a9              CBZ      r1,|L1.444|
                  |L1.400|
;;;1104           pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
000190  6a63              LDR      r3,[r4,#0x24]  ; OSTCBCur
000192  f1010c0b          ADD      r12,r1,#0xb
000196  f8932034          LDRB     r2,[r3,#0x34]
00019a  f8933035          LDRB     r3,[r3,#0x35]
00019e  f812500c          LDRB     r5,[r2,r12]
0001a2  432b              ORRS     r3,r3,r5
0001a4  f802300c          STRB     r3,[r2,r12]
;;;1105           pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
0001a8  6a63              LDR      r3,[r4,#0x24]  ; OSTCBCur
0001aa  7a8a              LDRB     r2,[r1,#0xa]
0001ac  f8933036          LDRB     r3,[r3,#0x36]
0001b0  431a              ORRS     r2,r2,r3
0001b2  728a              STRB     r2,[r1,#0xa]
;;;1106           pevents++;
0001b4  1d00              ADDS     r0,r0,#4
;;;1107           pevent = *pevents;
0001b6  6801              LDR      r1,[r0,#0]
0001b8  2900              CMP      r1,#0                 ;1103
0001ba  d1e9              BNE      |L1.400|
                  |L1.444|
;;;1108       }
;;;1109   
;;;1110       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
0001bc  6a60              LDR      r0,[r4,#0x24]  ; OSTCBCur
0001be  f8901034          LDRB     r1,[r0,#0x34]
;;;1111       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
0001c2  4b9c              LDR      r3,|L1.1076|
0001c4  f890c035          LDRB     r12,[r0,#0x35]
0001c8  5c5a              LDRB     r2,[r3,r1]
0001ca  ea22020c          BIC      r2,r2,r12
0001ce  545a              STRB     r2,[r3,r1]
;;;1112       if (OSRdyTbl[y] == 0) {
0001d0  2a00              CMP      r2,#0
0001d2  d105              BNE      |L1.480|
;;;1113           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
0001d4  f8900036          LDRB     r0,[r0,#0x36]
0001d8  79a1              LDRB     r1,[r4,#6]  ; OSRdyGrp
0001da  ea210000          BIC      r0,r1,r0
0001de  71a0              STRB     r0,[r4,#6]
                  |L1.480|
;;;1114       }
;;;1115   }
0001e0  bc30              POP      {r4,r5}
0001e2  4770              BX       lr
;;;1116   #endif
                          ENDP

                  OSEventPendMulti PROC
;;;305    #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;306    INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
0001e4  e92d4fff          PUSH     {r0-r11,lr}
;;;307    {
0001e8  b081              SUB      sp,sp,#4
0001ea  4682              MOV      r10,r0
0001ec  f8dd8038          LDR      r8,[sp,#0x38]
0001f0  460d              MOV      r5,r1
0001f2  4616              MOV      r6,r2
;;;308        OS_EVENT  **pevents;
;;;309        OS_EVENT   *pevent;
;;;310    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;311        OS_Q       *pq;
;;;312    #endif
;;;313        BOOLEAN     events_rdy;
;;;314        INT16U      events_rdy_nbr;
;;;315        INT8U       events_stat;
;;;316    #if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
;;;317        OS_CPU_SR   cpu_sr = 0;
;;;318    #endif
;;;319    
;;;320    
;;;321    
;;;322    #if (OS_ARG_CHK_EN > 0)
;;;323        if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
;;;324            return (0);
;;;325        }
;;;326        if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
;;;327           *perr =  OS_ERR_PEVENT_NULL;
;;;328            return (0);
;;;329        }
;;;330        if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
;;;331           *perr =  OS_ERR_PEVENT_NULL;
;;;332            return (0);
;;;333        }
;;;334        if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
;;;335           *perr =  OS_ERR_PEVENT_NULL;
;;;336            return (0);
;;;337        }
;;;338    #endif
;;;339    
;;;340       *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
0001f4  f04f0900          MOV      r9,#0
0001f8  f8c59000          STR      r9,[r5,#0]
;;;341    
;;;342        pevents     =  pevents_pend;
0001fc  4650              MOV      r0,r10
;;;343        pevent      = *pevents;
0001fe  6801              LDR      r1,[r0,#0]
;;;344        while  (pevent != (OS_EVENT *)0) {
;;;345            switch (pevent->OSEventType) {                  /* Validate event block types                  */
000200  f04f0b01          MOV      r11,#1
000204  b181              CBZ      r1,|L1.552|
                  |L1.518|
000206  7809              LDRB     r1,[r1,#0]
000208  2901              CMP      r1,#1
00020a  d009              BEQ      |L1.544|
00020c  2902              CMP      r1,#2
00020e  d007              BEQ      |L1.544|
000210  2903              CMP      r1,#3
000212  d005              BEQ      |L1.544|
;;;346    #if (OS_SEM_EN  > 0)
;;;347                case OS_EVENT_TYPE_SEM:
;;;348                     break;
;;;349    #endif
;;;350    #if (OS_MBOX_EN > 0)
;;;351                case OS_EVENT_TYPE_MBOX:
;;;352                     break;
;;;353    #endif
;;;354    #if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
;;;355                case OS_EVENT_TYPE_Q:
;;;356                     break;
;;;357    #endif
;;;358    
;;;359                case OS_EVENT_TYPE_MUTEX:                                            
;;;360                case OS_EVENT_TYPE_FLAG:
;;;361                default:           
;;;362                    *perr = OS_ERR_EVENT_TYPE;
000214  f888b000          STRB     r11,[r8,#0]
;;;363                     return (0);
;;;364            }
;;;365            pevents++;
;;;366            pevent = *pevents;
;;;367        }
;;;368    
;;;369        if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
;;;370           *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
;;;371            return (0);
;;;372        }
;;;373        if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
;;;374           *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
;;;375            return (0);
;;;376        }
;;;377    
;;;378    /*$PAGE*/
;;;379        OS_ENTER_CRITICAL();
;;;380        events_rdy     =  OS_FALSE;
;;;381        events_rdy_nbr =  0;
;;;382        events_stat    =  OS_STAT_RDY;
;;;383        pevents        =  pevents_pend;
;;;384        pevent         = *pevents;
;;;385        while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
;;;386            switch (pevent->OSEventType) {
;;;387    #if (OS_SEM_EN > 0)
;;;388                case OS_EVENT_TYPE_SEM:
;;;389                     if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
;;;390                         pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
;;;391                        *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
;;;392                          events_rdy   =  OS_TRUE;
;;;393                        *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
;;;394                          events_rdy_nbr++;
;;;395    
;;;396                     } else {
;;;397                          events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
;;;398                     }
;;;399                     break;
;;;400    #endif
;;;401    
;;;402    #if (OS_MBOX_EN > 0)
;;;403                case OS_EVENT_TYPE_MBOX:
;;;404                     if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
;;;405                                                            /* ... return available message,           ... */
;;;406                        *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
;;;407                         pevent->OSEventPtr  = (void *)0;
;;;408                        *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
;;;409                          events_rdy         =  OS_TRUE;
;;;410                          events_rdy_nbr++;
;;;411    
;;;412                     } else {
;;;413                          events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
;;;414                     }
;;;415                     break;
;;;416    #endif
;;;417    
;;;418    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;419                case OS_EVENT_TYPE_Q:
;;;420                     pq = (OS_Q *)pevent->OSEventPtr;
;;;421                     if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
;;;422                                                            /* ... return available message,           ... */
;;;423                        *pmsgs_rdy++ = (void *)*pq->OSQOut++;
;;;424                         if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
;;;425                             pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
;;;426                         }
;;;427                         pq->OSQEntries--;                  /* Update number of queue entries              */
;;;428                        *pevents_rdy++ = pevent;            /* ... and return available queue event        */
;;;429                          events_rdy   = OS_TRUE;
;;;430                          events_rdy_nbr++;
;;;431    
;;;432                     } else {
;;;433                          events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
;;;434                     }
;;;435                     break;
;;;436    #endif
;;;437    
;;;438                case OS_EVENT_TYPE_MUTEX:                                            
;;;439                case OS_EVENT_TYPE_FLAG:
;;;440                default:           
;;;441                     OS_EXIT_CRITICAL();
;;;442                    *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
;;;443                    *perr        =  OS_ERR_EVENT_TYPE;
;;;444                     return (events_rdy_nbr);
;;;445            }
;;;446            pevents++;
;;;447            pevent = *pevents;
;;;448        }
;;;449    
;;;450        if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
;;;451           *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
;;;452            OS_EXIT_CRITICAL();
;;;453           *perr        =  OS_ERR_NONE;
;;;454            return (events_rdy_nbr);
;;;455        }
;;;456    /*$PAGE*/
;;;457                                                            /* Otherwise, must wait until any event occurs */
;;;458        OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
;;;459                                   OS_STAT_MULTI;           /* ... pend on multiple events                 */
;;;460        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;461        OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
;;;462        OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
;;;463    
;;;464        OS_EXIT_CRITICAL();
;;;465        OS_Sched();                                         /* Find next highest priority task ready       */
;;;466        OS_ENTER_CRITICAL();
;;;467    
;;;468        switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
;;;469            case OS_STAT_PEND_OK:
;;;470            case OS_STAT_PEND_ABORT:
;;;471                 pevent = OSTCBCur->OSTCBEventPtr;
;;;472                 if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
;;;473                    *pevents_rdy++ =  pevent;               /* ... return available event ...              */
;;;474                    *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
;;;475                      events_rdy_nbr++;
;;;476    
;;;477                 } else {                                   /* Else NO event available, handle as timeout  */
;;;478                     OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
;;;479                     OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;480                 }
;;;481    			 break;
;;;482    
;;;483            case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
;;;484            default:                                        /* ... remove task from events' wait lists     */
;;;485                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;486                 break;
;;;487        }
;;;488    
;;;489        switch (OSTCBCur->OSTCBStatPend) {
;;;490            case OS_STAT_PEND_OK:
;;;491                 switch (pevent->OSEventType) {             /* Return event's message                      */
;;;492    #if (OS_SEM_EN > 0)
;;;493                     case OS_EVENT_TYPE_SEM:
;;;494                         *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
;;;495                          break;
;;;496    #endif
;;;497    
;;;498    #if ((OS_MBOX_EN > 0) ||                 \
;;;499        ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
;;;500                     case OS_EVENT_TYPE_MBOX:
;;;501                     case OS_EVENT_TYPE_Q:
;;;502                         *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
;;;503                          break;
;;;504    #endif
;;;505    
;;;506                     case OS_EVENT_TYPE_MUTEX:                                       
;;;507                     case OS_EVENT_TYPE_FLAG:
;;;508                     default:           
;;;509                          OS_EXIT_CRITICAL();
;;;510                         *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
;;;511                         *perr        =  OS_ERR_EVENT_TYPE;
;;;512                          return (events_rdy_nbr);
;;;513                 }
;;;514                *perr = OS_ERR_NONE;
;;;515                 break;
;;;516    
;;;517            case OS_STAT_PEND_ABORT:
;;;518                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
;;;519                *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
;;;520                 break;
;;;521                                                            
;;;522            case OS_STAT_PEND_TO:                                                
;;;523            default:        
;;;524                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
;;;525                *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
;;;526                 break;
;;;527        }
;;;528    
;;;529        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
;;;530        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
;;;531        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
;;;532        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;533        OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
;;;534        OS_EXIT_CRITICAL();
;;;535    
;;;536        return (events_rdy_nbr);
;;;537    }
000218  b005              ADD      sp,sp,#0x14
00021a  2000              MOVS     r0,#0                 ;363
00021c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.544|
000220  1d00              ADDS     r0,r0,#4              ;365
000222  6801              LDR      r1,[r0,#0]            ;366
000224  2900              CMP      r1,#0                 ;344
000226  d1ee              BNE      |L1.518|
                  |L1.552|
000228  487f              LDR      r0,|L1.1064|
00022a  7881              LDRB     r1,[r0,#2]            ;369  ; OSIntNesting
00022c  b131              CBZ      r1,|L1.572|
00022e  2002              MOVS     r0,#2                 ;370
000230  f8880000          STRB     r0,[r8,#0]            ;370
000234  b005              ADD      sp,sp,#0x14
000236  2000              MOVS     r0,#0                 ;371
000238  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.572|
00023c  487a              LDR      r0,|L1.1064|
00023e  78c0              LDRB     r0,[r0,#3]            ;373  ; OSLockNesting
000240  b130              CBZ      r0,|L1.592|
000242  200d              MOVS     r0,#0xd               ;374
000244  f8880000          STRB     r0,[r8,#0]            ;374
000248  b005              ADD      sp,sp,#0x14
00024a  2000              MOVS     r0,#0                 ;375
00024c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.592|
000250  f7fffffe          BL       OS_CPU_SR_Save
000254  9000              STR      r0,[sp,#0]            ;379
000256  2300              MOVS     r3,#0                 ;380
000258  2700              MOVS     r7,#0                 ;381
00025a  2100              MOVS     r1,#0                 ;382
00025c  4652              MOV      r2,r10                ;383
00025e  6814              LDR      r4,[r2,#0]            ;384
000260  b37c              CBZ      r4,|L1.706|
                  |L1.610|
000262  7820              LDRB     r0,[r4,#0]            ;386
000264  2801              CMP      r0,#1                 ;386
000266  d01d              BEQ      |L1.676|
000268  2802              CMP      r0,#2                 ;386
00026a  d02b              BEQ      |L1.708|
00026c  2803              CMP      r0,#3                 ;386
00026e  d00a              BEQ      |L1.646|
000270  9800              LDR      r0,[sp,#0]            ;441
000272  f7fffffe          BL       OS_CPU_SR_Restore
000276  f8c59000          STR      r9,[r5,#0]            ;442
00027a  f888b000          STRB     r11,[r8,#0]           ;443
00027e  b005              ADD      sp,sp,#0x14
000280  4638              MOV      r0,r7                 ;444
000282  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.646|
000286  8920              LDRH     r0,[r4,#8]            ;389
000288  b148              CBZ      r0,|L1.670|
00028a  1e40              SUBS     r0,r0,#1              ;390
00028c  8120              STRH     r0,[r4,#8]            ;390
00028e  f8454b04          STR      r4,[r5],#4            ;391
000292  2301              MOVS     r3,#1                 ;392
000294  f8469b04          STR      r9,[r6],#4            ;393
000298  1c78              ADDS     r0,r7,#1              ;394
00029a  b287              UXTH     r7,r0                 ;394
00029c  e032              B        |L1.772|
                  |L1.670|
00029e  f0410101          ORR      r1,r1,#1              ;397
0002a2  e02f              B        |L1.772|
                  |L1.676|
0002a4  6860              LDR      r0,[r4,#4]            ;404
0002a6  b148              CBZ      r0,|L1.700|
0002a8  f8460b04          STR      r0,[r6],#4            ;406
0002ac  f8c49004          STR      r9,[r4,#4]            ;407
0002b0  f8454b04          STR      r4,[r5],#4            ;408
0002b4  2301              MOVS     r3,#1                 ;409
0002b6  1c78              ADDS     r0,r7,#1              ;410
0002b8  b287              UXTH     r7,r0                 ;410
0002ba  e023              B        |L1.772|
                  |L1.700|
0002bc  f0410102          ORR      r1,r1,#2              ;413
0002c0  e020              B        |L1.772|
                  |L1.706|
0002c2  e023              B        |L1.780|
                  |L1.708|
0002c4  6860              LDR      r0,[r4,#4]            ;420
0002c6  f8b0c016          LDRH     r12,[r0,#0x16]        ;421
0002ca  f1bc0f00          CMP      r12,#0                ;421
0002ce  d017              BEQ      |L1.768|
0002d0  6903              LDR      r3,[r0,#0x10]         ;423
0002d2  f1030c04          ADD      r12,r3,#4             ;423
0002d6  f8c0c010          STR      r12,[r0,#0x10]        ;423
0002da  681b              LDR      r3,[r3,#0]            ;423
0002dc  f8463b04          STR      r3,[r6],#4            ;423
0002e0  f8d0c008          LDR      r12,[r0,#8]           ;424
0002e4  6903              LDR      r3,[r0,#0x10]         ;424
0002e6  4563              CMP      r3,r12                ;424
0002e8  d101              BNE      |L1.750|
0002ea  6843              LDR      r3,[r0,#4]            ;425
0002ec  6103              STR      r3,[r0,#0x10]         ;425
                  |L1.750|
0002ee  8ac3              LDRH     r3,[r0,#0x16]         ;427
0002f0  1e5b              SUBS     r3,r3,#1              ;427
0002f2  82c3              STRH     r3,[r0,#0x16]         ;427
0002f4  f8454b04          STR      r4,[r5],#4            ;428
0002f8  2301              MOVS     r3,#1                 ;429
0002fa  1c78              ADDS     r0,r7,#1              ;430
0002fc  b287              UXTH     r7,r0                 ;430
0002fe  e001              B        |L1.772|
                  |L1.768|
000300  f0410104          ORR      r1,r1,#4              ;433
                  |L1.772|
000304  1d12              ADDS     r2,r2,#4              ;446
000306  6814              LDR      r4,[r2,#0]            ;447
000308  2c00              CMP      r4,#0                 ;385
00030a  d1aa              BNE      |L1.610|
                  |L1.780|
00030c  2b01              CMP      r3,#1                 ;450
00030e  d03f              BEQ      |L1.912|
000310  4845              LDR      r0,|L1.1064|
000312  f0410180          ORR      r1,r1,#0x80           ;458
000316  6a40              LDR      r0,[r0,#0x24]         ;458  ; OSTCBCur
000318  f8902030          LDRB     r2,[r0,#0x30]         ;458
00031c  4311              ORRS     r1,r1,r2              ;458
00031e  f8801030          STRB     r1,[r0,#0x30]         ;458
000322  f8809031          STRB     r9,[r0,#0x31]         ;460
000326  9904              LDR      r1,[sp,#0x10]         ;461
000328  85c1              STRH     r1,[r0,#0x2e]         ;461
00032a  4650              MOV      r0,r10                ;462
00032c  f7fffffe          BL       OS_EventTaskWaitMulti
000330  9800              LDR      r0,[sp,#0]            ;464
000332  f7fffffe          BL       OS_CPU_SR_Restore
000336  f7fffffe          BL       OS_Sched
00033a  f7fffffe          BL       OS_CPU_SR_Save
00033e  9000              STR      r0,[sp,#0]            ;466
000340  4839              LDR      r0,|L1.1064|
000342  6a40              LDR      r0,[r0,#0x24]         ;468  ; OSTCBCur
000344  f8901031          LDRB     r1,[r0,#0x31]         ;468
000348  b369              CBZ      r1,|L1.934|
00034a  2902              CMP      r1,#2                 ;468
00034c  d02b              BEQ      |L1.934|
00034e  4651              MOV      r1,r10                ;485
000350  f7fffffe          BL       OS_EventTaskRemoveMulti
                  |L1.852|
000354  4a34              LDR      r2,|L1.1064|
000356  6a51              LDR      r1,[r2,#0x24]         ;489  ; OSTCBCur
000358  f8910031          LDRB     r0,[r1,#0x31]         ;489
00035c  b388              CBZ      r0,|L1.962|
00035e  2802              CMP      r0,#2                 ;489
000360  d04a              BEQ      |L1.1016|
000362  f8c69000          STR      r9,[r6,#0]            ;524
000366  200a              MOVS     r0,#0xa               ;525
000368  f8880000          STRB     r0,[r8,#0]            ;525
                  |L1.876|
00036c  6a50              LDR      r0,[r2,#0x24]         ;529  ; OSTCBCur
00036e  f8809030          STRB     r9,[r0,#0x30]         ;529
000372  f8809031          STRB     r9,[r0,#0x31]         ;530
000376  f8c0901c          STR      r9,[r0,#0x1c]         ;531
00037a  f8c09020          STR      r9,[r0,#0x20]         ;532
00037e  f8c09024          STR      r9,[r0,#0x24]         ;533
000382  9800              LDR      r0,[sp,#0]            ;534
000384  f7fffffe          BL       OS_CPU_SR_Restore
000388  b005              ADD      sp,sp,#0x14
00038a  4638              MOV      r0,r7                 ;536
00038c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.912|
000390  f8c59000          STR      r9,[r5,#0]            ;451
000394  9800              LDR      r0,[sp,#0]            ;452
000396  f7fffffe          BL       OS_CPU_SR_Restore
00039a  f8889000          STRB     r9,[r8,#0]            ;453
00039e  b005              ADD      sp,sp,#0x14
0003a0  4638              MOV      r0,r7                 ;454
0003a2  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.934|
0003a6  69c4              LDR      r4,[r0,#0x1c]         ;471
0003a8  b12c              CBZ      r4,|L1.950|
0003aa  602c              STR      r4,[r5,#0]            ;473
0003ac  f8459f04          STR      r9,[r5,#4]!           ;474
0003b0  1c78              ADDS     r0,r7,#1              ;475
0003b2  b287              UXTH     r7,r0                 ;475
0003b4  e7ce              B        |L1.852|
                  |L1.950|
0003b6  f880b031          STRB     r11,[r0,#0x31]        ;478
0003ba  4651              MOV      r1,r10                ;479
0003bc  f7fffffe          BL       OS_EventTaskRemoveMulti
0003c0  e7c8              B        |L1.852|
                  |L1.962|
0003c2  e7ff              B        |L1.964|
                  |L1.964|
0003c4  7820              LDRB     r0,[r4,#0]            ;491
0003c6  2801              CMP      r0,#1                 ;491
0003c8  d011              BEQ      |L1.1006|
0003ca  2802              CMP      r0,#2                 ;491
0003cc  d00f              BEQ      |L1.1006|
0003ce  2803              CMP      r0,#3                 ;491
0003d0  d00a              BEQ      |L1.1000|
0003d2  9800              LDR      r0,[sp,#0]            ;509
0003d4  f7fffffe          BL       OS_CPU_SR_Restore
0003d8  f8c59000          STR      r9,[r5,#0]            ;510
0003dc  f888b000          STRB     r11,[r8,#0]           ;511
0003e0  b005              ADD      sp,sp,#0x14
0003e2  4638              MOV      r0,r7                 ;512
0003e4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1000|
0003e8  f8c69000          STR      r9,[r6,#0]            ;494
0003ec  e001              B        |L1.1010|
                  |L1.1006|
0003ee  6a48              LDR      r0,[r1,#0x24]         ;502
0003f0  6030              STR      r0,[r6,#0]            ;502
                  |L1.1010|
0003f2  f8889000          STRB     r9,[r8,#0]            ;514
0003f6  e7b9              B        |L1.876|
                  |L1.1016|
0003f8  f8c69000          STR      r9,[r6,#0]            ;518
0003fc  200e              MOVS     r0,#0xe               ;519
0003fe  f8880000          STRB     r0,[r8,#0]            ;519
000402  e7b3              B        |L1.876|
;;;538    #endif
                          ENDP

                  OS_TaskStatStkChk PROC
;;;1849   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1850   void  OS_TaskStatStkChk (void)
000404  b530              PUSH     {r4,r5,lr}
;;;1851   {
000406  b083              SUB      sp,sp,#0xc
;;;1852       OS_TCB      *ptcb;
;;;1853       OS_STK_DATA  stk_data;
;;;1854       INT8U        err;
;;;1855       INT8U        prio;
;;;1856   
;;;1857   
;;;1858       for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
000408  2400              MOVS     r4,#0
;;;1859           err = OSTaskStkChk(prio, &stk_data);
;;;1860           if (err == OS_ERR_NONE) {
;;;1861               ptcb = OSTCBPrioTbl[prio];
00040a  4d09              LDR      r5,|L1.1072|
                  |L1.1036|
00040c  4669              MOV      r1,sp                 ;1859
00040e  4620              MOV      r0,r4                 ;1859
000410  f7fffffe          BL       OSTaskStkChk
000414  b9a8              CBNZ     r0,|L1.1090|
000416  f8551024          LDR      r1,[r5,r4,LSL #2]
;;;1862               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
00041a  b191              CBZ      r1,|L1.1090|
;;;1863                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00041c  2901              CMP      r1,#1
00041e  d010              BEQ      |L1.1090|
;;;1864   #if OS_TASK_PROFILE_EN > 0
;;;1865                       #if OS_STK_GROWTH == 1
;;;1866                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
000420  68ca              LDR      r2,[r1,#0xc]
000422  6888              LDR      r0,[r1,#8]
000424  e008              B        |L1.1080|
000426  0000              DCW      0x0000
                  |L1.1064|
                          DCD      ||.data||
                  |L1.1068|
                          DCD      ||.constdata||
                  |L1.1072|
                          DCD      ||.bss||+0x540
                  |L1.1076|
                          DCD      ||.data||+0x1c
                  |L1.1080|
000438  eb000082          ADD      r0,r0,r2,LSL #2
00043c  6448              STR      r0,[r1,#0x44]
;;;1867                       #else
;;;1868                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1869                       #endif
;;;1870                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
00043e  9801              LDR      r0,[sp,#4]
000440  6488              STR      r0,[r1,#0x48]
                  |L1.1090|
000442  1c60              ADDS     r0,r4,#1              ;1858
000444  b2c4              UXTB     r4,r0                 ;1858
000446  2c1f              CMP      r4,#0x1f              ;1858
000448  d9e0              BLS      |L1.1036|
;;;1871   #endif
;;;1872                   }
;;;1873               }
;;;1874           }
;;;1875       }
;;;1876   }
00044a  b003              ADD      sp,sp,#0xc
00044c  bd30              POP      {r4,r5,pc}
;;;1877   #endif
                          ENDP

                  OS_TaskStat PROC
;;;1804   #if OS_TASK_STAT_EN > 0
;;;1805   void  OS_TaskStat (void *p_arg)
00044e  4cfd              LDR      r4,|L1.2116|
;;;1806   {
;;;1807   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1808       OS_CPU_SR  cpu_sr = 0;
;;;1809   #endif
;;;1810   
;;;1811   
;;;1812   
;;;1813       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1814       while (OSStatRdy == OS_FALSE) {
000450  7860              LDRB     r0,[r4,#1]  ; OSStatRdy
000452  b928              CBNZ     r0,|L1.1120|
                  |L1.1108|
;;;1815           OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
000454  20c8              MOVS     r0,#0xc8
000456  f7fffffe          BL       OSTimeDly
00045a  7860              LDRB     r0,[r4,#1]            ;1814  ; OSStatRdy
00045c  2800              CMP      r0,#0                 ;1814
00045e  d0f9              BEQ      |L1.1108|
                  |L1.1120|
;;;1816       }
;;;1817       OSIdleCtrMax /= 100L;
000460  49f9              LDR      r1,|L1.2120|
000462  6960              LDR      r0,[r4,#0x14]  ; OSIdleCtrMax
000464  fba11000          UMULL    r1,r0,r1,r0
000468  0940              LSRS     r0,r0,#5
00046a  6160              STR      r0,[r4,#0x14]  ; OSIdleCtrMax
00046c  2500              MOVS     r5,#0                 ;1808
;;;1818       if (OSIdleCtrMax == 0L) {
00046e  b918              CBNZ     r0,|L1.1144|
;;;1819           OSCPUUsage = 0;
000470  7025              STRB     r5,[r4,#0]
;;;1820           (void)OSTaskSuspend(OS_PRIO_SELF);
000472  20ff              MOVS     r0,#0xff
000474  f7fffffe          BL       OSTaskSuspend
                  |L1.1144|
;;;1821       }
;;;1822       for (;;) {
;;;1823           OS_ENTER_CRITICAL();
000478  f7fffffe          BL       OS_CPU_SR_Save
;;;1824           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
00047c  6a21              LDR      r1,[r4,#0x20]  ; OSIdleCtr
00047e  61a1              STR      r1,[r4,#0x18]  ; OSIdleCtrRun
;;;1825           OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
000480  6225              STR      r5,[r4,#0x20]  ; OSIdleCtr
;;;1826           OS_EXIT_CRITICAL();
000482  f7fffffe          BL       OS_CPU_SR_Restore
;;;1827           OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
000486  6961              LDR      r1,[r4,#0x14]  ; OSIdleCtrMax
000488  69a0              LDR      r0,[r4,#0x18]  ; OSIdleCtrRun
00048a  fbb0f0f1          UDIV     r0,r0,r1
00048e  f1c00064          RSB      r0,r0,#0x64
000492  7020              STRB     r0,[r4,#0]
;;;1828           OSTaskStatHook();                        /* Invoke user definable hook                         */
000494  f7fffffe          BL       OSTaskStatHook
;;;1829   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1830           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000498  f7fffffe          BL       OS_TaskStatStkChk
;;;1831   #endif
;;;1832           OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
00049c  2064              MOVS     r0,#0x64
00049e  f7fffffe          BL       OSTimeDly
0004a2  e7e9              B        |L1.1144|
;;;1833       }
;;;1834   }
;;;1835   #endif
                          ENDP

                  OS_InitTaskStat PROC
;;;1433   #if OS_TASK_STAT_EN > 0
;;;1434   static  void  OS_InitTaskStat (void)
0004a4  b500              PUSH     {lr}
;;;1435   {
0004a6  b087              SUB      sp,sp,#0x1c
;;;1436   #if OS_TASK_NAME_SIZE > 7
;;;1437       INT8U  err;
;;;1438   #endif
;;;1439   
;;;1440   
;;;1441   #if OS_TASK_CREATE_EXT_EN > 0
;;;1442       #if OS_STK_GROWTH == 1
;;;1443       (void)OSTaskCreateExt(OS_TaskStat,
0004a8  2303              MOVS     r3,#3
0004aa  2200              MOVS     r2,#0
0004ac  e9cd2303          STRD     r2,r3,[sp,#0xc]
0004b0  f64f73fe          MOV      r3,#0xfffe
0004b4  2180              MOVS     r1,#0x80
0004b6  48e5              LDR      r0,|L1.2124|
0004b8  9300              STR      r3,[sp,#0]
0004ba  9102              STR      r1,[sp,#8]
0004bc  231e              MOVS     r3,#0x1e
0004be  9001              STR      r0,[sp,#4]
0004c0  f50072fe          ADD      r2,r0,#0x1fc
0004c4  2100              MOVS     r1,#0
0004c6  f2af0079          ADR      r0,OS_TaskStat + 1
0004ca  f7fffffe          BL       OSTaskCreateExt
;;;1444                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1445                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
;;;1446                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1447                             OS_TASK_STAT_ID,
;;;1448                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1449                             OS_TASK_STAT_STK_SIZE,
;;;1450                             (void *)0,                                   /* No TCB extension               */
;;;1451                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1452       #else
;;;1453       (void)OSTaskCreateExt(OS_TaskStat,
;;;1454                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1455                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1456                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1457                             OS_TASK_STAT_ID,
;;;1458                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
;;;1459                             OS_TASK_STAT_STK_SIZE,
;;;1460                             (void *)0,                                   /* No TCB extension               */
;;;1461                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1462       #endif
;;;1463   #else
;;;1464       #if OS_STK_GROWTH == 1
;;;1465       (void)OSTaskCreate(OS_TaskStat,
;;;1466                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1467                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
;;;1468                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1469       #else
;;;1470       (void)OSTaskCreate(OS_TaskStat,
;;;1471                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1472                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1473                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1474       #endif
;;;1475   #endif
;;;1476   
;;;1477   #if OS_TASK_NAME_SIZE > 14
;;;1478       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
0004ce  aa06              ADD      r2,sp,#0x18
0004d0  a1df              ADR      r1,|L1.2128|
0004d2  201e              MOVS     r0,#0x1e
0004d4  f7fffffe          BL       OSTaskNameSet
;;;1479   #else
;;;1480   #if OS_TASK_NAME_SIZE > 7
;;;1481       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
;;;1482   #endif
;;;1483   #endif
;;;1484   }
0004d8  b007              ADD      sp,sp,#0x1c
0004da  bd00              POP      {pc}
;;;1485   #endif
                          ENDP

                  OS_TaskIdle PROC
;;;1762   
;;;1763   void  OS_TaskIdle (void *p_arg)
0004dc  4cd9              LDR      r4,|L1.2116|
                  |L1.1246|
;;;1764   {
;;;1765   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1766       OS_CPU_SR  cpu_sr = 0;
;;;1767   #endif
;;;1768   
;;;1769   
;;;1770   
;;;1771       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1772       for (;;) {
;;;1773           OS_ENTER_CRITICAL();
0004de  f7fffffe          BL       OS_CPU_SR_Save
;;;1774           OSIdleCtr++;
0004e2  6a21              LDR      r1,[r4,#0x20]  ; OSIdleCtr
0004e4  1c49              ADDS     r1,r1,#1
0004e6  6221              STR      r1,[r4,#0x20]  ; OSIdleCtr
;;;1775           OS_EXIT_CRITICAL();
0004e8  f7fffffe          BL       OS_CPU_SR_Restore
;;;1776           OSTaskIdleHook();                        /* Call user definable HOOK                           */
0004ec  f7fffffe          BL       OSTaskIdleHook
0004f0  e7f5              B        |L1.1246|
;;;1777       }
;;;1778   }
;;;1779   /*$PAGE*/
                          ENDP

                  OS_InitTaskIdle PROC
;;;1367   
;;;1368   static  void  OS_InitTaskIdle (void)
0004f2  b500              PUSH     {lr}
;;;1369   {
0004f4  b087              SUB      sp,sp,#0x1c
;;;1370   #if OS_TASK_NAME_SIZE > 7
;;;1371       INT8U  err;
;;;1372   #endif
;;;1373   
;;;1374   
;;;1375   #if OS_TASK_CREATE_EXT_EN > 0
;;;1376       #if OS_STK_GROWTH == 1
;;;1377       (void)OSTaskCreateExt(OS_TaskIdle,
0004f6  2303              MOVS     r3,#3
0004f8  2200              MOVS     r2,#0
0004fa  e9cd2303          STRD     r2,r3,[sp,#0xc]
0004fe  f64f73ff          MOV      r3,#0xffff
000502  2180              MOVS     r1,#0x80
000504  48d6              LDR      r0,|L1.2144|
000506  9300              STR      r3,[sp,#0]
000508  9102              STR      r1,[sp,#8]
00050a  231f              MOVS     r3,#0x1f
00050c  9001              STR      r0,[sp,#4]
00050e  f50072fe          ADD      r2,r0,#0x1fc
000512  2100              MOVS     r1,#0
000514  f2af003b          ADR      r0,OS_TaskIdle + 1
000518  f7fffffe          BL       OSTaskCreateExt
;;;1378                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1379                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
;;;1380                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1381                             OS_TASK_IDLE_ID,
;;;1382                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1383                             OS_TASK_IDLE_STK_SIZE,
;;;1384                             (void *)0,                                 /* No TCB extension                     */
;;;1385                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1386       #else
;;;1387       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1388                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1389                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1390                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1391                             OS_TASK_IDLE_ID,
;;;1392                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
;;;1393                             OS_TASK_IDLE_STK_SIZE,
;;;1394                             (void *)0,                                 /* No TCB extension                     */
;;;1395                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1396       #endif
;;;1397   #else
;;;1398       #if OS_STK_GROWTH == 1
;;;1399       (void)OSTaskCreate(OS_TaskIdle,
;;;1400                          (void *)0,
;;;1401                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
;;;1402                          OS_TASK_IDLE_PRIO);
;;;1403       #else
;;;1404       (void)OSTaskCreate(OS_TaskIdle,
;;;1405                          (void *)0,
;;;1406                          &OSTaskIdleStk[0],
;;;1407                          OS_TASK_IDLE_PRIO);
;;;1408       #endif
;;;1409   #endif
;;;1410   
;;;1411   #if OS_TASK_NAME_SIZE > 14
;;;1412       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
00051c  aa06              ADD      r2,sp,#0x18
00051e  a1d1              ADR      r1,|L1.2148|
000520  201f              MOVS     r0,#0x1f
000522  f7fffffe          BL       OSTaskNameSet
;;;1413   #else
;;;1414   #if OS_TASK_NAME_SIZE > 7
;;;1415       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
;;;1416   #endif
;;;1417   #endif
;;;1418   }
000526  b007              ADD      sp,sp,#0x1c
000528  bd00              POP      {pc}
;;;1419   /*$PAGE*/
                          ENDP

                  OS_MemClr PROC
;;;1548   
;;;1549   void  OS_MemClr (INT8U *pdest, INT16U size)
00052a  2900              CMP      r1,#0
;;;1550   {
;;;1551       while (size > 0) {
00052c  d006              BEQ      |L1.1340|
00052e  2200              MOVS     r2,#0                 ;1550
                  |L1.1328|
;;;1552           *pdest++ = (INT8U)0;
000530  f8002b01          STRB     r2,[r0],#1
;;;1553           size--;
000534  1e49              SUBS     r1,r1,#1
000536  b289              UXTH     r1,r1
000538  2900              CMP      r1,#0                 ;1551
00053a  d1f9              BNE      |L1.1328|
                  |L1.1340|
;;;1554       }
;;;1555   }
00053c  4770              BX       lr
;;;1556   /*$PAGE*/
                          ENDP

                  OS_InitEventList PROC
;;;1240   
;;;1241   static  void  OS_InitEventList (void)
00053e  b510              PUSH     {r4,lr}
;;;1242   {
;;;1243   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
;;;1244   #if (OS_MAX_EVENTS > 1)
;;;1245       INT16U     i;
;;;1246       OS_EVENT  *pevent1;
;;;1247       OS_EVENT  *pevent2;
;;;1248   
;;;1249   
;;;1250       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000540  f44f71a0          MOV      r1,#0x140
000544  48cb              LDR      r0,|L1.2164|
000546  f7fffffe          BL       OS_MemClr
;;;1251       pevent1 = &OSEventTbl[0];
00054a  48ca              LDR      r0,|L1.2164|
;;;1252       pevent2 = &OSEventTbl[1];
00054c  4604              MOV      r4,r0
00054e  f1040220          ADD      r2,r4,#0x20
;;;1253       for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
000552  2100              MOVS     r1,#0
000554  2300              MOVS     r3,#0
;;;1254           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1255           pevent1->OSEventPtr     = pevent2;
;;;1256   #if OS_EVENT_NAME_SIZE > 1
;;;1257           pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
000556  f04f0c3f          MOV      r12,#0x3f
                  |L1.1370|
00055a  7003              STRB     r3,[r0,#0]            ;1254
00055c  6042              STR      r2,[r0,#4]            ;1255
00055e  f880c00f          STRB     r12,[r0,#0xf]
;;;1258           pevent1->OSEventName[1] = OS_ASCII_NUL;
000562  7403              STRB     r3,[r0,#0x10]
;;;1259   #endif
;;;1260           pevent1++;
000564  3020              ADDS     r0,r0,#0x20
;;;1261           pevent2++;
000566  3220              ADDS     r2,r2,#0x20
000568  1c49              ADDS     r1,r1,#1              ;1253
00056a  b289              UXTH     r1,r1                 ;1253
00056c  2909              CMP      r1,#9                 ;1253
00056e  d3f4              BCC      |L1.1370|
;;;1262       }
;;;1263       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
000570  7003              STRB     r3,[r0,#0]
;;;1264       pevent1->OSEventPtr             = (OS_EVENT *)0;
000572  6043              STR      r3,[r0,#4]
;;;1265   #if OS_EVENT_NAME_SIZE > 1
;;;1266       pevent1->OSEventName[0]         = '?';
000574  f880c00f          STRB     r12,[r0,#0xf]
;;;1267       pevent1->OSEventName[1]         = OS_ASCII_NUL;
000578  7403              STRB     r3,[r0,#0x10]
;;;1268   #endif
;;;1269       OSEventFreeList                 = &OSEventTbl[0];
00057a  48b2              LDR      r0,|L1.2116|
00057c  6104              STR      r4,[r0,#0x10]  ; OSEventFreeList
;;;1270   #else
;;;1271       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1272       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1273       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1274   #if OS_EVENT_NAME_SIZE > 1
;;;1275       OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
;;;1276       OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
;;;1277   #endif
;;;1278   #endif
;;;1279   #endif
;;;1280   }
00057e  bd10              POP      {r4,pc}
;;;1281   /*$PAGE*/
                          ENDP

                  OS_InitTCBList PROC
;;;1499   
;;;1500   static  void  OS_InitTCBList (void)
000580  b510              PUSH     {r4,lr}
;;;1501   {
;;;1502       INT8U    i;
;;;1503       OS_TCB  *ptcb1;
;;;1504       OS_TCB  *ptcb2;
;;;1505   
;;;1506   
;;;1507       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000582  f44f61fd          MOV      r1,#0x7e8
000586  48bc              LDR      r0,|L1.2168|
000588  f7fffffe          BL       OS_MemClr
;;;1508       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00058c  2180              MOVS     r1,#0x80
00058e  48bb              LDR      r0,|L1.2172|
000590  f7fffffe          BL       OS_MemClr
;;;1509       ptcb1 = &OSTCBTbl[0];
000594  48b8              LDR      r0,|L1.2168|
;;;1510       ptcb2 = &OSTCBTbl[1];
000596  4604              MOV      r4,r0
000598  f104025c          ADD      r2,r4,#0x5c
;;;1511       for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
00059c  2100              MOVS     r1,#0
00059e  2300              MOVS     r3,#0
;;;1512           ptcb1->OSTCBNext = ptcb2;
;;;1513   #if OS_TASK_NAME_SIZE > 1
;;;1514           ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
0005a0  f04f0c3f          MOV      r12,#0x3f
                  |L1.1444|
0005a4  6142              STR      r2,[r0,#0x14]         ;1512
0005a6  f880c04c          STRB     r12,[r0,#0x4c]
;;;1515           ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
0005aa  f880304d          STRB     r3,[r0,#0x4d]
;;;1516   #endif
;;;1517           ptcb1++;
0005ae  305c              ADDS     r0,r0,#0x5c
;;;1518           ptcb2++;
0005b0  325c              ADDS     r2,r2,#0x5c
0005b2  1c49              ADDS     r1,r1,#1              ;1511
0005b4  b2c9              UXTB     r1,r1                 ;1511
0005b6  2915              CMP      r1,#0x15              ;1511
0005b8  d3f4              BCC      |L1.1444|
;;;1519       }
;;;1520       ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
0005ba  6143              STR      r3,[r0,#0x14]
;;;1521   #if OS_TASK_NAME_SIZE > 1
;;;1522       ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
0005bc  f880c04c          STRB     r12,[r0,#0x4c]
;;;1523       ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
0005c0  f880304d          STRB     r3,[r0,#0x4d]
;;;1524   #endif
;;;1525       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
0005c4  489f              LDR      r0,|L1.2116|
0005c6  6303              STR      r3,[r0,#0x30]  ; OSTCBList
;;;1526       OSTCBFreeList           = &OSTCBTbl[0];
0005c8  6284              STR      r4,[r0,#0x28]  ; OSTCBFreeList
;;;1527   }
0005ca  bd10              POP      {r4,pc}
;;;1528   /*$PAGE*/
                          ENDP

                  OS_InitRdyList PROC
;;;1330   
;;;1331   static  void  OS_InitRdyList (void)
0005cc  4b9d              LDR      r3,|L1.2116|
;;;1332   {
;;;1333       INT8U    i;
;;;1334   #if OS_LOWEST_PRIO <= 63
;;;1335       INT8U   *prdytbl;
;;;1336   #else
;;;1337       INT16U  *prdytbl;
;;;1338   #endif
;;;1339   
;;;1340   
;;;1341       OSRdyGrp      = 0;                                     /* Clear the ready list                     */
0005ce  2200              MOVS     r2,#0
0005d0  719a              STRB     r2,[r3,#6]
;;;1342       prdytbl       = &OSRdyTbl[0];
0005d2  f103011c          ADD      r1,r3,#0x1c
;;;1343       for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
0005d6  2000              MOVS     r0,#0
                  |L1.1496|
;;;1344           *prdytbl++ = 0;
0005d8  f8012b01          STRB     r2,[r1],#1
0005dc  1c40              ADDS     r0,r0,#1              ;1343
0005de  b2c0              UXTB     r0,r0                 ;1343
0005e0  2804              CMP      r0,#4                 ;1343
0005e2  d3f9              BCC      |L1.1496|
;;;1345       }
;;;1346   
;;;1347       OSPrioCur     = 0;
0005e4  711a              STRB     r2,[r3,#4]
;;;1348       OSPrioHighRdy = 0;
0005e6  715a              STRB     r2,[r3,#5]
;;;1349   
;;;1350       OSTCBHighRdy  = (OS_TCB *)0;
0005e8  62da              STR      r2,[r3,#0x2c]  ; OSTCBHighRdy
;;;1351       OSTCBCur      = (OS_TCB *)0;
0005ea  625a              STR      r2,[r3,#0x24]  ; OSTCBCur
;;;1352   }
0005ec  4770              BX       lr
;;;1353   
                          ENDP

                  OS_InitMisc PROC
;;;1294   
;;;1295   static  void  OS_InitMisc (void)
0005ee  4895              LDR      r0,|L1.2116|
;;;1296   {
;;;1297   #if OS_TIME_GET_SET_EN > 0
;;;1298       OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
0005f0  2100              MOVS     r1,#0
0005f2  6341              STR      r1,[r0,#0x34]  ; OSTime
;;;1299   #endif
;;;1300   
;;;1301       OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
0005f4  7081              STRB     r1,[r0,#2]
;;;1302       OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
0005f6  70c1              STRB     r1,[r0,#3]
;;;1303   
;;;1304       OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
0005f8  7201              STRB     r1,[r0,#8]
;;;1305   
;;;1306       OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
0005fa  71c1              STRB     r1,[r0,#7]
;;;1307   
;;;1308       OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
0005fc  60c1              STR      r1,[r0,#0xc]  ; OSCtxSwCtr
;;;1309       OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
0005fe  6201              STR      r1,[r0,#0x20]  ; OSIdleCtr
;;;1310   
;;;1311   #if OS_TASK_STAT_EN > 0
;;;1312       OSIdleCtrRun  = 0L;
000600  6181              STR      r1,[r0,#0x18]  ; OSIdleCtrRun
;;;1313       OSIdleCtrMax  = 0L;
000602  6141              STR      r1,[r0,#0x14]  ; OSIdleCtrMax
;;;1314       OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
000604  7041              STRB     r1,[r0,#1]
;;;1315   #endif
;;;1316   }
000606  4770              BX       lr
;;;1317   /*$PAGE*/
                          ENDP

                  OSInit PROC
;;;553    
;;;554    void  OSInit (void)
000608  b510              PUSH     {r4,lr}
;;;555    {
;;;556        OSInitHookBegin();                                           /* Call port specific initialization code   */
00060a  f7fffffe          BL       OSInitHookBegin
;;;557    
;;;558        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
00060e  f7fffffe          BL       OS_InitMisc
;;;559    
;;;560        OS_InitRdyList();                                            /* Initialize the Ready List                */
000612  f7fffffe          BL       OS_InitRdyList
;;;561    
;;;562        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
000616  f7fffffe          BL       OS_InitTCBList
;;;563    
;;;564        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00061a  f7fffffe          BL       OS_InitEventList
;;;565    
;;;566    #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
;;;567        OS_FlagInit();                                               /* Initialize the event flag structures     */
00061e  f7fffffe          BL       OS_FlagInit
;;;568    #endif
;;;569    
;;;570    #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
;;;571        OS_MemInit();                                                /* Initialize the memory manager            */
;;;572    #endif
;;;573    
;;;574    #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
;;;575        OS_QInit();                                                  /* Initialize the message queue structures  */
000622  f7fffffe          BL       OS_QInit
;;;576    #endif
;;;577    
;;;578        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
000626  f7fffffe          BL       OS_InitTaskIdle
;;;579    #if OS_TASK_STAT_EN > 0
;;;580        OS_InitTaskStat();                                           /* Create the Statistic Task                */
00062a  f7fffffe          BL       OS_InitTaskStat
;;;581    #endif
;;;582    
;;;583    #if OS_TMR_EN > 0
;;;584        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;585    #endif
;;;586    
;;;587        OSInitHookEnd();                                             /* Call port specific init. code            */
00062e  f7fffffe          BL       OSInitHookEnd
;;;588    
;;;589    #if OS_DEBUG_EN > 0
;;;590        OSDebugInit();
000632  e8bd4010          POP      {r4,lr}
000636  f7ffbffe          B.W      OSDebugInit
;;;591    #endif
;;;592    }
;;;593    /*$PAGE*/
                          ENDP

                  OSIntEnter PROC
;;;618    
;;;619    void  OSIntEnter (void)
00063a  4982              LDR      r1,|L1.2116|
;;;620    {
;;;621        if (OSRunning == OS_TRUE) {
00063c  79c8              LDRB     r0,[r1,#7]  ; OSRunning
00063e  2801              CMP      r0,#1
000640  d104              BNE      |L1.1612|
;;;622            if (OSIntNesting < 255u) {
000642  7888              LDRB     r0,[r1,#2]  ; OSIntNesting
000644  28ff              CMP      r0,#0xff
000646  d201              BCS      |L1.1612|
;;;623                OSIntNesting++;                      /* Increment ISR nesting level                        */
000648  1c40              ADDS     r0,r0,#1
00064a  7088              STRB     r0,[r1,#2]
                  |L1.1612|
;;;624            }
;;;625        }
;;;626    }
00064c  4770              BX       lr
;;;627    /*$PAGE*/
                          ENDP

                  OSIntExit PROC
;;;646    
;;;647    void  OSIntExit (void)
00064e  b570              PUSH     {r4-r6,lr}
;;;648    {
;;;649    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;650        OS_CPU_SR  cpu_sr = 0;
;;;651    #endif
;;;652    
;;;653    
;;;654    
;;;655        if (OSRunning == OS_TRUE) {
000650  4c7c              LDR      r4,|L1.2116|
000652  79e0              LDRB     r0,[r4,#7]  ; OSRunning
000654  2801              CMP      r0,#1
000656  d121              BNE      |L1.1692|
;;;656            OS_ENTER_CRITICAL();
000658  f7fffffe          BL       OS_CPU_SR_Save
00065c  4605              MOV      r5,r0
;;;657            if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
00065e  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
000660  b109              CBZ      r1,|L1.1638|
;;;658                OSIntNesting--;
000662  1e48              SUBS     r0,r1,#1
000664  70a0              STRB     r0,[r4,#2]
                  |L1.1638|
;;;659            }
;;;660            if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
000666  78a0              LDRB     r0,[r4,#2]  ; OSIntNesting
000668  b998              CBNZ     r0,|L1.1682|
;;;661                if (OSLockNesting == 0) {                      /* ... and not locked.                      */
00066a  78e0              LDRB     r0,[r4,#3]  ; OSLockNesting
00066c  b988              CBNZ     r0,|L1.1682|
;;;662                    OS_SchedNew();
00066e  f7fffffe          BL       OS_SchedNew
;;;663                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000672  7961              LDRB     r1,[r4,#5]  ; OSPrioHighRdy
000674  7920              LDRB     r0,[r4,#4]  ; OSPrioCur
000676  4281              CMP      r1,r0
000678  d00b              BEQ      |L1.1682|
;;;664                        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
00067a  4880              LDR      r0,|L1.2172|
00067c  f8501021          LDR      r1,[r0,r1,LSL #2]
000680  62e1              STR      r1,[r4,#0x2c]  ; OSTCBHighRdy
;;;665    #if OS_TASK_PROFILE_EN > 0
;;;666                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
000682  6b88              LDR      r0,[r1,#0x38]
000684  1c40              ADDS     r0,r0,#1
000686  6388              STR      r0,[r1,#0x38]
;;;667    #endif
;;;668                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
000688  68e0              LDR      r0,[r4,#0xc]  ; OSCtxSwCtr
00068a  1c40              ADDS     r0,r0,#1
00068c  60e0              STR      r0,[r4,#0xc]  ; OSCtxSwCtr
;;;669                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
00068e  f7fffffe          BL       OSIntCtxSw
                  |L1.1682|
;;;670                    }
;;;671                }
;;;672            }
;;;673            OS_EXIT_CRITICAL();
000692  4628              MOV      r0,r5
000694  e8bd4070          POP      {r4-r6,lr}
000698  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1692|
;;;674        }
;;;675    }
00069c  bd70              POP      {r4-r6,pc}
;;;676    /*$PAGE*/
                          ENDP

                  OSSchedLock PROC
;;;693    #if OS_SCHED_LOCK_EN > 0
;;;694    void  OSSchedLock (void)
00069e  b510              PUSH     {r4,lr}
;;;695    {
;;;696    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;697        OS_CPU_SR  cpu_sr = 0;
;;;698    #endif
;;;699    
;;;700    
;;;701    
;;;702        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
0006a0  4c68              LDR      r4,|L1.2116|
0006a2  79e0              LDRB     r0,[r4,#7]  ; OSRunning
0006a4  2801              CMP      r0,#1
0006a6  d10c              BNE      |L1.1730|
;;;703            OS_ENTER_CRITICAL();
0006a8  f7fffffe          BL       OS_CPU_SR_Save
;;;704            if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
0006ac  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
0006ae  b921              CBNZ     r1,|L1.1722|
;;;705                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
0006b0  78e1              LDRB     r1,[r4,#3]  ; OSLockNesting
0006b2  29ff              CMP      r1,#0xff
0006b4  d201              BCS      |L1.1722|
;;;706                    OSLockNesting++;                 /* Increment lock nesting level                       */
0006b6  1c49              ADDS     r1,r1,#1
0006b8  70e1              STRB     r1,[r4,#3]
                  |L1.1722|
;;;707                }
;;;708            }
;;;709            OS_EXIT_CRITICAL();
0006ba  e8bd4010          POP      {r4,lr}
0006be  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1730|
;;;710        }
;;;711    }
0006c2  bd10              POP      {r4,pc}
;;;712    #endif
                          ENDP

                  OSSchedUnlock PROC
;;;730    #if OS_SCHED_LOCK_EN > 0
;;;731    void  OSSchedUnlock (void)
0006c4  b510              PUSH     {r4,lr}
;;;732    {
;;;733    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;734        OS_CPU_SR  cpu_sr = 0;
;;;735    #endif
;;;736    
;;;737    
;;;738    
;;;739        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
0006c6  4c5f              LDR      r4,|L1.2116|
0006c8  79e0              LDRB     r0,[r4,#7]  ; OSRunning
0006ca  2801              CMP      r0,#1
0006cc  d11a              BNE      |L1.1796|
;;;740            OS_ENTER_CRITICAL();
0006ce  f7fffffe          BL       OS_CPU_SR_Save
;;;741            if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
0006d2  78e1              LDRB     r1,[r4,#3]  ; OSLockNesting
0006d4  b191              CBZ      r1,|L1.1788|
;;;742                OSLockNesting--;                               /* Decrement lock nesting level             */
0006d6  1e49              SUBS     r1,r1,#1
0006d8  b2c9              UXTB     r1,r1
0006da  70e1              STRB     r1,[r4,#3]
;;;743                if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
0006dc  b119              CBZ      r1,|L1.1766|
;;;744                    if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
;;;745                        OS_EXIT_CRITICAL();
;;;746                        OS_Sched();                            /* See if a HPT is ready                    */
;;;747                    } else {
;;;748                        OS_EXIT_CRITICAL();
;;;749                    }
;;;750                } else {
;;;751                    OS_EXIT_CRITICAL();
0006de  e8bd4010          POP      {r4,lr}
0006e2  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1766|
0006e6  78a1              LDRB     r1,[r4,#2]            ;744  ; OSIntNesting
0006e8  b119              CBZ      r1,|L1.1778|
0006ea  e8bd4010          POP      {r4,lr}               ;748
0006ee  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1778|
0006f2  f7fffffe          BL       OS_CPU_SR_Restore
0006f6  e8bd4010          POP      {r4,lr}               ;746
0006fa  e7fe              B        OS_Sched
                  |L1.1788|
;;;752                }
;;;753            } else {
;;;754                OS_EXIT_CRITICAL();
0006fc  e8bd4010          POP      {r4,lr}
000700  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1796|
;;;755            }
;;;756        }
;;;757    }
000704  bd10              POP      {r4,pc}
;;;758    #endif
                          ENDP

                  OSStart PROC
;;;780    
;;;781    void  OSStart (void)
000706  b510              PUSH     {r4,lr}
;;;782    {
;;;783        if (OSRunning == OS_FALSE) {
000708  4c4e              LDR      r4,|L1.2116|
00070a  79e0              LDRB     r0,[r4,#7]  ; OSRunning
00070c  2800              CMP      r0,#0
00070e  d10c              BNE      |L1.1834|
;;;784            OS_SchedNew();                               /* Find highest priority's task priority number   */
000710  f7fffffe          BL       OS_SchedNew
;;;785            OSPrioCur     = OSPrioHighRdy;
000714  7960              LDRB     r0,[r4,#5]  ; OSPrioHighRdy
000716  7120              STRB     r0,[r4,#4]
;;;786            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000718  4958              LDR      r1,|L1.2172|
00071a  f8510020          LDR      r0,[r1,r0,LSL #2]
00071e  62e0              STR      r0,[r4,#0x2c]  ; OSTCBHighRdy
;;;787            OSTCBCur      = OSTCBHighRdy;
000720  6260              STR      r0,[r4,#0x24]  ; OSTCBCur
;;;788            OSStartHighRdy();                            /* Execute target specific code to start task     */
000722  e8bd4010          POP      {r4,lr}
000726  f7ffbffe          B.W      OSStartHighRdy
                  |L1.1834|
;;;789        }
;;;790    }
00072a  bd10              POP      {r4,pc}
;;;791    /*$PAGE*/
                          ENDP

                  OSStatInit PROC
;;;812    #if OS_TASK_STAT_EN > 0
;;;813    void  OSStatInit (void)
00072c  b510              PUSH     {r4,lr}
;;;814    {
;;;815    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;816        OS_CPU_SR  cpu_sr = 0;
;;;817    #endif
;;;818    
;;;819    
;;;820    
;;;821        OSTimeDly(2);                                /* Synchronize with clock tick                        */
00072e  2002              MOVS     r0,#2
000730  f7fffffe          BL       OSTimeDly
;;;822        OS_ENTER_CRITICAL();
000734  f7fffffe          BL       OS_CPU_SR_Save
;;;823        OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
000738  4c42              LDR      r4,|L1.2116|
00073a  2100              MOVS     r1,#0
00073c  6221              STR      r1,[r4,#0x20]  ; OSIdleCtr
;;;824        OS_EXIT_CRITICAL();
00073e  f7fffffe          BL       OS_CPU_SR_Restore
;;;825        OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
000742  2064              MOVS     r0,#0x64
000744  f7fffffe          BL       OSTimeDly
;;;826        OS_ENTER_CRITICAL();
000748  f7fffffe          BL       OS_CPU_SR_Save
;;;827        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
00074c  6a21              LDR      r1,[r4,#0x20]  ; OSIdleCtr
00074e  6161              STR      r1,[r4,#0x14]  ; OSIdleCtrMax
;;;828        OSStatRdy    = OS_TRUE;
000750  2101              MOVS     r1,#1
000752  7061              STRB     r1,[r4,#1]
;;;829        OS_EXIT_CRITICAL();
000754  e8bd4010          POP      {r4,lr}
000758  f7ffbffe          B.W      OS_CPU_SR_Restore
;;;830    }
;;;831    #endif
                          ENDP

                  OSTimeTick PROC
;;;846    
;;;847    void  OSTimeTick (void)
00075c  e92d41f0          PUSH     {r4-r8,lr}
;;;848    {
;;;849        OS_TCB    *ptcb;
;;;850    #if OS_TICK_STEP_EN > 0
;;;851        BOOLEAN    step;
;;;852    #endif
;;;853    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
;;;854        OS_CPU_SR  cpu_sr = 0;
;;;855    #endif
;;;856    
;;;857    
;;;858    
;;;859    #if OS_TIME_TICK_HOOK_EN > 0
;;;860        OSTimeTickHook();                                      /* Call user definable hook                     */
000760  f7fffffe          BL       OSTimeTickHook
;;;861    #endif
;;;862    #if OS_TIME_GET_SET_EN > 0
;;;863        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000764  f7fffffe          BL       OS_CPU_SR_Save
;;;864        OSTime++;
000768  4d36              LDR      r5,|L1.2116|
00076a  6b69              LDR      r1,[r5,#0x34]  ; OSTime
00076c  1c49              ADDS     r1,r1,#1
00076e  6369              STR      r1,[r5,#0x34]  ; OSTime
;;;865        OS_EXIT_CRITICAL();
000770  f7fffffe          BL       OS_CPU_SR_Restore
;;;866    #endif
;;;867        if (OSRunning == OS_TRUE) {
000774  79e8              LDRB     r0,[r5,#7]  ; OSRunning
000776  2801              CMP      r0,#1
000778  d14b              BNE      |L1.2066|
;;;868    #if OS_TICK_STEP_EN > 0
;;;869            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
00077a  7a68              LDRB     r0,[r5,#9]  ; OSTickStepState
00077c  2601              MOVS     r6,#1                 ;867
00077e  2700              MOVS     r7,#0                 ;854
000780  b1c0              CBZ      r0,|L1.1972|
000782  2801              CMP      r0,#1
000784  d018              BEQ      |L1.1976|
000786  2802              CMP      r0,#2
000788  d018              BEQ      |L1.1980|
;;;870                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;871                     step = OS_TRUE;
;;;872                     break;
;;;873    
;;;874                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;875                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
;;;876                     break;
;;;877    
;;;878                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;879                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
;;;880                     OSTickStepState = OS_TICK_STEP_WAIT;
;;;881                     break;
;;;882    
;;;883                default:                                       /* Invalid case, correct situation              */
;;;884                     step            = OS_TRUE;
00078a  2001              MOVS     r0,#1
;;;885                     OSTickStepState = OS_TICK_STEP_DIS;
00078c  726f              STRB     r7,[r5,#9]
                  |L1.1934|
;;;886                     break;
;;;887            }
;;;888            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
00078e  2800              CMP      r0,#0
000790  d03f              BEQ      |L1.2066|
;;;889                return;
;;;890            }
;;;891    #endif
;;;892            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
000792  6b2c              LDR      r4,[r5,#0x30]  ; OSTCBList
;;;893            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
000794  f8940032          LDRB     r0,[r4,#0x32]
000798  281f              CMP      r0,#0x1f
00079a  d03a              BEQ      |L1.2066|
;;;894                OS_ENTER_CRITICAL();
;;;895                if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
;;;896                    if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
;;;897                                                               /* Check for timeout                            */
;;;898                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;899                            ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;900                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;901                        } else {
;;;902                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;903                        }
;;;904    
;;;905                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;906                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;907                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00079c  f8df80e0          LDR      r8,|L1.2176|
                  |L1.1952|
0007a0  f7fffffe          BL       OS_CPU_SR_Save
0007a4  8de1              LDRH     r1,[r4,#0x2e]         ;895
0007a6  b369              CBZ      r1,|L1.2052|
0007a8  1e49              SUBS     r1,r1,#1              ;896
0007aa  0409              LSLS     r1,r1,#16             ;896
0007ac  0c09              LSRS     r1,r1,#16             ;896
0007ae  85e1              STRH     r1,[r4,#0x2e]         ;896
0007b0  d007              BEQ      |L1.1986|
0007b2  e027              B        |L1.2052|
                  |L1.1972|
0007b4  2001              MOVS     r0,#1                 ;871
0007b6  e7ea              B        |L1.1934|
                  |L1.1976|
0007b8  2000              MOVS     r0,#0                 ;875
0007ba  e7e8              B        |L1.1934|
                  |L1.1980|
0007bc  2001              MOVS     r0,#1                 ;879
0007be  726e              STRB     r6,[r5,#9]            ;880
0007c0  e7e5              B        |L1.1934|
                  |L1.1986|
0007c2  f8941030          LDRB     r1,[r4,#0x30]         ;898
0007c6  f0110f37          TST      r1,#0x37              ;898
0007ca  d006              BEQ      |L1.2010|
0007cc  f0210137          BIC      r1,r1,#0x37           ;899
0007d0  f8841030          STRB     r1,[r4,#0x30]         ;899
0007d4  f8846031          STRB     r6,[r4,#0x31]         ;900
0007d8  e001              B        |L1.2014|
                  |L1.2010|
0007da  f8847031          STRB     r7,[r4,#0x31]         ;902
                  |L1.2014|
0007de  f8941030          LDRB     r1,[r4,#0x30]         ;905
0007e2  f0110f08          TST      r1,#8                 ;905
0007e6  d10d              BNE      |L1.2052|
0007e8  f8941036          LDRB     r1,[r4,#0x36]         ;906
0007ec  79aa              LDRB     r2,[r5,#6]            ;906  ; OSRdyGrp
0007ee  4311              ORRS     r1,r1,r2              ;906
0007f0  71a9              STRB     r1,[r5,#6]            ;906
0007f2  f8941034          LDRB     r1,[r4,#0x34]
0007f6  f8943035          LDRB     r3,[r4,#0x35]
0007fa  f8182001          LDRB     r2,[r8,r1]
0007fe  431a              ORRS     r2,r2,r3
000800  f8082001          STRB     r2,[r8,r1]
                  |L1.2052|
;;;908                        }
;;;909                    }
;;;910                }
;;;911                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
000804  6964              LDR      r4,[r4,#0x14]
;;;912                OS_EXIT_CRITICAL();
000806  f7fffffe          BL       OS_CPU_SR_Restore
00080a  f8940032          LDRB     r0,[r4,#0x32]         ;893
00080e  281f              CMP      r0,#0x1f              ;893
000810  d1c6              BNE      |L1.1952|
                  |L1.2066|
;;;913            }
;;;914        }
;;;915    }
000812  e8bd81f0          POP      {r4-r8,pc}
;;;916    
                          ENDP

                  OSVersion PROC
;;;931    
;;;932    INT16U  OSVersion (void)
000816  f44f708f          MOV      r0,#0x11e
;;;933    {
;;;934        return (OS_VERSION);
;;;935    }
00081a  4770              BX       lr
;;;936    
                          ENDP

                  OS_Dummy PROC
;;;950    #if OS_TASK_DEL_EN > 0
;;;951    void  OS_Dummy (void)
00081c  4770              BX       lr
;;;952    {
;;;953    }
;;;954    #endif
                          ENDP

                  OS_EventTaskRemove PROC
;;;1133   #if (OS_EVENT_EN)
;;;1134   void  OS_EventTaskRemove (OS_TCB   *ptcb,
00081e  f8902034          LDRB     r2,[r0,#0x34]
;;;1135                             OS_EVENT *pevent)
;;;1136   {
;;;1137       INT8U  y;
;;;1138   
;;;1139   
;;;1140       y                       =  ptcb->OSTCBY;
;;;1141       pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
000822  f890c035          LDRB     r12,[r0,#0x35]
000826  188b              ADDS     r3,r1,r2
000828  7ada              LDRB     r2,[r3,#0xb]
00082a  ea22020c          BIC      r2,r2,r12
00082e  72da              STRB     r2,[r3,#0xb]
;;;1142       if (pevent->OSEventTbl[y] == 0) {
000830  2a00              CMP      r2,#0
000832  d105              BNE      |L1.2112|
;;;1143           pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
000834  7a8a              LDRB     r2,[r1,#0xa]
000836  f8900036          LDRB     r0,[r0,#0x36]
00083a  ea220000          BIC      r0,r2,r0
00083e  7288              STRB     r0,[r1,#0xa]
                  |L1.2112|
;;;1144       }
;;;1145   }
000840  4770              BX       lr
000842  0000              DCW      0x0000
                  |L1.2116|
                          DCD      ||.data||
                  |L1.2120|
                          DCD      0x51eb851f
                  |L1.2124|
                          DCD      ||.bss||+0x140
                  |L1.2128|
000850  75432f4f          DCB      "uC/OS-II Stat",0
000854  532d4949
000858  20537461
00085c  7400    
00085e  00                DCB      0
00085f  00                DCB      0
                  |L1.2144|
                          DCD      ||.bss||+0x340
                  |L1.2148|
000864  75432f4f          DCB      "uC/OS-II Idle",0
000868  532d4949
00086c  2049646c
000870  6500    
000872  00                DCB      0
000873  00                DCB      0
                  |L1.2164|
                          DCD      ||.bss||
                  |L1.2168|
                          DCD      ||.bss||+0x5c0
                  |L1.2172|
                          DCD      ||.bss||+0x540
                  |L1.2176|
                          DCD      ||.data||+0x1c
                          ENDP

                  OS_EventTaskRdy PROC
;;;984    #if (OS_EVENT_EN)
;;;985    INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
000884  b570              PUSH     {r4-r6,lr}
;;;986    {
000886  4605              MOV      r5,r0
000888  468c              MOV      r12,r1
;;;987        OS_TCB  *ptcb;
;;;988        INT8U    y;
;;;989        INT8U    x;
;;;990        INT8U    prio;
;;;991    #if OS_LOWEST_PRIO > 63
;;;992        INT16U  *ptbl;
;;;993    #endif
;;;994    
;;;995    
;;;996    #if OS_LOWEST_PRIO <= 63
;;;997        y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
00088a  7aa8              LDRB     r0,[r5,#0xa]
00088c  4978              LDR      r1,|L1.2672|
00088e  5c08              LDRB     r0,[r1,r0]
;;;998        x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000890  182c              ADDS     r4,r5,r0
000892  7ae4              LDRB     r4,[r4,#0xb]
000894  5d09              LDRB     r1,[r1,r4]
;;;999        prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
000896  eb0101c0          ADD      r1,r1,r0,LSL #3
00089a  b2ce              UXTB     r6,r1
;;;1000   #else
;;;1001       if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
;;;1002           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
;;;1003       } else {
;;;1004           y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
;;;1005       }
;;;1006       ptbl = &pevent->OSEventTbl[y];
;;;1007       if ((*ptbl & 0xFF) != 0) {
;;;1008           x = OSUnMapTbl[*ptbl & 0xFF];
;;;1009       } else {
;;;1010           x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
;;;1011       }
;;;1012       prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
;;;1013   #endif
;;;1014   
;;;1015       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
00089c  4975              LDR      r1,|L1.2676|
00089e  f8514026          LDR      r4,[r1,r6,LSL #2]
;;;1016       ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
0008a2  2100              MOVS     r1,#0
0008a4  85e1              STRH     r1,[r4,#0x2e]
;;;1017   #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
;;;1018       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
0008a6  f8c4c024          STR      r12,[r4,#0x24]
;;;1019   #else
;;;1020       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1021   #endif
;;;1022       ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
0008aa  f8941030          LDRB     r1,[r4,#0x30]
0008ae  4391              BICS     r1,r1,r2
0008b0  f8841030          STRB     r1,[r4,#0x30]
;;;1023       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
0008b4  f8843031          STRB     r3,[r4,#0x31]
;;;1024                                                           /* See if task is ready (could be susp'd)      */
;;;1025       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
0008b8  f0110f08          TST      r1,#8
0008bc  d10b              BNE      |L1.2262|
;;;1026           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
0008be  496e              LDR      r1,|L1.2680|
0008c0  f8942036          LDRB     r2,[r4,#0x36]
0008c4  798b              LDRB     r3,[r1,#6]  ; OSRdyGrp
0008c6  431a              ORRS     r2,r2,r3
0008c8  718a              STRB     r2,[r1,#6]
;;;1027           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
0008ca  311c              ADDS     r1,r1,#0x1c
0008cc  f8943035          LDRB     r3,[r4,#0x35]
0008d0  5c0a              LDRB     r2,[r1,r0]
0008d2  431a              ORRS     r2,r2,r3
0008d4  540a              STRB     r2,[r1,r0]
                  |L1.2262|
;;;1028       }
;;;1029   
;;;1030       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
0008d6  4629              MOV      r1,r5
0008d8  4620              MOV      r0,r4
0008da  f7fffffe          BL       OS_EventTaskRemove
;;;1031   #if (OS_EVENT_MULTI_EN > 0)
;;;1032       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
0008de  6a21              LDR      r1,[r4,#0x20]
0008e0  b119              CBZ      r1,|L1.2282|
;;;1033           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
0008e2  4620              MOV      r0,r4
0008e4  f7fffffe          BL       OS_EventTaskRemoveMulti
;;;1034           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
0008e8  61e5              STR      r5,[r4,#0x1c]
                  |L1.2282|
;;;1035       }
;;;1036   #endif
;;;1037   
;;;1038       return (prio);
0008ea  4630              MOV      r0,r6
;;;1039   }
0008ec  bd70              POP      {r4-r6,pc}
;;;1040   #endif
                          ENDP

                  OS_EventTaskWait PROC
;;;1056   #if (OS_EVENT_EN)
;;;1057   void  OS_EventTaskWait (OS_EVENT *pevent)
0008ee  b410              PUSH     {r4}
;;;1058   {
;;;1059       INT8U  y;
;;;1060   
;;;1061   
;;;1062       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
0008f0  f8dfc184          LDR      r12,|L1.2680|
0008f4  f8dc1024          LDR      r1,[r12,#0x24]  ; OSTCBCur
0008f8  61c8              STR      r0,[r1,#0x1c]
;;;1063   
;;;1064       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
0008fa  f8912034          LDRB     r2,[r1,#0x34]
0008fe  f100030b          ADD      r3,r0,#0xb
000902  f8911035          LDRB     r1,[r1,#0x35]
000906  5cd4              LDRB     r4,[r2,r3]
000908  4321              ORRS     r1,r1,r4
00090a  54d1              STRB     r1,[r2,r3]
;;;1065       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00090c  f8dc1024          LDR      r1,[r12,#0x24]  ; OSTCBCur
000910  7a82              LDRB     r2,[r0,#0xa]
000912  f8913036          LDRB     r3,[r1,#0x36]
000916  431a              ORRS     r2,r2,r3
000918  7282              STRB     r2,[r0,#0xa]
;;;1066   
;;;1067       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00091a  f8910034          LDRB     r0,[r1,#0x34]
;;;1068       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
00091e  f10c031c          ADD      r3,r12,#0x1c
000922  f8914035          LDRB     r4,[r1,#0x35]
000926  5c1a              LDRB     r2,[r3,r0]
000928  43a2              BICS     r2,r2,r4
00092a  541a              STRB     r2,[r3,r0]
;;;1069       if (OSRdyTbl[y] == 0) {
00092c  2a00              CMP      r2,#0
00092e  d107              BNE      |L1.2368|
;;;1070           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
000930  f8910036          LDRB     r0,[r1,#0x36]
000934  f89c1006          LDRB     r1,[r12,#6]  ; OSRdyGrp
000938  ea210000          BIC      r0,r1,r0
00093c  f88c0006          STRB     r0,[r12,#6]
                  |L1.2368|
;;;1071       }
;;;1072   }
000940  bc10              POP      {r4}
000942  4770              BX       lr
;;;1073   #endif
                          ENDP

                  OS_EventWaitListInit PROC
;;;1208   #if (OS_EVENT_EN)
;;;1209   void  OS_EventWaitListInit (OS_EVENT *pevent)
000944  2200              MOVS     r2,#0
;;;1210   {
;;;1211   #if OS_LOWEST_PRIO <= 63
;;;1212       INT8U  *ptbl;
;;;1213   #else
;;;1214       INT16U *ptbl;
;;;1215   #endif
;;;1216       INT8U   i;
;;;1217   
;;;1218   
;;;1219       pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
000946  7282              STRB     r2,[r0,#0xa]
;;;1220       ptbl               = &pevent->OSEventTbl[0];
000948  300b              ADDS     r0,r0,#0xb
;;;1221   
;;;1222       for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
00094a  2100              MOVS     r1,#0
                  |L1.2380|
;;;1223           *ptbl++ = 0;
00094c  f8002b01          STRB     r2,[r0],#1
000950  1c49              ADDS     r1,r1,#1              ;1222
000952  b2c9              UXTB     r1,r1                 ;1222
000954  2904              CMP      r1,#4                 ;1222
000956  d3f9              BCC      |L1.2380|
;;;1224       }
;;;1225   }
000958  4770              BX       lr
;;;1226   #endif
                          ENDP

                  OS_MemCopy PROC
;;;1580   
;;;1581   void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
00095a  2a00              CMP      r2,#0
;;;1582   {
;;;1583       while (size > 0) {
00095c  d007              BEQ      |L1.2414|
                  |L1.2398|
;;;1584           *pdest++ = *psrc++;
00095e  f8113b01          LDRB     r3,[r1],#1
000962  f8003b01          STRB     r3,[r0],#1
;;;1585           size--;
000966  1e52              SUBS     r2,r2,#1
000968  b292              UXTH     r2,r2
00096a  2a00              CMP      r2,#0                 ;1583
00096c  d1f7              BNE      |L1.2398|
                  |L1.2414|
;;;1586       }
;;;1587   }
00096e  4770              BX       lr
;;;1588   /*$PAGE*/
                          ENDP

                  OS_TCBInit PROC
;;;1921   
;;;1922   INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
000970  e92d5fff          PUSH     {r0-r12,lr}
;;;1923   {
000974  4606              MOV      r6,r0
000976  460d              MOV      r5,r1
000978  4693              MOV      r11,r2
00097a  f8dd9040          LDR      r9,[sp,#0x40]
00097e  f8dd803c          LDR      r8,[sp,#0x3c]
000982  9f0e              LDR      r7,[sp,#0x38]
;;;1924       OS_TCB    *ptcb;
;;;1925   #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;1926       OS_CPU_SR  cpu_sr = 0;
;;;1927   #endif
;;;1928   
;;;1929   
;;;1930   
;;;1931       OS_ENTER_CRITICAL();
000984  f7fffffe          BL       OS_CPU_SR_Save
;;;1932       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
000988  f8dfa0ec          LDR      r10,|L1.2680|
00098c  f8da4028          LDR      r4,[r10,#0x28]  ; OSTCBFreeList
;;;1933       if (ptcb != (OS_TCB *)0) {
000990  b3ec              CBZ      r4,|L1.2574|
;;;1934           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000992  6961              LDR      r1,[r4,#0x14]
000994  f8ca1028          STR      r1,[r10,#0x28]  ; OSTCBFreeList
;;;1935           OS_EXIT_CRITICAL();
000998  f7fffffe          BL       OS_CPU_SR_Restore
;;;1936           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
00099c  6025              STR      r5,[r4,#0]
;;;1937           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00099e  f8846032          STRB     r6,[r4,#0x32]
;;;1938           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
0009a2  2500              MOVS     r5,#0
0009a4  f8845030          STRB     r5,[r4,#0x30]
;;;1939           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
0009a8  f8845031          STRB     r5,[r4,#0x31]
;;;1940           ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
0009ac  85e5              STRH     r5,[r4,#0x2e]
;;;1941   
;;;1942   #if OS_TASK_CREATE_EXT_EN > 0
;;;1943           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
0009ae  f8c48004          STR      r8,[r4,#4]
;;;1944           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
0009b2  60e7              STR      r7,[r4,#0xc]
;;;1945           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
0009b4  f8c4b008          STR      r11,[r4,#8]
;;;1946           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
0009b8  f8a49010          STRH     r9,[r4,#0x10]
;;;1947           ptcb->OSTCBId            = id;                     /* Store task ID                            */
0009bc  9803              LDR      r0,[sp,#0xc]
0009be  8260              STRH     r0,[r4,#0x12]
;;;1948   #else
;;;1949           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1950           stk_size                 = stk_size;
;;;1951           pbos                     = pbos;
;;;1952           opt                      = opt;
;;;1953           id                       = id;
;;;1954   #endif
;;;1955   
;;;1956   #if OS_TASK_DEL_EN > 0
;;;1957           ptcb->OSTCBDelReq        = OS_ERR_NONE;
0009c0  f8845037          STRB     r5,[r4,#0x37]
;;;1958   #endif
;;;1959   
;;;1960   #if OS_LOWEST_PRIO <= 63
;;;1961           ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
0009c4  08f0              LSRS     r0,r6,#3
0009c6  f8840034          STRB     r0,[r4,#0x34]
;;;1962           ptcb->OSTCBX             = (INT8U)(prio & 0x07);
0009ca  f0060107          AND      r1,r6,#7
0009ce  f8841033          STRB     r1,[r4,#0x33]
;;;1963           ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
0009d2  2201              MOVS     r2,#1
0009d4  fa02f000          LSL      r0,r2,r0
0009d8  f8840036          STRB     r0,[r4,#0x36]
;;;1964           ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
0009dc  fa02f001          LSL      r0,r2,r1
0009e0  f8840035          STRB     r0,[r4,#0x35]
;;;1965   #else
;;;1966           ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
;;;1967           ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
;;;1968           ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
;;;1969           ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
;;;1970   #endif
;;;1971   
;;;1972   #if (OS_EVENT_EN)
;;;1973           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
0009e4  61e5              STR      r5,[r4,#0x1c]
;;;1974   #if (OS_EVENT_MULTI_EN > 0)
;;;1975           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
0009e6  6225              STR      r5,[r4,#0x20]
;;;1976   #endif
;;;1977   #endif
;;;1978   
;;;1979   #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
;;;1980           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
0009e8  62a5              STR      r5,[r4,#0x28]
;;;1981   #endif
;;;1982   
;;;1983   #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;1984           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
0009ea  6265              STR      r5,[r4,#0x24]
;;;1985   #endif
;;;1986   
;;;1987   #if OS_TASK_PROFILE_EN > 0
;;;1988           ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
0009ec  63a5              STR      r5,[r4,#0x38]
;;;1989           ptcb->OSTCBCyclesStart = 0L;
0009ee  6425              STR      r5,[r4,#0x40]
;;;1990           ptcb->OSTCBCyclesTot   = 0L;
0009f0  63e5              STR      r5,[r4,#0x3c]
;;;1991           ptcb->OSTCBStkBase     = (OS_STK *)0;
0009f2  6465              STR      r5,[r4,#0x44]
;;;1992           ptcb->OSTCBStkUsed     = 0L;
0009f4  64a5              STR      r5,[r4,#0x48]
;;;1993   #endif
;;;1994   
;;;1995   #if OS_TASK_NAME_SIZE > 1
;;;1996           ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
0009f6  203f              MOVS     r0,#0x3f
0009f8  f884004c          STRB     r0,[r4,#0x4c]
;;;1997           ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
0009fc  f884504d          STRB     r5,[r4,#0x4d]
;;;1998   #endif
;;;1999   
;;;2000           OSTCBInitHook(ptcb);
000a00  4620              MOV      r0,r4
000a02  f7fffffe          BL       OSTCBInitHook
;;;2001   
;;;2002           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
000a06  4620              MOV      r0,r4
000a08  f7fffffe          BL       OSTaskCreateHook
;;;2003   
;;;2004           OS_ENTER_CRITICAL();
000a0c  e000              B        |L1.2576|
                  |L1.2574|
000a0e  e029              B        |L1.2660|
                  |L1.2576|
000a10  f7fffffe          BL       OS_CPU_SR_Save
000a14  4602              MOV      r2,r0
;;;2005           OSTCBPrioTbl[prio] = ptcb;
000a16  4817              LDR      r0,|L1.2676|
000a18  f8404026          STR      r4,[r0,r6,LSL #2]
;;;2006           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
000a1c  f8da0030          LDR      r0,[r10,#0x30]  ; OSTCBList
000a20  6160              STR      r0,[r4,#0x14]
;;;2007           ptcb->OSTCBPrev    = (OS_TCB *)0;
000a22  61a5              STR      r5,[r4,#0x18]
;;;2008           if (OSTCBList != (OS_TCB *)0) {
000a24  b100              CBZ      r0,|L1.2600|
;;;2009               OSTCBList->OSTCBPrev = ptcb;
000a26  6184              STR      r4,[r0,#0x18]
                  |L1.2600|
;;;2010           }
;;;2011           OSTCBList               = ptcb;
000a28  f8ca4030          STR      r4,[r10,#0x30]  ; OSTCBList
;;;2012           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
000a2c  f8940036          LDRB     r0,[r4,#0x36]
000a30  f89a1006          LDRB     r1,[r10,#6]  ; OSRdyGrp
000a34  4308              ORRS     r0,r0,r1
000a36  f88a0006          STRB     r0,[r10,#6]
;;;2013           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000a3a  f8940034          LDRB     r0,[r4,#0x34]
000a3e  490f              LDR      r1,|L1.2684|
000a40  f894c035          LDRB     r12,[r4,#0x35]
000a44  5c0b              LDRB     r3,[r1,r0]
000a46  ea43030c          ORR      r3,r3,r12
000a4a  540b              STRB     r3,[r1,r0]
;;;2014           OSTaskCtr++;                                       /* Increment the #tasks counter             */
000a4c  f89a0008          LDRB     r0,[r10,#8]  ; OSTaskCtr
000a50  1c40              ADDS     r0,r0,#1
000a52  f88a0008          STRB     r0,[r10,#8]
;;;2015           OS_EXIT_CRITICAL();
000a56  4610              MOV      r0,r2
000a58  f7fffffe          BL       OS_CPU_SR_Restore
;;;2016           return (OS_ERR_NONE);
;;;2017       }
;;;2018       OS_EXIT_CRITICAL();
;;;2019       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2020   }
000a5c  b004              ADD      sp,sp,#0x10
000a5e  2000              MOVS     r0,#0                 ;2016
000a60  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.2660|
000a64  f7fffffe          BL       OS_CPU_SR_Restore
000a68  b004              ADD      sp,sp,#0x10
000a6a  2042              MOVS     r0,#0x42              ;2019
000a6c  e8bd9ff0          POP      {r4-r12,pc}
                          ENDP

                  |L1.2672|
                          DCD      ||.constdata||
                  |L1.2676|
                          DCD      ||.bss||+0x540
                  |L1.2680|
                          DCD      ||.data||
                  |L1.2684|
                          DCD      ||.data||+0x1c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=6

                  OSEventTbl
                          %        320
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        128
                  OSTCBTbl
                          %        2024

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=6

                          EXPORTAS ||area_number.4||, ||.bss||
                  OSFlagTbl
                          %        140

                          AREA ||area_number.5||, DATA, NOINIT, ALIGN=6

                          EXPORTAS ||area_number.5||, ||.bss||
                  OSQTbl
                          %        240

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCPUUsage
000000  00                DCB      0x00
                  OSStatRdy
000001  00                DCB      0x00
                  OSIntNesting
000002  00                DCB      0x00
                  OSLockNesting
000003  00                DCB      0x00
                  OSPrioCur
000004  00                DCB      0x00
                  OSPrioHighRdy
000005  00                DCB      0x00
                  OSRdyGrp
000006  00                DCB      0x00
                  OSRunning
000007  00                DCB      0x00
                  OSTaskCtr
000008  00                DCB      0x00
                  OSTickStepState
000009  000000            DCB      0x00,0x00,0x00
                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSRdyTbl
                          DCD      0x00000000
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000

                          AREA ||area_number.9||, DATA, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.data||
                  OSFlagFreeList
                          DCD      0x00000000

                          AREA ||area_number.10||, DATA, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.data||
                  OSQFreeList
                          DCD      0x00000000
