; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\user_task_hmc.o --depend=.\rvmdk\user_task_hmc.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\user_task_hmc.crf ..\..\..\..\..\User\user_task_hmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Delayms PROC
;;;59     */
;;;60      void Delayms(int m)
000000  2800              CMP      r0,#0
;;;61     {
;;;62       int i;
;;;63       
;;;64       for(; m != 0; m--)	
000002  d008              BEQ      |L1.22|
;;;65            for (i=0; i<50000; i++);
000004  f24c3250          MOV      r2,#0xc350
                  |L1.8|
000008  2100              MOVS     r1,#0
                  |L1.10|
00000a  1c49              ADDS     r1,r1,#1
00000c  4291              CMP      r1,r2
00000e  dbfc              BLT      |L1.10|
000010  1e40              SUBS     r0,r0,#1              ;64
000012  2800              CMP      r0,#0                 ;64
000014  d1f8              BNE      |L1.8|
                  |L1.22|
;;;66     }
000016  4770              BX       lr
;;;67     
                          ENDP

                  I2C_delay PROC
;;;74     ****************************************************************************** */
;;;75     void I2C_delay(void)
000018  201e              MOVS     r0,#0x1e
                  |L1.26|
;;;76     {
;;;77     		
;;;78        char i=30; //这里可以优化速度	，经测试最低到5还能写入
;;;79        while(i) 
;;;80        { 
;;;81          i--; 
00001a  1e40              SUBS     r0,r0,#1
00001c  b2c0              UXTB     r0,r0
00001e  2800              CMP      r0,#0                 ;79
000020  d1fb              BNE      |L1.26|
;;;82        }  
;;;83     }
000022  4770              BX       lr
;;;84     
                          ENDP

                  delay5ms PROC
;;;85     void delay5ms(void)
000024  f2413088          MOV      r0,#0x1388
                  |L1.40|
;;;86     {
;;;87     		
;;;88        int i=5000;  
;;;89        while(i) 
;;;90        { 
;;;91          i--; 
000028  1e40              SUBS     r0,r0,#1
00002a  2800              CMP      r0,#0                 ;89
00002c  d1fc              BNE      |L1.40|
;;;92        }  
;;;93     }
00002e  4770              BX       lr
;;;94     
                          ENDP

                  I2C_GPIO_Config PROC
;;;95     void I2C_GPIO_Config(void)
000030  48d7              LDR      r0,|L1.912|
;;;96     {
;;;97      	RCC->APB2ENR|=1<<3;//先使能外设IO PORTC时钟 							 
000032  6981              LDR      r1,[r0,#0x18]
000034  f0410108          ORR      r1,r1,#8
000038  6181              STR      r1,[r0,#0x18]
;;;98     	GPIOB->CRL&=0X00FFFFFF;//PC11/12 推挽输出
00003a  48d6              LDR      r0,|L1.916|
00003c  6801              LDR      r1,[r0,#0]
00003e  f021417f          BIC      r1,r1,#0xff000000
000042  6001              STR      r1,[r0,#0]
;;;99     	GPIOB->CRL|=0X33000000;	   
000044  6801              LDR      r1,[r0,#0]
000046  f041514c          ORR      r1,r1,#0x33000000
00004a  6001              STR      r1,[r0,#0]
;;;100    	GPIOB->ODR|=3<<6;     //PC11,12 输出高
00004c  68c1              LDR      r1,[r0,#0xc]
00004e  f04101c0          ORR      r1,r1,#0xc0
000052  60c1              STR      r1,[r0,#0xc]
;;;101    }
000054  4770              BX       lr
;;;102    
                          ENDP

                  I2C_Start PROC
;;;103    bool I2C_Start(void)
000056  b500              PUSH     {lr}
;;;104    {
;;;105    	SDA_H;
000058  49cf              LDR      r1,|L1.920|
00005a  2280              MOVS     r2,#0x80
00005c  f8c12c10          STR      r2,[r1,#0xc10]
;;;106    	SCL_H;
000060  2040              MOVS     r0,#0x40
000062  f8c10c10          STR      r0,[r1,#0xc10]
;;;107    	I2C_delay();
000066  f7fffffe          BL       I2C_delay
;;;108    	if(!SDA_read)return FALSE;	//SDA线为低电平则总线忙,退出
00006a  f8d10c08          LDR      r0,[r1,#0xc08]
;;;109    	SDA_L;
00006e  f8c12c14          STR      r2,[r1,#0xc14]
;;;110    	I2C_delay();
000072  f7fffffe          BL       I2C_delay
;;;111    	if(SDA_read) return FALSE;	//SDA线为高电平则总线出错,退出
000076  f8d10c08          LDR      r0,[r1,#0xc08]
00007a  f0100f80          TST      r0,#0x80
00007e  d001              BEQ      |L1.132|
000080  2000              MOVS     r0,#0
;;;112    	SDA_L;
;;;113    	I2C_delay();
;;;114    	return TRUE;
;;;115    }
000082  bd00              POP      {pc}
                  |L1.132|
000084  f8c12c14          STR      r2,[r1,#0xc14]        ;112
000088  f7fffffe          BL       I2C_delay
00008c  2001              MOVS     r0,#1                 ;114
00008e  bd00              POP      {pc}
;;;116    void I2C_Stop(void)
                          ENDP

                  I2C_Stop PROC
000090  b500              PUSH     {lr}
;;;117    {
;;;118    	SCL_L;
000092  49c2              LDR      r1,|L1.924|
000094  2240              MOVS     r2,#0x40
000096  604a              STR      r2,[r1,#4]
;;;119    	I2C_delay();
000098  f7fffffe          BL       I2C_delay
;;;120    	SDA_L;
00009c  2380              MOVS     r3,#0x80
00009e  604b              STR      r3,[r1,#4]
;;;121    	I2C_delay();
0000a0  f7fffffe          BL       I2C_delay
;;;122    	SCL_H;
0000a4  600a              STR      r2,[r1,#0]
;;;123    	I2C_delay();
0000a6  f7fffffe          BL       I2C_delay
;;;124    	SDA_H;
0000aa  600b              STR      r3,[r1,#0]
;;;125    	I2C_delay();
0000ac  f85deb04          POP      {lr}
0000b0  e7fe              B        I2C_delay
;;;126    } 
;;;127    void I2C_Ack(void)
                          ENDP

                  I2C_Ack PROC
0000b2  b500              PUSH     {lr}
;;;128    {	
;;;129    	SCL_L;
0000b4  49b9              LDR      r1,|L1.924|
0000b6  2240              MOVS     r2,#0x40
0000b8  604a              STR      r2,[r1,#4]
;;;130    	I2C_delay();
0000ba  f7fffffe          BL       I2C_delay
;;;131    	SDA_L;
0000be  2080              MOVS     r0,#0x80
0000c0  6048              STR      r0,[r1,#4]
;;;132    	I2C_delay();
0000c2  f7fffffe          BL       I2C_delay
;;;133    	SCL_H;
0000c6  600a              STR      r2,[r1,#0]
;;;134    	I2C_delay();
0000c8  f7fffffe          BL       I2C_delay
;;;135    	SCL_L;
0000cc  604a              STR      r2,[r1,#4]
;;;136    	I2C_delay();
0000ce  f85deb04          POP      {lr}
0000d2  e7fe              B        I2C_delay
;;;137    }   
;;;138    void I2C_NoAck(void)
                          ENDP

                  I2C_NoAck PROC
0000d4  b500              PUSH     {lr}
;;;139    {	
;;;140    	SCL_L;
0000d6  49b1              LDR      r1,|L1.924|
0000d8  2240              MOVS     r2,#0x40
0000da  604a              STR      r2,[r1,#4]
;;;141    	I2C_delay();
0000dc  f7fffffe          BL       I2C_delay
;;;142    	SDA_H;
0000e0  2080              MOVS     r0,#0x80
0000e2  6008              STR      r0,[r1,#0]
;;;143    	I2C_delay();
0000e4  f7fffffe          BL       I2C_delay
;;;144    	SCL_H;
0000e8  600a              STR      r2,[r1,#0]
;;;145    	I2C_delay();
0000ea  f7fffffe          BL       I2C_delay
;;;146    	SCL_L;
0000ee  604a              STR      r2,[r1,#4]
;;;147    	I2C_delay();
0000f0  f85deb04          POP      {lr}
0000f4  e7fe              B        I2C_delay
;;;148    } 
;;;149    bool I2C_WaitAck(void) 	 //返回为:=1有ACK,=0无ACK
                          ENDP

                  I2C_WaitAck PROC
0000f6  b500              PUSH     {lr}
;;;150    {
;;;151    	SCL_L;
0000f8  49a7              LDR      r1,|L1.920|
0000fa  2240              MOVS     r2,#0x40
0000fc  f8c12c14          STR      r2,[r1,#0xc14]
;;;152    	I2C_delay();
000100  f7fffffe          BL       I2C_delay
;;;153    	SDA_H;			
000104  2080              MOVS     r0,#0x80
000106  f8c10c10          STR      r0,[r1,#0xc10]
;;;154    	I2C_delay();
00010a  f7fffffe          BL       I2C_delay
;;;155    	SCL_H;
00010e  f8c12c10          STR      r2,[r1,#0xc10]
;;;156    	I2C_delay();
000112  f7fffffe          BL       I2C_delay
;;;157    	if(SDA_read)
000116  f8d10c08          LDR      r0,[r1,#0xc08]
00011a  f0100f80          TST      r0,#0x80
00011e  d005              BEQ      |L1.300|
;;;158    	{
;;;159          SCL_L;
000120  f8c12c14          STR      r2,[r1,#0xc14]
;;;160    	  I2C_delay();
000124  f7fffffe          BL       I2C_delay
;;;161          return FALSE;
000128  2000              MOVS     r0,#0
;;;162    	}
;;;163    	SCL_L;
;;;164    	I2C_delay();
;;;165    	return TRUE;
;;;166    }
00012a  bd00              POP      {pc}
                  |L1.300|
00012c  f8c12c14          STR      r2,[r1,#0xc14]        ;163
000130  f7fffffe          BL       I2C_delay
000134  2001              MOVS     r0,#1                 ;165
000136  bd00              POP      {pc}
;;;167    void I2C_SendByte(u8 SendByte) //数据从高位到低位//
                          ENDP

                  I2C_SendByte PROC
000138  b530              PUSH     {r4,r5,lr}
;;;168    {
00013a  4602              MOV      r2,r0
;;;169        u8 i=8;
;;;170        while(i--)
00013c  2107              MOVS     r1,#7
;;;171        {
;;;172            SCL_L;
;;;173            I2C_delay();
;;;174          if(SendByte&0x80)
;;;175            SDA_H;  
00013e  2580              MOVS     r5,#0x80
000140  4b95              LDR      r3,|L1.920|
000142  2440              MOVS     r4,#0x40              ;172
                  |L1.324|
000144  f8c34c14          STR      r4,[r3,#0xc14]        ;172
000148  f7fffffe          BL       I2C_delay
00014c  f0120f80          TST      r2,#0x80              ;174
000150  d002              BEQ      |L1.344|
000152  f8c35c10          STR      r5,[r3,#0xc10]
000156  e001              B        |L1.348|
                  |L1.344|
;;;176          else 
;;;177            SDA_L;   
000158  f8c35c14          STR      r5,[r3,#0xc14]
                  |L1.348|
;;;178            SendByte<<=1;
00015c  0650              LSLS     r0,r2,#25
00015e  0e02              LSRS     r2,r0,#24
;;;179            I2C_delay();
000160  f7fffffe          BL       I2C_delay
;;;180    		SCL_H;
000164  f8c34c10          STR      r4,[r3,#0xc10]
;;;181            I2C_delay();
000168  f7fffffe          BL       I2C_delay
00016c  0008              MOVS     r0,r1                 ;170
00016e  f1a10101          SUB      r1,r1,#1              ;170
000172  b2c9              UXTB     r1,r1                 ;170
000174  d1e6              BNE      |L1.324|
;;;182        }
;;;183        SCL_L;
000176  f8c34c14          STR      r4,[r3,#0xc14]
;;;184    }  
00017a  bd30              POP      {r4,r5,pc}
;;;185    unsigned char I2C_RadeByte(void)  //数据从高位到低位//
                          ENDP

                  I2C_RadeByte PROC
00017c  b510              PUSH     {r4,lr}
;;;186    { 
;;;187        u8 i=8;
;;;188        u8 ReceiveByte=0;
00017e  2100              MOVS     r1,#0
;;;189    
;;;190        SDA_H;				
000180  4b85              LDR      r3,|L1.920|
000182  2080              MOVS     r0,#0x80
000184  f8c30c10          STR      r0,[r3,#0xc10]
;;;191        while(i--)
000188  2207              MOVS     r2,#7
;;;192        {
;;;193          ReceiveByte<<=1;      
;;;194          SCL_L;
00018a  2440              MOVS     r4,#0x40
                  |L1.396|
00018c  0648              LSLS     r0,r1,#25             ;193
00018e  0e01              LSRS     r1,r0,#24             ;193
000190  f8c34c14          STR      r4,[r3,#0xc14]
;;;195          I2C_delay();
000194  f7fffffe          BL       I2C_delay
;;;196    	  SCL_H;
000198  f8c34c10          STR      r4,[r3,#0xc10]
;;;197          I2C_delay();	
00019c  f7fffffe          BL       I2C_delay
;;;198          if(SDA_read)
0001a0  f8d30c08          LDR      r0,[r3,#0xc08]
0001a4  f0100f80          TST      r0,#0x80
0001a8  d001              BEQ      |L1.430|
;;;199          {
;;;200            ReceiveByte|=0x01;
0001aa  f0410101          ORR      r1,r1,#1
                  |L1.430|
0001ae  0010              MOVS     r0,r2                 ;191
0001b0  f1a20201          SUB      r2,r2,#1              ;191
0001b4  b2d2              UXTB     r2,r2                 ;191
0001b6  d1e9              BNE      |L1.396|
;;;201          }
;;;202        }
;;;203        SCL_L;
0001b8  f8c34c14          STR      r4,[r3,#0xc14]
;;;204        return ReceiveByte;
0001bc  4608              MOV      r0,r1
;;;205    } 
0001be  bd10              POP      {r4,pc}
;;;206    
                          ENDP

                  Single_Write PROC
;;;207    bool Single_Write(unsigned char SlaveAddress,unsigned char REG_Address,unsigned char REG_data)		     //void
0001c0  b530              PUSH     {r4,r5,lr}
;;;208    {
0001c2  4603              MOV      r3,r0
0001c4  460c              MOV      r4,r1
0001c6  4615              MOV      r5,r2
;;;209      	if(!I2C_Start())return FALSE;
0001c8  f7fffffe          BL       I2C_Start
0001cc  b1a8              CBZ      r0,|L1.506|
;;;210        I2C_SendByte(SlaveAddress);   //发送设备地址+写信号//I2C_SendByte(((REG_Address & 0x0700) >>7) | SlaveAddress & 0xFFFE);//设置高起始地址+器件地址 
0001ce  4618              MOV      r0,r3
0001d0  f7fffffe          BL       I2C_SendByte
;;;211        if(!I2C_WaitAck()){I2C_Stop(); return FALSE;}
0001d4  f7fffffe          BL       I2C_WaitAck
0001d8  b188              CBZ      r0,|L1.510|
;;;212        I2C_SendByte(REG_Address );   //设置低起始地址      
0001da  4620              MOV      r0,r4
0001dc  f7fffffe          BL       I2C_SendByte
;;;213        I2C_WaitAck();	
0001e0  f7fffffe          BL       I2C_WaitAck
;;;214        I2C_SendByte(REG_data);
0001e4  4628              MOV      r0,r5
0001e6  f7fffffe          BL       I2C_SendByte
;;;215        I2C_WaitAck();   
0001ea  f7fffffe          BL       I2C_WaitAck
;;;216        I2C_Stop(); 
0001ee  f7fffffe          BL       I2C_Stop
;;;217        delay5ms();
0001f2  f7fffffe          BL       delay5ms
;;;218        return TRUE;
0001f6  2001              MOVS     r0,#1
;;;219    }
0001f8  bd30              POP      {r4,r5,pc}
                  |L1.506|
0001fa  2000              MOVS     r0,#0                 ;209
0001fc  bd30              POP      {r4,r5,pc}
                  |L1.510|
0001fe  f7fffffe          BL       I2C_Stop
000202  2000              MOVS     r0,#0                 ;211
000204  bd30              POP      {r4,r5,pc}
;;;220    
                          ENDP

                  Single_Read PROC
;;;221    unsigned char Single_Read(unsigned char SlaveAddress,unsigned char REG_Address)
000206  b530              PUSH     {r4,r5,lr}
;;;222    {   unsigned char REG_data;     	
000208  4604              MOV      r4,r0
00020a  460d              MOV      r5,r1
;;;223    	if(!I2C_Start())return FALSE;
00020c  f7fffffe          BL       I2C_Start
000210  b1d8              CBZ      r0,|L1.586|
;;;224        I2C_SendByte(SlaveAddress); //I2C_SendByte(((REG_Address & 0x0700) >>7) | REG_Address & 0xFFFE);//设置高起始地址+器件地址 
000212  4620              MOV      r0,r4
000214  f7fffffe          BL       I2C_SendByte
;;;225        if(!I2C_WaitAck()){I2C_Stop();test=1; return FALSE;}
000218  f7fffffe          BL       I2C_WaitAck
00021c  b1b8              CBZ      r0,|L1.590|
;;;226        I2C_SendByte((u8) REG_Address);   //设置低起始地址      
00021e  4628              MOV      r0,r5
000220  f7fffffe          BL       I2C_SendByte
;;;227        I2C_WaitAck();
000224  f7fffffe          BL       I2C_WaitAck
;;;228        I2C_Start();
000228  f7fffffe          BL       I2C_Start
;;;229        I2C_SendByte(SlaveAddress+1);
00022c  1c60              ADDS     r0,r4,#1
00022e  b2c0              UXTB     r0,r0
000230  f7fffffe          BL       I2C_SendByte
;;;230        I2C_WaitAck();
000234  f7fffffe          BL       I2C_WaitAck
;;;231    
;;;232    	REG_data= I2C_RadeByte();
000238  f7fffffe          BL       I2C_RadeByte
00023c  4604              MOV      r4,r0
;;;233        I2C_NoAck();
00023e  f7fffffe          BL       I2C_NoAck
;;;234        I2C_Stop();
000242  f7fffffe          BL       I2C_Stop
;;;235        //return TRUE;
;;;236    	return REG_data;
000246  4620              MOV      r0,r4
;;;237    
;;;238    }
000248  bd30              POP      {r4,r5,pc}
                  |L1.586|
00024a  2000              MOVS     r0,#0                 ;223
00024c  bd30              POP      {r4,r5,pc}
                  |L1.590|
00024e  f7fffffe          BL       I2C_Stop
000252  4953              LDR      r1,|L1.928|
000254  2001              MOVS     r0,#1                 ;225
000256  7008              STRB     r0,[r1,#0]            ;225
000258  2000              MOVS     r0,#0                 ;225
00025a  bd30              POP      {r4,r5,pc}
;;;239    
                          ENDP

                  conversion PROC
;;;240    void conversion(u16 temp_data)  
00025c  b510              PUSH     {r4,lr}
;;;241    {   
;;;242    	printf("现在的角度为:=%d°\n",temp_data);
00025e  4601              MOV      r1,r0
000260  a050              ADR      r0,|L1.932|
000262  f7fffffe          BL       __2printf
;;;243        Delayms(20);		
000266  e8bd4010          POP      {r4,lr}
00026a  2014              MOVS     r0,#0x14
00026c  e7fe              B        Delayms
;;;244    }
;;;245    
                          ENDP

                  read_hmc5883l PROC
;;;246    void read_hmc5883l()
00026e  b570              PUSH     {r4-r6,lr}
;;;247    {
000270  b082              SUB      sp,sp,#8
;;;248        unsigned char BUF[8];                         //接收数据缓存区
;;;249        int   x,y;
;;;250    
;;;251        Single_Write(HMC5883L_Addr,0x00,0x14);    
000272  2214              MOVS     r2,#0x14
000274  2100              MOVS     r1,#0
000276  203c              MOVS     r0,#0x3c
000278  f7fffffe          BL       Single_Write
;;;252        Single_Write(HMC5883L_Addr,0x02,0x00);   
00027c  2200              MOVS     r2,#0
00027e  2102              MOVS     r1,#2
000280  203c              MOVS     r0,#0x3c
000282  f7fffffe          BL       Single_Write
;;;253        Delayms(10);
000286  200a              MOVS     r0,#0xa
000288  f7fffffe          BL       Delayms
;;;254    
;;;255        BUF[1]=Single_Read(HMC5883L_Addr,0x03); 
00028c  2103              MOVS     r1,#3
00028e  203c              MOVS     r0,#0x3c
000290  f7fffffe          BL       Single_Read
000294  f88d0001          STRB     r0,[sp,#1]
000298  4605              MOV      r5,r0
;;;256        BUF[2]=Single_Read(HMC5883L_Addr,0x04); 
00029a  2104              MOVS     r1,#4
00029c  203c              MOVS     r0,#0x3c
00029e  f7fffffe          BL       Single_Read
0002a2  f88d0002          STRB     r0,[sp,#2]
0002a6  4606              MOV      r6,r0
;;;257    
;;;258        BUF[3]=Single_Read(HMC5883L_Addr,0x07); 
0002a8  2107              MOVS     r1,#7
0002aa  203c              MOVS     r0,#0x3c
0002ac  f7fffffe          BL       Single_Read
0002b0  f88d0003          STRB     r0,[sp,#3]
0002b4  4604              MOV      r4,r0
;;;259        BUF[4]=Single_Read(HMC5883L_Addr,0x08); 
0002b6  2108              MOVS     r1,#8
0002b8  203c              MOVS     r0,#0x3c
0002ba  f7fffffe          BL       Single_Read
0002be  f88d0004          STRB     r0,[sp,#4]
;;;260    
;;;261        x=(BUF[1] << 8) | BUF[2];  
0002c2  ea462105          ORR      r1,r6,r5,LSL #8
;;;262        y=(BUF[3] << 8) | BUF[4];  
0002c6  ea402004          ORR      r0,r0,r4,LSL #8
;;;263    
;;;264        if(x>0x7fff)x-=0xffff;	  
0002ca  f5b14f00          CMP      r1,#0x8000
0002ce  db02              BLT      |L1.726|
0002d0  f5a1417f          SUB      r1,r1,#0xff00
0002d4  39ff              SUBS     r1,r1,#0xff
                  |L1.726|
;;;265        if(y>0x7fff)y-=0xffff;	  
0002d6  f5b04f00          CMP      r0,#0x8000
0002da  db02              BLT      |L1.738|
0002dc  f5a0407f          SUB      r0,r0,#0xff00
0002e0  38ff              SUBS     r0,r0,#0xff
                  |L1.738|
;;;266        angle= atan2(y,x) * (180 / 3.14159265) + 180;  
0002e2  f7fffffe          BL       atan2
0002e6  f7fffffe          BL       __aeabi_i2d
0002ea  4a33              LDR      r2,|L1.952|
0002ec  4b33              LDR      r3,|L1.956|
0002ee  f7fffffe          BL       __aeabi_dmul
0002f2  2200              MOVS     r2,#0
0002f4  4b32              LDR      r3,|L1.960|
0002f6  f7fffffe          BL       __aeabi_dadd
0002fa  f7fffffe          BL       __aeabi_d2uiz
0002fe  4928              LDR      r1,|L1.928|
000300  b280              UXTH     r0,r0
000302  8048              STRH     r0,[r1,#2]
;;;267        conversion(angle);
000304  b002              ADD      sp,sp,#8
000306  e8bd4070          POP      {r4-r6,lr}
00030a  e7fe              B        conversion
;;;268    }
;;;269    
                          ENDP

                  UHMC_EventLoop PROC
                  |L1.780|
;;;316    
;;;317    void UHMC_EventLoop(void)
00030c  f7fffffe          BL       read_hmc5883l
;;;318    {
;;;319        INT8U           err     = 0;    
;;;320        UCORE_MSG_S     *pMsg   = NULL;   	
;;;321        
;;;322        while (1)
;;;323        {
;;;324            read_hmc5883l();
;;;325    
;;;326            OSTimeDlyHMSM(0, 0, 0, 1000);
000310  2200              MOVS     r2,#0
000312  f44f737a          MOV      r3,#0x3e8
000316  4611              MOV      r1,r2
000318  4610              MOV      r0,r2
00031a  f7fffffe          BL       OSTimeDlyHMSM
00031e  e7f5              B        |L1.780|
;;;327        }
;;;328    }
                          ENDP

                  UHMC_Init PROC
;;;300    
;;;301    void UHMC_Init(void)
000320  b510              PUSH     {r4,lr}
;;;302    {
;;;303        g_QMboxHmcMsg = OSMboxCreate((void *)0);
000322  2000              MOVS     r0,#0
000324  f7fffffe          BL       OSMboxCreate
000328  491d              LDR      r1,|L1.928|
00032a  6048              STR      r0,[r1,#4]  ; g_QMboxHmcMsg
;;;304    
;;;305        I2C_GPIO_Config();
00032c  f7fffffe          BL       I2C_GPIO_Config
;;;306        //初始化HMC5883L
;;;307        if (TRUE != Single_Write(HMC5883L_Addr,0x00,0x14))
000330  2214              MOVS     r2,#0x14
000332  2100              MOVS     r1,#0
000334  203c              MOVS     r0,#0x3c
000336  f7fffffe          BL       Single_Write
00033a  2801              CMP      r0,#1
00033c  d004              BEQ      |L1.840|
;;;308        {
;;;309            printf("初始化失败!\r\n");
00033e  e8bd4010          POP      {r4,lr}
000342  a020              ADR      r0,|L1.964|
000344  f7ffbffe          B.W      __2printf
                  |L1.840|
;;;310            return;
;;;311        }
;;;312        Single_Write(HMC5883L_Addr,0x02,0x00);   
000348  2200              MOVS     r2,#0
00034a  2102              MOVS     r1,#2
00034c  203c              MOVS     r0,#0x3c
00034e  f7fffffe          BL       Single_Write
;;;313      
;;;314        printf("User task hmc init finished.\r\n");
000352  e8bd4010          POP      {r4,lr}
000356  a01f              ADR      r0,|L1.980|
000358  f7ffbffe          B.W      __2printf
;;;315    }
;;;316    
                          ENDP

                  UHMC_TaskProc PROC
;;;287    
;;;288    void UHMC_TaskProc(void *p_arg)
00035c  a025              ADR      r0,|L1.1012|
;;;289    {
;;;290        printf("User Task hmc Start.\r\n");
00035e  f7fffffe          BL       __2printf
;;;291    
;;;292        /* call init */
;;;293        UHMC_Init();
000362  f7fffffe          BL       UHMC_Init
;;;294    
;;;295        /* enter event loop */
;;;296        UHMC_EventLoop();
000366  f7fffffe          BL       UHMC_EventLoop
;;;297    
;;;298        printf("User Task hmc Exit.\r\n");
;;;299    }
;;;300    
                          ENDP

                  UHMC_Start PROC
;;;269    
;;;270    u8 UHMC_Start(void)
00036a  b510              PUSH     {r4,lr}
;;;271    {
;;;272        u8          ucResult    = UCORE_ERR_COMMON_FAILED;
;;;273    
;;;274        printf("starting user task hmc...\r\n");
00036c  a027              ADR      r0,|L1.1036|
00036e  f7fffffe          BL       __2printf
;;;275    
;;;276        ucResult = OSTaskCreate(UHMC_TaskProc, (void *)0, (OS_STK *)&g_UserTaskHmcSTK[DEFAULT_USER_HMC_STK_SIZE - 1], DEFAULT_USER_TASK_HMC_PRIO);
000372  230e              MOVS     r3,#0xe
000374  4a2c              LDR      r2,|L1.1064|
000376  2100              MOVS     r1,#0
000378  482c              LDR      r0,|L1.1068|
00037a  f7fffffe          BL       OSTaskCreate
;;;277    
;;;278        if (OS_ERR_NONE == ucResult)
00037e  b128              CBZ      r0,|L1.908|
;;;279        {
;;;280            return UCORE_ERR_SUCCESS;
;;;281        }
;;;282    
;;;283        printf("User task hmc Failed value:%d.\r\n", ucResult);
000380  4601              MOV      r1,r0
000382  a02b              ADR      r0,|L1.1072|
000384  f7fffffe          BL       __2printf
;;;284    
;;;285        return UCORE_ERR_CREATE_TASK_FAILED;
000388  2004              MOVS     r0,#4
;;;286    }
00038a  bd10              POP      {r4,pc}
                  |L1.908|
00038c  2000              MOVS     r0,#0                 ;280
00038e  bd10              POP      {r4,pc}
;;;287    
                          ENDP

                  |L1.912|
                          DCD      0x40021000
                  |L1.916|
                          DCD      0x40010c00
                  |L1.920|
                          DCD      0x40010000
                  |L1.924|
                          DCD      0x40010c10
                  |L1.928|
                          DCD      ||.data||
                  |L1.932|
0003a4  cfd6d4da          DCB      207,214,212,218,181,196,189,199,182,200,206,170,":=%d",161
0003a8  b5c4bdc7
0003ac  b6c8ceaa
0003b0  3a3d2564
0003b4  a1      
0003b5  e30a00            DCB      227,"\n",0
                  |L1.952|
                          DCD      0x1af05a77
                  |L1.956|
                          DCD      0x404ca5dc
                  |L1.960|
                          DCD      0x40668000
                  |L1.964|
0003c4  b3f5cabc          DCB      179,245,202,188,187,175,202,167,176,220,"!\r\n",0
0003c8  bbafcaa7
0003cc  b0dc210d
0003d0  0a00    
0003d2  00                DCB      0
0003d3  00                DCB      0
                  |L1.980|
0003d4  55736572          DCB      "User task hmc init finished.\r\n",0
0003d8  20746173
0003dc  6b20686d
0003e0  6320696e
0003e4  69742066
0003e8  696e6973
0003ec  6865642e
0003f0  0d0a00  
0003f3  00                DCB      0
                  |L1.1012|
0003f4  55736572          DCB      "User Task hmc Start.\r\n",0
0003f8  20546173
0003fc  6b20686d
000400  63205374
000404  6172742e
000408  0d0a00  
00040b  00                DCB      0
                  |L1.1036|
00040c  73746172          DCB      "starting user task hmc...\r\n",0
000410  74696e67
000414  20757365
000418  72207461
00041c  736b2068
000420  6d632e2e
000424  2e0d0a00
                  |L1.1064|
                          DCD      ||.bss||+0xfc
                  |L1.1068|
                          DCD      UHMC_TaskProc
                  |L1.1072|
000430  55736572          DCB      "User task hmc Failed value:%d.\r\n",0
000434  20746173
000438  6b20686d
00043c  63204661
000440  696c6564
000444  2076616c
000448  75653a25
00044c  642e0d0a
000450  00      
000451  00                DCB      0
000452  00                DCB      0
000453  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=6

                  g_UserTaskHmcSTK
                          %        256

                          AREA ||.data||, DATA, ALIGN=2

                  test
000000  0000              DCB      0x00,0x00
                  angle
000002  0000              DCB      0x00,0x00
                  g_QMboxHmcMsg
                          DCD      0x00000000
