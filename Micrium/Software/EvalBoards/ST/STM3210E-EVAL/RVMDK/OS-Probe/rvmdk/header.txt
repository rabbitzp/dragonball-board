; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\header.o --depend=.\rvmdk\header.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\header.crf ..\..\..\..\..\uCGUI\GUI\Widget\HEADER.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _DrawTriangle PROC
;;;100    */
;;;101    static void _DrawTriangle(int x, int y, int Size, int Inc) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;102      for (; Size >= 0; Size--, y += Inc) {
00000c  2c00              CMP      r4,#0
00000e  db08              BLT      |L1.34|
                  |L1.16|
;;;103        GUI_DrawHLine(y, x - Size, x + Size);
000010  1932              ADDS     r2,r6,r4
000012  1b31              SUBS     r1,r6,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       GUI_DrawHLine
00001a  1e64              SUBS     r4,r4,#1              ;102
00001c  443d              ADD      r5,r5,r7              ;102
00001e  2c00              CMP      r4,#0                 ;102
000020  daf6              BGE      |L1.16|
                  |L1.34|
;;;104      }
;;;105    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;106    
                          ENDP

                  _Paint PROC
;;;110    */
;;;111    static void _Paint(HEADER_Obj* pObj) {
000026  e92d4ff0          PUSH     {r4-r11,lr}
00002a  b089              SUB      sp,sp,#0x24
00002c  4605              MOV      r5,r0
;;;112      GUI_RECT Rect, RectItem;
;;;113      int i, xPos = -pObj->ScrollPos;
00002e  6be8              LDR      r0,[r5,#0x3c]
000030  4247              RSBS     r7,r0,#0
;;;114      int NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
000032  f1050030          ADD      r0,r5,#0x30
000036  f7fffffe          BL       GUI_ARRAY_GetNumItems
00003a  9003              STR      r0,[sp,#0xc]
;;;115      int EffectSize = pObj->Widget.pEffect->EffectSize;
00003c  6a28              LDR      r0,[r5,#0x20]
00003e  f8d0b014          LDR      r11,[r0,#0x14]
;;;116      int ArrowSize, ArrowPos;
;;;117      LCD_SetBkColor(pObj->BkColor);
000042  6aa8              LDR      r0,[r5,#0x28]
000044  f7fffffe          BL       LCD_SetBkColor
;;;118      GUI_SetFont(pObj->pFont);
000048  6ce8              LDR      r0,[r5,#0x4c]
00004a  f7fffffe          BL       GUI_SetFont
;;;119      GUI_Clear();
00004e  f7fffffe          BL       GUI_Clear
;;;120      for (i = 0; i < NumItems; i++) {
000052  2600              MOVS     r6,#0
000054  9803              LDR      r0,[sp,#0xc]
000056  2800              CMP      r0,#0
000058  dd6f              BLE      |L1.314|
;;;121        int Subtract = 0;
;;;122        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
;;;123        GUI_GetClientRect(&Rect);
;;;124        Rect.x0 = xPos;
;;;125        Rect.x1 = Rect.x0 + pColumn->Width;
;;;126        RectItem = Rect;
;;;127        ArrowSize = ((RectItem.y1 - RectItem.y0 - EffectSize * 2) / 3) - 1;
00005a  f1cb0000          RSB      r0,r11,#0
00005e  9008              STR      r0,[sp,#0x20]
                  |L1.96|
000060  f04f0900          MOV      r9,#0                 ;121
000064  4631              MOV      r1,r6                 ;122
000066  f1050030          ADD      r0,r5,#0x30           ;122
00006a  f7fffffe          BL       GUI_ARRAY_GetpItem
00006e  4604              MOV      r4,r0                 ;122
000070  a806              ADD      r0,sp,#0x18           ;123
000072  f7fffffe          BL       GUI_GetClientRect
000076  f8ad7018          STRH     r7,[sp,#0x18]         ;124
00007a  6820              LDR      r0,[r4,#0]            ;125
00007c  4438              ADD      r0,r0,r7              ;125
00007e  f8ad001c          STRH     r0,[sp,#0x1c]         ;125
000082  9907              LDR      r1,[sp,#0x1c]         ;126
000084  9806              LDR      r0,[sp,#0x18]         ;126
000086  9105              STR      r1,[sp,#0x14]         ;126
000088  9004              STR      r0,[sp,#0x10]         ;126
00008a  f9bd0016          LDRSH    r0,[sp,#0x16]
00008e  f9bd1012          LDRSH    r1,[sp,#0x12]
000092  1a41              SUBS     r1,r0,r1
000094  9808              LDR      r0,[sp,#0x20]
000096  eb010140          ADD      r1,r1,r0,LSL #1
00009a  48ff              LDR      r0,|L1.1176|
00009c  fb801001          SMULL    r1,r0,r0,r1
0000a0  eba070e0          SUB      r0,r0,r0,ASR #31
0000a4  f1a00801          SUB      r8,r0,#1
;;;128        ArrowPos = RectItem.x1 - 4 - ArrowSize;
0000a8  f9bd0014          LDRSH    r0,[sp,#0x14]
0000ac  eba00008          SUB      r0,r0,r8
0000b0  1f00              SUBS     r0,r0,#4
0000b2  9002              STR      r0,[sp,#8]
;;;129        if (pColumn->hDrawObj) {
0000b4  f9b40006          LDRSH    r0,[r4,#6]
0000b8  b3f0              CBZ      r0,|L1.312|
;;;130          int xOff = 0, yOff = 0;
0000ba  46ca              MOV      r10,r9
0000bc  2100              MOVS     r1,#0
0000be  9101              STR      r1,[sp,#4]
;;;131          switch (pColumn->Align & GUI_TA_HORIZONTAL) {
0000c0  88a1              LDRH     r1,[r4,#4]
0000c2  f0010103          AND      r1,r1,#3
0000c6  2901              CMP      r1,#1
0000c8  d002              BEQ      |L1.208|
0000ca  2902              CMP      r1,#2
0000cc  d10e              BNE      |L1.236|
0000ce  e005              B        |L1.220|
                  |L1.208|
;;;132            case GUI_TA_RIGHT:
;;;133              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj));
0000d0  f7fffffe          BL       GUI_DRAW__GetXSize
0000d4  6821              LDR      r1,[r4,#0]
0000d6  eba10a00          SUB      r10,r1,r0
;;;134              break;
0000da  e007              B        |L1.236|
                  |L1.220|
;;;135            case GUI_TA_HCENTER:
;;;136              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj)) / 2;
0000dc  f7fffffe          BL       GUI_DRAW__GetXSize
0000e0  6821              LDR      r1,[r4,#0]
0000e2  1a08              SUBS     r0,r1,r0
0000e4  eb0070d0          ADD      r0,r0,r0,LSR #31
0000e8  ea4f0a60          ASR      r10,r0,#1
                  |L1.236|
;;;137              break;
;;;138          }
;;;139          switch (pColumn->Align & GUI_TA_VERTICAL) {
0000ec  88a0              LDRH     r0,[r4,#4]
0000ee  f000000c          AND      r0,r0,#0xc
0000f2  2804              CMP      r0,#4
0000f4  d002              BEQ      |L1.252|
0000f6  280c              CMP      r0,#0xc
0000f8  d11c              BNE      |L1.308|
0000fa  e00c              B        |L1.278|
                  |L1.252|
;;;140    	      case GUI_TA_BOTTOM:
;;;141              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj));
0000fc  f9b40006          LDRSH    r0,[r4,#6]
000100  f7fffffe          BL       GUI_DRAW__GetYSize
000104  f9bd101e          LDRSH    r1,[sp,#0x1e]
000108  f9bd201a          LDRSH    r2,[sp,#0x1a]
00010c  1a89              SUBS     r1,r1,r2
00010e  1a08              SUBS     r0,r1,r0
000110  1c40              ADDS     r0,r0,#1
000112  9001              STR      r0,[sp,#4]
;;;142              break;
000114  e00e              B        |L1.308|
                  |L1.278|
;;;143    	      case GUI_TA_VCENTER:
;;;144              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj)) / 2;
000116  f9b40006          LDRSH    r0,[r4,#6]
00011a  f7fffffe          BL       GUI_DRAW__GetYSize
00011e  f9bd101e          LDRSH    r1,[sp,#0x1e]
000122  f9bd201a          LDRSH    r2,[sp,#0x1a]
000126  1a89              SUBS     r1,r1,r2
000128  1a08              SUBS     r0,r1,r0
00012a  1c40              ADDS     r0,r0,#1
00012c  eb0070d0          ADD      r0,r0,r0,LSR #31
000130  1040              ASRS     r0,r0,#1
000132  9001              STR      r0,[sp,#4]
                  |L1.308|
;;;145              break;
;;;146          }
;;;147          WM_SetUserClipRect(&Rect);
000134  a806              ADD      r0,sp,#0x18
000136  e001              B        |L1.316|
                  |L1.312|
000138  e00c              B        |L1.340|
                  |L1.314|
00013a  e069              B        |L1.528|
                  |L1.316|
00013c  f7fffffe          BL       WM_SetUserClipRect
;;;148          GUI_DRAW__Draw(pColumn->hDrawObj, xPos + xOff, yOff);
000140  eb07010a          ADD      r1,r7,r10
000144  f9b40006          LDRSH    r0,[r4,#6]
000148  9a01              LDR      r2,[sp,#4]
00014a  f7fffffe          BL       GUI_DRAW__Draw
;;;149          WM_SetUserClipRect(NULL);
00014e  2000              MOVS     r0,#0
000150  f7fffffe          BL       WM_SetUserClipRect
                  |L1.340|
;;;150        }
;;;151        WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
000154  a906              ADD      r1,sp,#0x18
000156  4628              MOV      r0,r5
000158  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;152        xPos += Rect.x1 - Rect.x0;
00015c  f9bd001c          LDRSH    r0,[sp,#0x1c]
000160  f9bd1018          LDRSH    r1,[sp,#0x18]
000164  1a42              SUBS     r2,r0,r1
000166  4417              ADD      r7,r7,r2
;;;153        Rect.x0 += EffectSize + _DefaultBorderH;
000168  4bcc              LDR      r3,|L1.1180|
00016a  68da              LDR      r2,[r3,#0xc]  ; _DefaultBorderH
00016c  445a              ADD      r2,r2,r11
00016e  4411              ADD      r1,r1,r2
000170  f8ad1018          STRH     r1,[sp,#0x18]
;;;154        Rect.x1 -= EffectSize + _DefaultBorderH;
000174  1a80              SUBS     r0,r0,r2
000176  f8ad001c          STRH     r0,[sp,#0x1c]
;;;155        Rect.y0 += EffectSize + _DefaultBorderV;
00017a  6918              LDR      r0,[r3,#0x10]  ; _DefaultBorderV
00017c  f8bd101a          LDRH     r1,[sp,#0x1a]
000180  4458              ADD      r0,r0,r11
000182  4401              ADD      r1,r1,r0
000184  f8ad101a          STRH     r1,[sp,#0x1a]
;;;156        Rect.y1 -= EffectSize + _DefaultBorderV;
000188  f8bd101e          LDRH     r1,[sp,#0x1e]
00018c  1a08              SUBS     r0,r1,r0
00018e  f8ad001e          STRH     r0,[sp,#0x1e]
;;;157        LCD_SetColor(pObj->TextColor);
000192  6ae8              LDR      r0,[r5,#0x2c]
000194  f7fffffe          BL       LCD_SetColor
;;;158        if ((pObj->DirIndicatorColumn == i) && ((pColumn->Align & GUI_TA_HORIZONTAL) == GUI_TA_RIGHT)) {
000198  6c68              LDR      r0,[r5,#0x44]
00019a  42b0              CMP      r0,r6
00019c  d106              BNE      |L1.428|
00019e  88a0              LDRH     r0,[r4,#4]
0001a0  f0000003          AND      r0,r0,#3
0001a4  2801              CMP      r0,#1
0001a6  d101              BNE      |L1.428|
;;;159          Subtract = (ArrowSize << 1) + 1;
0001a8  eb000948          ADD      r9,r0,r8,LSL #1
                  |L1.428|
;;;160        }
;;;161        Rect.x1 -= Subtract;
0001ac  f8bd001c          LDRH     r0,[sp,#0x1c]
0001b0  eba00009          SUB      r0,r0,r9
0001b4  f8ad001c          STRH     r0,[sp,#0x1c]
;;;162        GUI_DispStringInRect(pColumn->acText, &Rect, pColumn->Align);
0001b8  f9b42004          LDRSH    r2,[r4,#4]
0001bc  a906              ADD      r1,sp,#0x18
0001be  f1040008          ADD      r0,r4,#8
0001c2  f7fffffe          BL       GUI_DispStringInRect
;;;163        Rect.x1 += Subtract;
0001c6  f8bd001c          LDRH     r0,[sp,#0x1c]
0001ca  4448              ADD      r0,r0,r9
0001cc  f8ad001c          STRH     r0,[sp,#0x1c]
;;;164        if (pObj->DirIndicatorColumn == i) {
0001d0  6c68              LDR      r0,[r5,#0x44]
0001d2  42b0              CMP      r0,r6
0001d4  d117              BNE      |L1.518|
;;;165          LCD_SetColor(GUI_BLACK);
0001d6  2000              MOVS     r0,#0
0001d8  f7fffffe          BL       LCD_SetColor
;;;166          WM_SetUserClipRect(&RectItem);
0001dc  a804              ADD      r0,sp,#0x10
0001de  f7fffffe          BL       WM_SetUserClipRect
;;;167          if (pObj->DirIndicatorReverse == 0) {
0001e2  6ca8              LDR      r0,[r5,#0x48]
0001e4  b320              CBZ      r0,|L1.560|
;;;168            _DrawTriangle(ArrowPos, ((Rect.y1 - Rect.y0) >> 1), ArrowSize, 1);
;;;169          } else {
;;;170            _DrawTriangle(ArrowPos, ((Rect.y1 - Rect.y0) >> 1) + ArrowSize, ArrowSize, -1);
0001e6  f9bd001e          LDRSH    r0,[sp,#0x1e]
0001ea  f9bd101a          LDRSH    r1,[sp,#0x1a]
0001ee  f04f33ff          MOV      r3,#0xffffffff
0001f2  1a40              SUBS     r0,r0,r1
0001f4  eb080160          ADD      r1,r8,r0,ASR #1
0001f8  4642              MOV      r2,r8
0001fa  9802              LDR      r0,[sp,#8]
0001fc  f7fffffe          BL       _DrawTriangle
                  |L1.512|
;;;171          }
;;;172          WM_SetUserClipRect(NULL);
000200  2000              MOVS     r0,#0
000202  f7fffffe          BL       WM_SetUserClipRect
                  |L1.518|
000206  1c76              ADDS     r6,r6,#1              ;120
000208  9803              LDR      r0,[sp,#0xc]          ;120
00020a  4286              CMP      r6,r0                 ;120
00020c  f6ffaf28          BLT      |L1.96|
                  |L1.528|
;;;173        }
;;;174      }
;;;175      GUI_GetClientRect(&Rect);
000210  a806              ADD      r0,sp,#0x18
000212  f7fffffe          BL       GUI_GetClientRect
;;;176      Rect.x0 = xPos;
000216  f8ad7018          STRH     r7,[sp,#0x18]
;;;177      Rect.x1 = 0xfff;
00021a  f64070ff          MOV      r0,#0xfff
00021e  f8ad001c          STRH     r0,[sp,#0x1c]
;;;178      WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
000222  a906              ADD      r1,sp,#0x18
000224  4628              MOV      r0,r5
000226  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;179    }
00022a  b009              ADD      sp,sp,#0x24
00022c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.560|
000230  f9bd001e          LDRSH    r0,[sp,#0x1e]         ;168
000234  f9bd101a          LDRSH    r1,[sp,#0x1a]         ;168
000238  2301              MOVS     r3,#1                 ;168
00023a  1a40              SUBS     r0,r0,r1              ;168
00023c  1041              ASRS     r1,r0,#1              ;168
00023e  4642              MOV      r2,r8                 ;168
000240  9802              LDR      r0,[sp,#8]            ;168
000242  f7fffffe          BL       _DrawTriangle
000246  e7db              B        |L1.512|
;;;180    
                          ENDP

                  _RestoreOldCursor PROC
;;;184    */
;;;185    static void _RestoreOldCursor(void) {
000248  4894              LDR      r0,|L1.1180|
;;;186      if (_pOldCursor) {
00024a  6981              LDR      r1,[r0,#0x18]  ; _pOldCursor
00024c  2900              CMP      r1,#0
00024e  d001              BEQ      |L1.596|
;;;187        #if GUI_SUPPORT_CURSOR
;;;188          GUI_CURSOR_Select(_pOldCursor);
;;;189        #endif
;;;190        _pOldCursor = 0;
000250  2100              MOVS     r1,#0
000252  6181              STR      r1,[r0,#0x18]  ; _pOldCursor
                  |L1.596|
;;;191      }
;;;192    }
000254  4770              BX       lr
;;;193    
                          ENDP

                  _FreeAttached PROC
;;;199    */
;;;200    static void _FreeAttached(HEADER_Obj * pObj) {
000256  b570              PUSH     {r4-r6,lr}
000258  4605              MOV      r5,r0
;;;201      int i, NumItems;
;;;202      NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
00025a  f1050030          ADD      r0,r5,#0x30
00025e  f7fffffe          BL       GUI_ARRAY_GetNumItems
000262  4606              MOV      r6,r0
;;;203      for (i = 0; i < NumItems; i++) {
000264  2400              MOVS     r4,#0
000266  2e00              CMP      r6,#0
000268  dd0c              BLE      |L1.644|
                  |L1.618|
;;;204        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
00026a  4621              MOV      r1,r4
00026c  f1050030          ADD      r0,r5,#0x30
000270  f7fffffe          BL       GUI_ARRAY_GetpItem
;;;205        if (pColumn->hDrawObj) {
000274  f9b00006          LDRSH    r0,[r0,#6]
000278  b108              CBZ      r0,|L1.638|
;;;206          GUI_ALLOC_Free(pColumn->hDrawObj);
00027a  f7fffffe          BL       GUI_ALLOC_Free
                  |L1.638|
00027e  1c64              ADDS     r4,r4,#1              ;203
000280  42b4              CMP      r4,r6                 ;203
000282  dbf2              BLT      |L1.618|
                  |L1.644|
;;;207        }
;;;208      }
;;;209      /* Delete attached objects (if any) */
;;;210      GUI_ARRAY_Delete(&pObj->Columns);
000284  f1050030          ADD      r0,r5,#0x30
000288  f7fffffe          BL       GUI_ARRAY_Delete
;;;211      _RestoreOldCursor();
00028c  e8bd4070          POP      {r4-r6,lr}
000290  e7fe              B        _RestoreOldCursor
;;;212    }
;;;213    
                          ENDP

                  _GetDividerIndex PROC
;;;218    #if (HEADER_SUPPORT_DRAG)
;;;219    static int _GetDividerIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
000292  e92d4ff8          PUSH     {r3-r11,lr}
000296  4605              MOV      r5,r0
000298  460e              MOV      r6,r1
00029a  4617              MOV      r7,r2
00029c  461c              MOV      r4,r3
;;;220      int Item = -1;
00029e  f04f39ff          MOV      r9,#0xffffffff
;;;221      if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
0002a2  2c00              CMP      r4,#0
0002a4  db30              BLT      |L1.776|
0002a6  4628              MOV      r0,r5
0002a8  f7fffffe          BL       WM_GetWindowSizeY
0002ac  42a0              CMP      r0,r4
0002ae  dd2b              BLE      |L1.776|
;;;222        if (hObj) {
0002b0  b355              CBZ      r5,|L1.776|
;;;223          int Index, xPos = 0, NumColumns;
0002b2  2500              MOVS     r5,#0
;;;224          NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
0002b4  f1060030          ADD      r0,r6,#0x30
0002b8  f7fffffe          BL       GUI_ARRAY_GetNumItems
0002bc  4680              MOV      r8,r0
;;;225          for (Index = 0; Index < NumColumns; Index++) {
0002be  2400              MOVS     r4,#0
0002c0  f1b80f00          CMP      r8,#0
0002c4  dd20              BLE      |L1.776|
;;;226            HEADER_COLUMN * pColumn;
;;;227            pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
;;;228            xPos += pColumn->Width;
;;;229            if ((xPos >= (x - 4)) && (xPos <= (x + 4))) {
0002c6  1f38              SUBS     r0,r7,#4
0002c8  f1070a04          ADD      r10,r7,#4
;;;230              Item = Index;
;;;231              if ((Index < (NumColumns - 1)) && (x < xPos)) {
0002cc  f1a80b01          SUB      r11,r8,#1
0002d0  9000              STR      r0,[sp,#0]
                  |L1.722|
0002d2  4621              MOV      r1,r4                 ;227
0002d4  f1060030          ADD      r0,r6,#0x30           ;227
0002d8  f7fffffe          BL       GUI_ARRAY_GetpItem
0002dc  6800              LDR      r0,[r0,#0]            ;228
0002de  4405              ADD      r5,r5,r0              ;228
0002e0  9800              LDR      r0,[sp,#0]            ;229
0002e2  4285              CMP      r5,r0                 ;229
0002e4  db0d              BLT      |L1.770|
0002e6  4555              CMP      r5,r10                ;229
0002e8  dc0b              BGT      |L1.770|
0002ea  46a1              MOV      r9,r4                 ;230
0002ec  455c              CMP      r4,r11
0002ee  da08              BGE      |L1.770|
0002f0  42af              CMP      r7,r5
0002f2  da06              BGE      |L1.770|
;;;232                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index + 1);
0002f4  1c61              ADDS     r1,r4,#1
0002f6  f1060030          ADD      r0,r6,#0x30
0002fa  f7fffffe          BL       GUI_ARRAY_GetpItem
;;;233                if (pColumn->Width == 0) {
0002fe  6800              LDR      r0,[r0,#0]
000300  b110              CBZ      r0,|L1.776|
                  |L1.770|
000302  1c64              ADDS     r4,r4,#1              ;225
000304  4544              CMP      r4,r8                 ;225
000306  dbe4              BLT      |L1.722|
                  |L1.776|
;;;234                  break;
;;;235                }
;;;236              }
;;;237            }
;;;238          }
;;;239        }
;;;240      }
;;;241      return Item;
000308  4648              MOV      r0,r9
;;;242    }
00030a  e8bd8ff8          POP      {r3-r11,pc}
;;;243    #endif
                          ENDP

                  HEADER_SetItemWidth PROC
;;;792    */
;;;793    void HEADER_SetItemWidth(HEADER_Handle hObj, unsigned int Index, int Width) {
00030e  b5f0              PUSH     {r4-r7,lr}
000310  b083              SUB      sp,sp,#0xc
000312  4604              MOV      r4,r0
000314  460f              MOV      r7,r1
000316  4615              MOV      r5,r2
;;;794      if (hObj && (Width >= 0)) {
000318  2c00              CMP      r4,#0
00031a  d02f              BEQ      |L1.892|
00031c  2d00              CMP      r5,#0
00031e  db2d              BLT      |L1.892|
;;;795        HEADER_Obj * pObj;
;;;796        WM_LOCK();
000320  f7fffffe          BL       GUI_Lock
;;;797        pObj = HEADER_H2P(hObj);
000324  4620              MOV      r0,r4
000326  f7fffffe          BL       GUI_ALLOC_h2p
00032a  4606              MOV      r6,r0
;;;798        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
00032c  f1060030          ADD      r0,r6,#0x30
000330  f7fffffe          BL       GUI_ARRAY_GetNumItems
000334  42b8              CMP      r0,r7
000336  d31c              BCC      |L1.882|
;;;799          HEADER_COLUMN * pColumn;
;;;800          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000338  4639              MOV      r1,r7
00033a  f1060030          ADD      r0,r6,#0x30
00033e  f7fffffe          BL       GUI_ARRAY_GetpItem
;;;801          if (pColumn) {
000342  b1b0              CBZ      r0,|L1.882|
;;;802            WM_MESSAGE Msg;
;;;803            pColumn->Width = Width;
000344  6005              STR      r5,[r0,#0]
;;;804            Msg.hWin  = WM_GetParent(hObj);
000346  4620              MOV      r0,r4
000348  f7fffffe          BL       WM_GetParent
00034c  f8ad0004          STRH     r0,[sp,#4]
;;;805            Msg.MsgId = WM_NOTIFY_CLIENTCHANGE;
000350  2025              MOVS     r0,#0x25
000352  9000              STR      r0,[sp,#0]
;;;806            Msg.hWinSrc = hObj;
000354  f8ad4006          STRH     r4,[sp,#6]
;;;807            WM_InvalidateWindow(hObj);
000358  4620              MOV      r0,r4
00035a  f7fffffe          BL       WM_InvalidateWindow
;;;808            WM__SendMessage(Msg.hWin, &Msg);
00035e  f9bd0004          LDRSH    r0,[sp,#4]
000362  4669              MOV      r1,sp
000364  f7fffffe          BL       WM__SendMessage
;;;809            //WM__SendMsgNoData(WM_GetParent(hObj), WM_NOTIFY_CLIENTCHANGE);
;;;810            WM_InvalidateWindow(WM_GetParent(hObj));
000368  4620              MOV      r0,r4
00036a  f7fffffe          BL       WM_GetParent
00036e  f7fffffe          BL       WM_InvalidateWindow
                  |L1.882|
;;;811          }
;;;812        }
;;;813        WM_UNLOCK();
000372  b003              ADD      sp,sp,#0xc
000374  e8bd40f0          POP      {r4-r7,lr}
000378  f7ffbffe          B.W      GUI_Unlock
                  |L1.892|
;;;814      }
;;;815    }
00037c  b003              ADD      sp,sp,#0xc
00037e  bdf0              POP      {r4-r7,pc}
;;;816    
                          ENDP

                  HEADER_GetItemWidth PROC
;;;835    */
;;;836    int HEADER_GetItemWidth(HEADER_Handle hObj, unsigned int Index) {
000380  b570              PUSH     {r4-r6,lr}
000382  4605              MOV      r5,r0
000384  460e              MOV      r6,r1
;;;837      int Width = 0;
000386  2400              MOVS     r4,#0
;;;838      if (hObj) {
000388  b19d              CBZ      r5,|L1.946|
;;;839        HEADER_Obj * pObj;
;;;840        WM_LOCK();
00038a  f7fffffe          BL       GUI_Lock
;;;841        pObj = HEADER_H2P(hObj);
00038e  4628              MOV      r0,r5
000390  f7fffffe          BL       GUI_ALLOC_h2p
000394  4605              MOV      r5,r0
;;;842        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000396  f1050030          ADD      r0,r5,#0x30
00039a  f7fffffe          BL       GUI_ARRAY_GetNumItems
00039e  42b0              CMP      r0,r6
0003a0  d305              BCC      |L1.942|
;;;843          HEADER_COLUMN * pColumn;
;;;844          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
0003a2  4631              MOV      r1,r6
0003a4  f1050030          ADD      r0,r5,#0x30
0003a8  f7fffffe          BL       GUI_ARRAY_GetpItem
;;;845          Width = pColumn->Width;
0003ac  6804              LDR      r4,[r0,#0]
                  |L1.942|
;;;846        }
;;;847        WM_UNLOCK();
0003ae  f7fffffe          BL       GUI_Unlock
                  |L1.946|
;;;848      }
;;;849      return Width;
0003b2  4620              MOV      r0,r4
;;;850    }
0003b4  bd70              POP      {r4-r6,pc}
;;;851    
                          ENDP

                  _LimitDragWitdh PROC
;;;255    */
;;;256    static int _LimitDragWitdh(HEADER_Handle hObj, HEADER_Obj * pObj) {
0003b6  e92d41f0          PUSH     {r4-r8,lr}
0003ba  b082              SUB      sp,sp,#8
0003bc  4680              MOV      r8,r0
0003be  460c              MOV      r4,r1
;;;257      if (pObj->DragLimit) {
0003c0  f8940050          LDRB     r0,[r4,#0x50]
0003c4  b3c8              CBZ      r0,|L1.1082|
;;;258        int DragLimit, i, SumX;
;;;259        GUI_RECT Rect;
;;;260        WM_HWIN hVScroll, hParent;
;;;261        /* Take the x-size of the widgets client rectangle as limit */
;;;262        WM_GetClientRectEx(hObj, &Rect);
0003c6  4669              MOV      r1,sp
0003c8  4640              MOV      r0,r8
0003ca  f7fffffe          BL       WM_GetClientRectEx
;;;263        DragLimit = Rect.x1;
0003ce  f9bd7004          LDRSH    r7,[sp,#4]
;;;264        /* If the parent window has a vertical scrollbar, reduce the drag limit by the xsize of the scrollbar */
;;;265        hParent = WM_GetParent(hObj);
0003d2  4640              MOV      r0,r8
0003d4  f7fffffe          BL       WM_GetParent
;;;266        if (hParent) {
0003d8  b140              CBZ      r0,|L1.1004|
;;;267          hVScroll = WM_GetScrollbarV(WM_GetParent(hObj));
0003da  4640              MOV      r0,r8
0003dc  f7fffffe          BL       WM_GetParent
0003e0  f7fffffe          BL       WM_GetScrollbarV
;;;268          if (hVScroll) {
0003e4  b110              CBZ      r0,|L1.1004|
;;;269            DragLimit -= WM_GetWindowSizeX(hVScroll);
0003e6  f7fffffe          BL       WM_GetWindowSizeX
0003ea  1a3f              SUBS     r7,r7,r0
                  |L1.1004|
;;;270          }
;;;271        }
;;;272        /* Calculate the sum of the width of all header items */
;;;273        for (SumX = i = 0; i <= pObj->CaptureItem; i++) {
0003ec  2500              MOVS     r5,#0
0003ee  462e              MOV      r6,r5
0003f0  6ba0              LDR      r0,[r4,#0x38]
0003f2  2800              CMP      r0,#0
0003f4  db08              BLT      |L1.1032|
                  |L1.1014|
;;;274          SumX += HEADER_GetItemWidth(hObj, i);
0003f6  4629              MOV      r1,r5
0003f8  4640              MOV      r0,r8
0003fa  f7fffffe          BL       HEADER_GetItemWidth
0003fe  4406              ADD      r6,r6,r0
000400  1c6d              ADDS     r5,r5,#1              ;273
000402  6ba0              LDR      r0,[r4,#0x38]         ;273
000404  42a8              CMP      r0,r5                 ;273
000406  daf6              BGE      |L1.1014|
                  |L1.1032|
;;;275        }
;;;276        /* If the sum of the width of all header items exeeds the limit, limit the captured item */
;;;277        if (SumX > DragLimit) {
000408  42be              CMP      r6,r7
00040a  dd17              BLE      |L1.1084|
;;;278          for (SumX = i = 0; i < pObj->CaptureItem; i++) {
00040c  2500              MOVS     r5,#0
00040e  462e              MOV      r6,r5
000410  6ba0              LDR      r0,[r4,#0x38]
000412  2800              CMP      r0,#0
000414  dd08              BLE      |L1.1064|
                  |L1.1046|
;;;279            SumX += HEADER_GetItemWidth(hObj, i);
000416  4629              MOV      r1,r5
000418  4640              MOV      r0,r8
00041a  f7fffffe          BL       HEADER_GetItemWidth
00041e  4406              ADD      r6,r6,r0
000420  1c6d              ADDS     r5,r5,#1              ;278
000422  6ba0              LDR      r0,[r4,#0x38]         ;278
000424  42a8              CMP      r0,r5                 ;278
000426  dcf6              BGT      |L1.1046|
                  |L1.1064|
;;;280          }
;;;281          HEADER_SetItemWidth(hObj, pObj->CaptureItem, DragLimit - SumX);
000428  1bba              SUBS     r2,r7,r6
00042a  4640              MOV      r0,r8
00042c  6ba1              LDR      r1,[r4,#0x38]
00042e  f7fffffe          BL       HEADER_SetItemWidth
;;;282          return 1;
;;;283        }
;;;284      }
;;;285      return 0;
;;;286    }
000432  b002              ADD      sp,sp,#8
000434  2001              MOVS     r0,#1                 ;282
000436  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1082|
00043a  e7ff              B        |L1.1084|
                  |L1.1084|
00043c  b002              ADD      sp,sp,#8
00043e  2000              MOVS     r0,#0                 ;285
000440  e8bd81f0          POP      {r4-r8,pc}
;;;287    
                          ENDP

                  _HandlePID PROC
;;;292    #if (HEADER_SUPPORT_DRAG)
;;;293    static void _HandlePID(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y, int Pressed) {
000444  e92d41f0          PUSH     {r4-r8,lr}
000448  4680              MOV      r8,r0
00044a  9d06              LDR      r5,[sp,#0x18]
00044c  460c              MOV      r4,r1
00044e  4616              MOV      r6,r2
;;;294      int Hit = _GetDividerIndex(hObj, pObj, x, y);
000450  4632              MOV      r2,r6
000452  4621              MOV      r1,r4
000454  4640              MOV      r0,r8
000456  f7fffffe          BL       _GetDividerIndex
;;;295      /* set capture position */
;;;296      if ((Pressed == 1) && (Hit >= 0) && (pObj->CapturePosX == -1)) {
00045a  2d01              CMP      r5,#1
00045c  d106              BNE      |L1.1132|
00045e  2800              CMP      r0,#0
000460  db04              BLT      |L1.1132|
000462  6b61              LDR      r1,[r4,#0x34]
000464  1c49              ADDS     r1,r1,#1
000466  d101              BNE      |L1.1132|
;;;297        pObj->CapturePosX = x;
000468  6366              STR      r6,[r4,#0x34]
;;;298        pObj->CaptureItem = Hit;
00046a  63a0              STR      r0,[r4,#0x38]
                  |L1.1132|
00046c  f04f37ff          MOV      r7,#0xffffffff        ;296
;;;299      }
;;;300      if (Pressed <= 0) {
000470  2d00              CMP      r5,#0
000472  dc00              BGT      |L1.1142|
;;;301        pObj->CapturePosX = -1;
000474  6367              STR      r7,[r4,#0x34]
                  |L1.1142|
;;;302      }
;;;303      /* set mouse cursor and capture */
;;;304      if (Hit >= 0) {
000476  2800              CMP      r0,#0
000478  db03              BLT      |L1.1154|
;;;305        WM_SetCapture(hObj, 1);
00047a  2101              MOVS     r1,#1
00047c  4640              MOV      r0,r8
00047e  f7fffffe          BL       WM_SetCapture
                  |L1.1154|
;;;306        #if GUI_SUPPORT_CURSOR
;;;307          if (!_pOldCursor) {
;;;308            _pOldCursor = GUI_CURSOR_Select(_pDefaultCursor);
;;;309          }
;;;310        #endif
;;;311      }
;;;312      /* modify header */
;;;313      if ((pObj->CapturePosX >= 0) && (x != pObj->CapturePosX) && (Pressed == 1)) {
000482  6b60              LDR      r0,[r4,#0x34]
000484  2800              CMP      r0,#0
000486  db1c              BLT      |L1.1218|
000488  42b0              CMP      r0,r6
00048a  d01a              BEQ      |L1.1218|
00048c  2d01              CMP      r5,#1
00048e  d118              BNE      |L1.1218|
;;;314        int NewSize = HEADER_GetItemWidth(hObj, pObj->CaptureItem) + x - pObj->CapturePosX;
000490  4640              MOV      r0,r8
000492  6ba1              LDR      r1,[r4,#0x38]
000494  e004              B        |L1.1184|
000496  0000              DCW      0x0000
                  |L1.1176|
                          DCD      0x55555556
                  |L1.1180|
                          DCD      ||.data||
                  |L1.1184|
0004a0  f7fffffe          BL       HEADER_GetItemWidth
0004a4  6b61              LDR      r1,[r4,#0x34]
0004a6  4430              ADD      r0,r0,r6
0004a8  1a42              SUBS     r2,r0,r1
;;;315        if (NewSize >= 0) {
0004aa  2a00              CMP      r2,#0
0004ac  db09              BLT      |L1.1218|
;;;316          HEADER_SetItemWidth(hObj, pObj->CaptureItem, NewSize);
0004ae  4640              MOV      r0,r8
0004b0  6ba1              LDR      r1,[r4,#0x38]
0004b2  f7fffffe          BL       HEADER_SetItemWidth
;;;317          if (!_LimitDragWitdh(hObj, pObj)) {
0004b6  4621              MOV      r1,r4
0004b8  4640              MOV      r0,r8
0004ba  f7fffffe          BL       _LimitDragWitdh
0004be  b900              CBNZ     r0,|L1.1218|
;;;318            pObj->CapturePosX = x;
0004c0  6366              STR      r6,[r4,#0x34]
                  |L1.1218|
;;;319          }
;;;320        }
;;;321      }
;;;322      /* release capture & restore cursor */
;;;323      if (Pressed <= 0) {
0004c2  2d00              CMP      r5,#0
0004c4  dc06              BGT      |L1.1236|
;;;324        #if (GUI_SUPPORT_MOUSE)
;;;325        if (Hit == -1)
;;;326        #endif
;;;327        {
;;;328          _RestoreOldCursor();
0004c6  f7fffffe          BL       _RestoreOldCursor
;;;329          pObj->CapturePosX = -1;
0004ca  6367              STR      r7,[r4,#0x34]
;;;330          WM_ReleaseCapture();
0004cc  e8bd41f0          POP      {r4-r8,lr}
0004d0  f7ffbffe          B.W      WM_ReleaseCapture
                  |L1.1236|
;;;331        }
;;;332      }
;;;333    }
0004d4  e8bd81f0          POP      {r4-r8,pc}
;;;334    #endif
                          ENDP

                  _GetItemIndex PROC
;;;352    */
;;;353    static int _GetItemIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
0004d8  e92d47f0          PUSH     {r4-r10,lr}
0004dc  4605              MOV      r5,r0
0004de  460f              MOV      r7,r1
0004e0  4616              MOV      r6,r2
0004e2  461c              MOV      r4,r3
;;;354      int Item = -1;
0004e4  f04f39ff          MOV      r9,#0xffffffff
;;;355      if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
0004e8  2c00              CMP      r4,#0
0004ea  db23              BLT      |L1.1332|
0004ec  4628              MOV      r0,r5
0004ee  f7fffffe          BL       WM_GetWindowSizeY
0004f2  42a0              CMP      r0,r4
0004f4  dd1e              BLE      |L1.1332|
;;;356        if (hObj) {
0004f6  b1ed              CBZ      r5,|L1.1332|
;;;357          int Index, xPos = 0, NumColumns;
0004f8  2400              MOVS     r4,#0
;;;358          NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
0004fa  f1070030          ADD      r0,r7,#0x30
0004fe  f7fffffe          BL       GUI_ARRAY_GetNumItems
000502  4680              MOV      r8,r0
;;;359          for (Index = 0; Index < NumColumns; Index++) {
000504  2500              MOVS     r5,#0
000506  f1b80f00          CMP      r8,#0
00050a  dd13              BLE      |L1.1332|
                  |L1.1292|
;;;360            HEADER_COLUMN * pColumn;
;;;361            pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
00050c  4629              MOV      r1,r5
00050e  f1070030          ADD      r0,r7,#0x30
000512  f7fffffe          BL       GUI_ARRAY_GetpItem
;;;362            if ((x > (xPos + 4)) && (x < (xPos + pColumn->Width - 4))) {
000516  1d21              ADDS     r1,r4,#4
000518  428e              CMP      r6,r1
00051a  dd06              BLE      |L1.1322|
00051c  6801              LDR      r1,[r0,#0]
00051e  1f22              SUBS     r2,r4,#4
000520  4411              ADD      r1,r1,r2
000522  42b1              CMP      r1,r6
000524  dd01              BLE      |L1.1322|
;;;363              Item = Index;
000526  46a9              MOV      r9,r5
;;;364              break;
000528  e004              B        |L1.1332|
                  |L1.1322|
;;;365            }
;;;366            xPos += pColumn->Width;
00052a  6800              LDR      r0,[r0,#0]
00052c  4404              ADD      r4,r4,r0
00052e  1c6d              ADDS     r5,r5,#1              ;359
000530  4545              CMP      r5,r8                 ;359
000532  dbeb              BLT      |L1.1292|
                  |L1.1332|
;;;367          }
;;;368        }
;;;369      }
;;;370      return Item;
000534  4648              MOV      r0,r9
;;;371    }
000536  e8bd87f0          POP      {r4-r10,pc}
;;;372    
                          ENDP

                  _OnTouch PROC
;;;377    #if (HEADER_SUPPORT_DRAG)
;;;378    static void _OnTouch(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
00053a  b5f8              PUSH     {r3-r7,lr}
00053c  4606              MOV      r6,r0
00053e  4615              MOV      r5,r2
;;;379      int Notification;
;;;380      const GUI_PID_STATE * pState = (const GUI_PID_STATE *)pMsg->Data.p;
000540  68ac              LDR      r4,[r5,#8]
;;;381      if (pState) {
000542  b144              CBZ      r4,|L1.1366|
;;;382        _HandlePID(hObj, pObj, pState->x + pObj->ScrollPos, pState->y, pState->Pressed);
000544  7a23              LDRB     r3,[r4,#8]
000546  9300              STR      r3,[sp,#0]
000548  6820              LDR      r0,[r4,#0]
00054a  6bca              LDR      r2,[r1,#0x3c]
00054c  6863              LDR      r3,[r4,#4]
00054e  4402              ADD      r2,r2,r0
000550  4630              MOV      r0,r6
000552  f7fffffe          BL       _HandlePID
                  |L1.1366|
;;;383      }
;;;384      if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
000556  68a8              LDR      r0,[r5,#8]
000558  b128              CBZ      r0,|L1.1382|
;;;385        if (pState->Pressed) {
00055a  7a20              LDRB     r0,[r4,#8]
00055c  b108              CBZ      r0,|L1.1378|
;;;386          Notification = WM_NOTIFICATION_CLICKED;
00055e  2101              MOVS     r1,#1
000560  e002              B        |L1.1384|
                  |L1.1378|
;;;387        } else {
;;;388          Notification = WM_NOTIFICATION_RELEASED;
000562  2102              MOVS     r1,#2
000564  e000              B        |L1.1384|
                  |L1.1382|
;;;389        }
;;;390      } else {
;;;391        Notification = WM_NOTIFICATION_MOVED_OUT;
000566  2103              MOVS     r1,#3
                  |L1.1384|
;;;392      }
;;;393      WM_NotifyParent(hObj, Notification);
000568  4630              MOV      r0,r6
00056a  e8bd40f8          POP      {r3-r7,lr}
00056e  f7ffbffe          B.W      WM_NotifyParent
;;;394    }
;;;395    #endif
                          ENDP

                  _OnPidStateChange PROC
;;;400    */
;;;401    static void _OnPidStateChange(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
000572  b510              PUSH     {r4,lr}
000574  460c              MOV      r4,r1
;;;402      const WM_PID_STATE_CHANGED_INFO * pState = (const WM_PID_STATE_CHANGED_INFO *)pMsg->Data.p;
000576  6893              LDR      r3,[r2,#8]
;;;403      if ((pState->StatePrev == 1) && (pState->State == 0)) {
000578  7a59              LDRB     r1,[r3,#9]
00057a  2901              CMP      r1,#1
00057c  d10a              BNE      |L1.1428|
00057e  7a19              LDRB     r1,[r3,#8]
000580  2900              CMP      r1,#0
000582  d107              BNE      |L1.1428|
;;;404        pObj->Sel = _GetItemIndex(hObj, pObj, pState->x + pObj->ScrollPos, pState->y);
000584  6819              LDR      r1,[r3,#0]
000586  6be2              LDR      r2,[r4,#0x3c]
000588  685b              LDR      r3,[r3,#4]
00058a  440a              ADD      r2,r2,r1
00058c  4621              MOV      r1,r4
00058e  f7fffffe          BL       _GetItemIndex
000592  6420              STR      r0,[r4,#0x40]
                  |L1.1428|
;;;405      }
;;;406    }
000594  bd10              POP      {r4,pc}
;;;407    
                          ENDP

                  HEADER_Callback PROC
;;;440    */
;;;441    void HEADER_Callback (WM_MESSAGE *pMsg) {
000596  b570              PUSH     {r4-r6,lr}
000598  4604              MOV      r4,r0
;;;442      HEADER_Handle hObj;
;;;443      HEADER_Obj * pObj;
;;;444      hObj = pMsg->hWin;
00059a  f9b45004          LDRSH    r5,[r4,#4]
;;;445      /* Let widget handle the standard messages */
;;;446      if (WIDGET_HandleActive(hObj, pMsg) == 0) {
00059e  4621              MOV      r1,r4
0005a0  4628              MOV      r0,r5
0005a2  f7fffffe          BL       WIDGET_HandleActive
0005a6  2800              CMP      r0,#0
0005a8  d027              BEQ      |L1.1530|
;;;447        return;
;;;448      }
;;;449      WM_LOCK();
0005aa  f7fffffe          BL       GUI_Lock
;;;450      pObj = (HEADER_Obj *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
0005ae  4628              MOV      r0,r5
0005b0  f7fffffe          BL       GUI_ALLOC_h2p
0005b4  4601              MOV      r1,r0
;;;451      switch (pMsg->MsgId) {
0005b6  6820              LDR      r0,[r4,#0]
0005b8  280b              CMP      r0,#0xb
0005ba  d014              BEQ      |L1.1510|
0005bc  280c              CMP      r0,#0xc
0005be  d00d              BEQ      |L1.1500|
0005c0  280f              CMP      r0,#0xf
0005c2  d002              BEQ      |L1.1482|
0005c4  2811              CMP      r0,#0x11
0005c6  d111              BNE      |L1.1516|
0005c8  e003              B        |L1.1490|
                  |L1.1482|
;;;452      case WM_PAINT:
;;;453        _Paint(pObj);
0005ca  4608              MOV      r0,r1
0005cc  f7fffffe          BL       _Paint
;;;454        break;
0005d0  e00f              B        |L1.1522|
                  |L1.1490|
;;;455      case WM_PID_STATE_CHANGED:
;;;456        _OnPidStateChange(hObj, pObj, pMsg);
0005d2  4622              MOV      r2,r4
0005d4  4628              MOV      r0,r5
0005d6  f7fffffe          BL       _OnPidStateChange
;;;457        break;
0005da  e00a              B        |L1.1522|
                  |L1.1500|
;;;458    #if (HEADER_SUPPORT_DRAG)
;;;459      case WM_TOUCH:
;;;460        _OnTouch(hObj, pObj, pMsg);
0005dc  4622              MOV      r2,r4
0005de  4628              MOV      r0,r5
0005e0  f7fffffe          BL       _OnTouch
;;;461        break;
0005e4  e005              B        |L1.1522|
                  |L1.1510|
;;;462    #endif
;;;463    #if (HEADER_SUPPORT_DRAG & GUI_SUPPORT_MOUSE)
;;;464      case WM_MOUSEOVER:
;;;465        _OnMouseOver(hObj, pObj, pMsg);
;;;466        break;
;;;467    #endif
;;;468      case WM_DELETE:
;;;469        _FreeAttached(pObj); /* No return here ... WM_DefaultProc needs to be called */
0005e6  4608              MOV      r0,r1
0005e8  f7fffffe          BL       _FreeAttached
                  |L1.1516|
;;;470      default:
;;;471        WM_DefaultProc(pMsg);
0005ec  4620              MOV      r0,r4
0005ee  f7fffffe          BL       WM_DefaultProc
                  |L1.1522|
;;;472      }
;;;473      WM_UNLOCK();
0005f2  e8bd4070          POP      {r4-r6,lr}
0005f6  f7ffbffe          B.W      GUI_Unlock
                  |L1.1530|
;;;474    }
0005fa  bd70              POP      {r4-r6,pc}
;;;475    
                          ENDP

                  HEADER_CreateEx PROC
;;;493    */
;;;494    HEADER_Handle HEADER_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
0005fc  e92d4ff0          PUSH     {r4-r11,lr}
;;;495                                  int WinFlags, int ExFlags, int Id)
;;;496    {
000600  b085              SUB      sp,sp,#0x14
000602  4604              MOV      r4,r0
000604  468b              MOV      r11,r1
000606  4616              MOV      r6,r2
000608  461d              MOV      r5,r3
00060a  f8dda038          LDR      r10,[sp,#0x38]
00060e  f8dd9044          LDR      r9,[sp,#0x44]
000612  9f0f              LDR      r7,[sp,#0x3c]
;;;497      HEADER_Handle hObj;
;;;498      GUI_USE_PARA(ExFlags);
;;;499      /* Create the window */
;;;500      WM_LOCK();
000614  f7fffffe          BL       GUI_Lock
;;;501      if ((xsize == 0) && (x0 == 0) && (y0 == 0)) {
000618  ea460004          ORR      r0,r6,r4
00061c  ea50000b          ORRS     r0,r0,r11
000620  d10b              BNE      |L1.1594|
;;;502        GUI_RECT Rect;
;;;503        WM_GetInsideRectEx(hParent, &Rect);
000622  a902              ADD      r1,sp,#8
000624  4650              MOV      r0,r10
000626  f7fffffe          BL       WM_GetInsideRectEx
;;;504        xsize = Rect.x1 - Rect.x0 + 1;
00062a  f9bd000c          LDRSH    r0,[sp,#0xc]
00062e  f9bd4008          LDRSH    r4,[sp,#8]
000632  1b00              SUBS     r0,r0,r4
000634  1c46              ADDS     r6,r0,#1
;;;505        x0    = Rect.x0;
;;;506        y0    = Rect.y0;
000636  f9bdb00a          LDRSH    r11,[sp,#0xa]
                  |L1.1594|
;;;507      }
;;;508      if (ysize == 0) {
;;;509        const WIDGET_EFFECT* pEffect = WIDGET_GetDefaultEffect();
;;;510        ysize  = GUI_GetYDistOfFont(_pDefaultFont);
00063a  f8df8408          LDR      r8,|L1.2628|
00063e  b96d              CBNZ     r5,|L1.1628|
000640  f7fffffe          BL       WIDGET_GetDefaultEffect
000644  4605              MOV      r5,r0                 ;509
000646  f8d80014          LDR      r0,[r8,#0x14]  ; _pDefaultFont
00064a  f7fffffe          BL       GUI_GetYDistOfFont
;;;511        ysize += 2 * _DefaultBorderV;
00064e  f8d81010          LDR      r1,[r8,#0x10]  ; _DefaultBorderV
000652  eb000041          ADD      r0,r0,r1,LSL #1
;;;512        ysize += 2 * (unsigned)pEffect->EffectSize;
000656  6969              LDR      r1,[r5,#0x14]
000658  eb000541          ADD      r5,r0,r1,LSL #1
                  |L1.1628|
;;;513      }
;;;514      WinFlags |= WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_RIGHT;
00065c  f4477020          ORR      r0,r7,#0x280
;;;515      hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &HEADER_Callback,
000660  2334              MOVS     r3,#0x34
000662  f2af02cd          ADR      r2,HEADER_Callback + 1
000666  b281              UXTH     r1,r0
000668  9303              STR      r3,[sp,#0xc]
00066a  9202              STR      r2,[sp,#8]
00066c  9101              STR      r1,[sp,#4]
00066e  f8cda000          STR      r10,[sp,#0]
000672  462b              MOV      r3,r5
000674  4632              MOV      r2,r6
000676  4659              MOV      r1,r11
000678  4620              MOV      r0,r4
00067a  f7fffffe          BL       WM_CreateWindowAsChild
00067e  4605              MOV      r5,r0
;;;516                                    sizeof(HEADER_Obj) - sizeof(WM_Obj));
;;;517      if (hObj) {
000680  b1c5              CBZ      r5,|L1.1716|
;;;518        HEADER_Obj * pObj;
;;;519        pObj = (HEADER_Obj *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
000682  4628              MOV      r0,r5
000684  f7fffffe          BL       GUI_ALLOC_h2p
000688  4604              MOV      r4,r0
;;;520        /* Init sub-classes */
;;;521        GUI_ARRAY_CREATE(&pObj->Columns);
;;;522        /* init widget specific variables */
;;;523        WIDGET__Init(&pObj->Widget, Id, 0);
00068a  2200              MOVS     r2,#0
00068c  4649              MOV      r1,r9
00068e  4620              MOV      r0,r4
000690  f7fffffe          BL       WIDGET__Init
;;;524        /* init member variables */
;;;525        HEADER_INIT_ID(pObj);
;;;526        pObj->BkColor     = _DefaultBkColor;
000694  f8d80004          LDR      r0,[r8,#4]  ; _DefaultBkColor
000698  62a0              STR      r0,[r4,#0x28]
;;;527        pObj->TextColor   = _DefaultTextColor;
00069a  f8d80008          LDR      r0,[r8,#8]  ; _DefaultTextColor
00069e  62e0              STR      r0,[r4,#0x2c]
;;;528        pObj->pFont       = _pDefaultFont;
0006a0  f8d80014          LDR      r0,[r8,#0x14]  ; _pDefaultFont
0006a4  64e0              STR      r0,[r4,#0x4c]
;;;529        pObj->CapturePosX = -1;
0006a6  f04f31ff          MOV      r1,#0xffffffff
0006aa  6361              STR      r1,[r4,#0x34]
;;;530        pObj->CaptureItem = -1;
0006ac  63a1              STR      r1,[r4,#0x38]
;;;531        pObj->ScrollPos   = 0;
0006ae  2000              MOVS     r0,#0
0006b0  63e0              STR      r0,[r4,#0x3c]
;;;532        pObj->DirIndicatorColumn = -1;
0006b2  6461              STR      r1,[r4,#0x44]
                  |L1.1716|
;;;533      } else {
;;;534        GUI_DEBUG_ERROROUT_IF(hObj==0, "HEADER_Create failed")
;;;535      }
;;;536      WM_UNLOCK();
0006b4  f7fffffe          BL       GUI_Unlock
;;;537      return hObj;
;;;538    }
0006b8  b005              ADD      sp,sp,#0x14
0006ba  4628              MOV      r0,r5                 ;537
0006bc  e8bd8ff0          POP      {r4-r11,pc}
;;;539    
                          ENDP

                  HEADER_Create PROC
;;;485    */
;;;486    HEADER_Handle HEADER_Create(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int Id, int Flags, int ExFlags) {
0006c0  b570              PUSH     {r4-r6,lr}
0006c2  b084              SUB      sp,sp,#0x10
0006c4  4684              MOV      r12,r0
0006c6  460c              MOV      r4,r1
0006c8  4615              MOV      r5,r2
0006ca  461e              MOV      r6,r3
0006cc  9b09              LDR      r3,[sp,#0x24]
0006ce  9a0b              LDR      r2,[sp,#0x2c]
0006d0  990a              LDR      r1,[sp,#0x28]
0006d2  9808              LDR      r0,[sp,#0x20]
;;;487      return HEADER_CreateEx(x0, y0, xsize, ysize, hParent, Flags, ExFlags, Id);
0006d4  e88d000f          STM      sp,{r0-r3}
0006d8  4633              MOV      r3,r6
0006da  462a              MOV      r2,r5
0006dc  4621              MOV      r1,r4
0006de  4660              MOV      r0,r12
0006e0  f7fffffe          BL       HEADER_CreateEx
;;;488    }
0006e4  b004              ADD      sp,sp,#0x10
0006e6  bd70              POP      {r4-r6,pc}
;;;489    
                          ENDP

                  HEADER_SetDefaultCursor PROC
;;;549    */
;;;550    const GUI_CURSOR GUI_UNI_PTR * HEADER_SetDefaultCursor(const GUI_CURSOR * pCursor) {
0006e8  4ad6              LDR      r2,|L1.2628|
;;;551      const GUI_CURSOR GUI_UNI_PTR * pOldCursor = _pDefaultCursor;
0006ea  6811              LDR      r1,[r2,#0]  ; _pDefaultCursor
;;;552      _pDefaultCursor = pCursor;
0006ec  6010              STR      r0,[r2,#0]  ; _pDefaultCursor
;;;553      return pOldCursor;
0006ee  4608              MOV      r0,r1
;;;554    }
0006f0  4770              BX       lr
;;;555    
                          ENDP

                  HEADER_SetDefaultBkColor PROC
;;;559    */
;;;560    GUI_COLOR HEADER_SetDefaultBkColor(GUI_COLOR Color) {
0006f2  4ad4              LDR      r2,|L1.2628|
;;;561      GUI_COLOR OldColor = _DefaultBkColor;
0006f4  6851              LDR      r1,[r2,#4]  ; _DefaultBkColor
;;;562      _DefaultBkColor = Color;
0006f6  6050              STR      r0,[r2,#4]  ; _DefaultBkColor
;;;563      return OldColor;
0006f8  4608              MOV      r0,r1
;;;564    }
0006fa  4770              BX       lr
;;;565    
                          ENDP

                  HEADER_SetDefaultTextColor PROC
;;;569    */
;;;570    GUI_COLOR HEADER_SetDefaultTextColor(GUI_COLOR Color) {
0006fc  4ad1              LDR      r2,|L1.2628|
;;;571      GUI_COLOR OldColor = _DefaultTextColor;
0006fe  6891              LDR      r1,[r2,#8]  ; _DefaultTextColor
;;;572      _DefaultTextColor = Color;
000700  6090              STR      r0,[r2,#8]  ; _DefaultTextColor
;;;573      return OldColor;
000702  4608              MOV      r0,r1
;;;574    }
000704  4770              BX       lr
;;;575    
                          ENDP

                  HEADER_SetDefaultBorderH PROC
;;;579    */
;;;580    int HEADER_SetDefaultBorderH(int Spacing) {
000706  4acf              LDR      r2,|L1.2628|
;;;581      int OldSpacing = _DefaultBorderH;
000708  68d1              LDR      r1,[r2,#0xc]  ; _DefaultBorderH
;;;582      _DefaultBorderH = Spacing;
00070a  60d0              STR      r0,[r2,#0xc]  ; _DefaultBorderH
;;;583      return OldSpacing;
00070c  4608              MOV      r0,r1
;;;584    }
00070e  4770              BX       lr
;;;585    
                          ENDP

                  HEADER_SetDefaultBorderV PROC
;;;589    */
;;;590    int HEADER_SetDefaultBorderV(int Spacing) {
000710  4acc              LDR      r2,|L1.2628|
;;;591      int OldSpacing = _DefaultBorderV;
000712  6911              LDR      r1,[r2,#0x10]  ; _DefaultBorderV
;;;592      _DefaultBorderV = Spacing;
000714  6110              STR      r0,[r2,#0x10]  ; _DefaultBorderV
;;;593      return OldSpacing;
000716  4608              MOV      r0,r1
;;;594    }
000718  4770              BX       lr
;;;595    
                          ENDP

                  HEADER_SetDefaultFont PROC
;;;599    */
;;;600    const GUI_FONT GUI_UNI_PTR * HEADER_SetDefaultFont(const GUI_FONT GUI_UNI_PTR * pFont) {
00071a  4aca              LDR      r2,|L1.2628|
;;;601      const GUI_FONT GUI_UNI_PTR * pOldFont = _pDefaultFont;
00071c  6951              LDR      r1,[r2,#0x14]  ; _pDefaultFont
;;;602      _pDefaultFont = pFont;
00071e  6150              STR      r0,[r2,#0x14]  ; _pDefaultFont
;;;603      return pOldFont;
000720  4608              MOV      r0,r1
;;;604    }
000722  4770              BX       lr
;;;605    
                          ENDP

                  HEADER_GetDefaultCursor PROC
;;;609    */
;;;610    const GUI_CURSOR GUI_UNI_PTR *  HEADER_GetDefaultCursor(void)    { return _pDefaultCursor; }
000724  48c7              LDR      r0,|L1.2628|
000726  6800              LDR      r0,[r0,#0]  ; _pDefaultCursor
000728  4770              BX       lr
;;;611    GUI_COLOR          HEADER_GetDefaultBkColor(void)   { return _DefaultBkColor; }
                          ENDP

                  HEADER_GetDefaultBkColor PROC
00072a  48c6              LDR      r0,|L1.2628|
00072c  6840              LDR      r0,[r0,#4]  ; _DefaultBkColor
00072e  4770              BX       lr
;;;612    GUI_COLOR          HEADER_GetDefaultTextColor(void) { return _DefaultTextColor; }
                          ENDP

                  HEADER_GetDefaultTextColor PROC
000730  48c4              LDR      r0,|L1.2628|
000732  6880              LDR      r0,[r0,#8]  ; _DefaultTextColor
000734  4770              BX       lr
;;;613    int                HEADER_GetDefaultBorderH(void)   { return _DefaultBorderH; }
                          ENDP

                  HEADER_GetDefaultBorderH PROC
000736  48c3              LDR      r0,|L1.2628|
000738  68c0              LDR      r0,[r0,#0xc]  ; _DefaultBorderH
00073a  4770              BX       lr
;;;614    int                HEADER_GetDefaultBorderV(void)   { return _DefaultBorderV; }
                          ENDP

                  HEADER_GetDefaultBorderV PROC
00073c  48c1              LDR      r0,|L1.2628|
00073e  6900              LDR      r0,[r0,#0x10]  ; _DefaultBorderV
000740  4770              BX       lr
;;;615    const GUI_FONT GUI_UNI_PTR *    HEADER_GetDefaultFont(void)      { return _pDefaultFont; }
                          ENDP

                  HEADER_GetDefaultFont PROC
000742  48c0              LDR      r0,|L1.2628|
000744  6940              LDR      r0,[r0,#0x14]  ; _pDefaultFont
000746  4770              BX       lr
;;;616    
                          ENDP

                  HEADER_SetHeight PROC
;;;642    */
;;;643    void HEADER_SetHeight(HEADER_Handle hObj, int Height) {
000748  b530              PUSH     {r4,r5,lr}
00074a  b083              SUB      sp,sp,#0xc
00074c  4604              MOV      r4,r0
00074e  460d              MOV      r5,r1
;;;644      if (hObj) {
000750  2c00              CMP      r4,#0
000752  d012              BEQ      |L1.1914|
;;;645        GUI_RECT Rect;
;;;646        WM_GetClientRectEx(hObj, &Rect);
000754  4669              MOV      r1,sp
000756  4620              MOV      r0,r4
000758  f7fffffe          BL       WM_GetClientRectEx
;;;647        WM_SetSize(hObj, Rect.x1 - Rect.x0 + 1, Height);
00075c  f9bd1004          LDRSH    r1,[sp,#4]
000760  f9bd3000          LDRSH    r3,[sp,#0]
000764  462a              MOV      r2,r5
000766  1ac9              SUBS     r1,r1,r3
000768  1c49              ADDS     r1,r1,#1
00076a  4620              MOV      r0,r4
00076c  f7fffffe          BL       WM_SetSize
;;;648        WM_InvalidateWindow(WM_GetParent(hObj));
000770  4620              MOV      r0,r4
000772  f7fffffe          BL       WM_GetParent
000776  f7fffffe          BL       WM_InvalidateWindow
                  |L1.1914|
;;;649      }
;;;650    }
00077a  b003              ADD      sp,sp,#0xc
00077c  bd30              POP      {r4,r5,pc}
;;;651    
                          ENDP

                  HEADER_SetFont PROC
;;;626    */
;;;627    void HEADER_SetFont(HEADER_Handle hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
00077e  b570              PUSH     {r4-r6,lr}
000780  4606              MOV      r6,r0
000782  460d              MOV      r5,r1
;;;628      if (hObj) {
000784  2e00              CMP      r6,#0
000786  d017              BEQ      |L1.1976|
;;;629        HEADER_Obj * pObj;
;;;630        WM_LOCK();
000788  f7fffffe          BL       GUI_Lock
;;;631        pObj = HEADER_H2P(hObj);
00078c  4630              MOV      r0,r6
00078e  f7fffffe          BL       GUI_ALLOC_h2p
000792  4604              MOV      r4,r0
;;;632        pObj->pFont = pFont;
000794  64e5              STR      r5,[r4,#0x4c]
;;;633        HEADER_SetHeight(hObj, GUI_GetYDistOfFont(pFont) + 2 * HEADER_BORDER_V_DEFAULT + 2 * pObj->Widget.pEffect->EffectSize);
000796  4628              MOV      r0,r5
000798  f7fffffe          BL       GUI_GetYDistOfFont
00079c  6a21              LDR      r1,[r4,#0x20]
00079e  6949              LDR      r1,[r1,#0x14]
0007a0  eb000141          ADD      r1,r0,r1,LSL #1
0007a4  4630              MOV      r0,r6
0007a6  f7fffffe          BL       HEADER_SetHeight
;;;634        WM_InvalidateWindow(hObj);
0007aa  4630              MOV      r0,r6
0007ac  f7fffffe          BL       WM_InvalidateWindow
;;;635        WM_UNLOCK();
0007b0  e8bd4070          POP      {r4-r6,lr}
0007b4  f7ffbffe          B.W      GUI_Unlock
                  |L1.1976|
;;;636      }
;;;637    }
0007b8  bd70              POP      {r4-r6,pc}
;;;638    
                          ENDP

                  HEADER_SetTextColor PROC
;;;655    */
;;;656    void HEADER_SetTextColor(HEADER_Handle hObj, GUI_COLOR Color) {
0007ba  b570              PUSH     {r4-r6,lr}
0007bc  4605              MOV      r5,r0
0007be  460c              MOV      r4,r1
;;;657      if (hObj) {
0007c0  2d00              CMP      r5,#0
0007c2  d00c              BEQ      |L1.2014|
;;;658        HEADER_Obj * pObj;
;;;659        WM_LOCK();
0007c4  f7fffffe          BL       GUI_Lock
;;;660        pObj = HEADER_H2P(hObj);
0007c8  4628              MOV      r0,r5
0007ca  f7fffffe          BL       GUI_ALLOC_h2p
;;;661        pObj->TextColor = Color;
0007ce  62c4              STR      r4,[r0,#0x2c]
;;;662        WM_InvalidateWindow(hObj);
0007d0  4628              MOV      r0,r5
0007d2  f7fffffe          BL       WM_InvalidateWindow
;;;663        WM_UNLOCK();
0007d6  e8bd4070          POP      {r4-r6,lr}
0007da  f7ffbffe          B.W      GUI_Unlock
                  |L1.2014|
;;;664      }
;;;665    }
0007de  bd70              POP      {r4-r6,pc}
;;;666    
                          ENDP

                  HEADER_SetBkColor PROC
;;;670    */
;;;671    void HEADER_SetBkColor(HEADER_Handle hObj, GUI_COLOR Color) {
0007e0  b570              PUSH     {r4-r6,lr}
0007e2  4605              MOV      r5,r0
0007e4  460c              MOV      r4,r1
;;;672      if (hObj) {
0007e6  2d00              CMP      r5,#0
0007e8  d00c              BEQ      |L1.2052|
;;;673        HEADER_Obj * pObj;
;;;674        WM_LOCK();
0007ea  f7fffffe          BL       GUI_Lock
;;;675        pObj = HEADER_H2P(hObj);
0007ee  4628              MOV      r0,r5
0007f0  f7fffffe          BL       GUI_ALLOC_h2p
;;;676        pObj->BkColor = Color;
0007f4  6284              STR      r4,[r0,#0x28]
;;;677        WM_InvalidateWindow(hObj);
0007f6  4628              MOV      r0,r5
0007f8  f7fffffe          BL       WM_InvalidateWindow
;;;678        WM_UNLOCK();
0007fc  e8bd4070          POP      {r4-r6,lr}
000800  f7ffbffe          B.W      GUI_Unlock
                  |L1.2052|
;;;679      }
;;;680    }
000804  bd70              POP      {r4-r6,pc}
;;;681    
                          ENDP

                  HEADER_SetTextAlign PROC
;;;685    */
;;;686    void HEADER_SetTextAlign(HEADER_Handle hObj, unsigned int Index, int Align) {
000806  e92d41f0          PUSH     {r4-r8,lr}
00080a  4607              MOV      r7,r0
00080c  460d              MOV      r5,r1
00080e  4616              MOV      r6,r2
;;;687      if (hObj) {
000810  2f00              CMP      r7,#0
000812  d018              BEQ      |L1.2118|
;;;688        HEADER_Obj * pObj;
;;;689        WM_LOCK();
000814  f7fffffe          BL       GUI_Lock
;;;690        pObj = HEADER_H2P(hObj);
000818  4638              MOV      r0,r7
00081a  f7fffffe          BL       GUI_ALLOC_h2p
00081e  4604              MOV      r4,r0
;;;691        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000820  f1040030          ADD      r0,r4,#0x30
000824  f7fffffe          BL       GUI_ARRAY_GetNumItems
000828  42a8              CMP      r0,r5
00082a  d308              BCC      |L1.2110|
;;;692          HEADER_COLUMN * pColumn;
;;;693          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
00082c  4629              MOV      r1,r5
00082e  f1040030          ADD      r0,r4,#0x30
000832  f7fffffe          BL       GUI_ARRAY_GetpItem
;;;694          pColumn->Align = Align;
000836  8086              STRH     r6,[r0,#4]
;;;695          WM_InvalidateWindow(hObj);
000838  4638              MOV      r0,r7
00083a  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2110|
;;;696        }
;;;697        WM_UNLOCK();
00083e  e8bd41f0          POP      {r4-r8,lr}
000842  f7ffbffe          B.W      GUI_Unlock
                  |L1.2118|
;;;698      }
;;;699    }
000846  e8bd81f0          POP      {r4-r8,pc}
;;;700    
                          ENDP

                  HEADER_SetScrollPos PROC
;;;704    */
;;;705    void HEADER_SetScrollPos(HEADER_Handle hObj, int ScrollPos) {
00084a  b570              PUSH     {r4-r6,lr}
00084c  4605              MOV      r5,r0
00084e  460c              MOV      r4,r1
;;;706      if (hObj && (ScrollPos >= 0)) {
000850  2d00              CMP      r5,#0
000852  d016              BEQ      |L1.2178|
000854  2c00              CMP      r4,#0
000856  db14              BLT      |L1.2178|
;;;707        HEADER_Obj* pObj;
;;;708        WM_LOCK();
000858  f7fffffe          BL       GUI_Lock
;;;709        pObj = HEADER_H2P(hObj);
00085c  4628              MOV      r0,r5
00085e  f7fffffe          BL       GUI_ALLOC_h2p
;;;710        if (ScrollPos != pObj->ScrollPos) {
000862  6bc1              LDR      r1,[r0,#0x3c]
000864  42a1              CMP      r1,r4
000866  d008              BEQ      |L1.2170|
;;;711          pObj->ScrollPos = ScrollPos;
000868  63c4              STR      r4,[r0,#0x3c]
;;;712          WM_Invalidate(hObj);
00086a  4628              MOV      r0,r5
00086c  f7fffffe          BL       WM_InvalidateWindow
;;;713          WM_InvalidateWindow(WM_GetParent(hObj));
000870  4628              MOV      r0,r5
000872  f7fffffe          BL       WM_GetParent
000876  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2170|
;;;714        }
;;;715        WM_UNLOCK();
00087a  e8bd4070          POP      {r4-r6,lr}
00087e  f7ffbffe          B.W      GUI_Unlock
                  |L1.2178|
;;;716      }
;;;717    }
000882  bd70              POP      {r4-r6,pc}
;;;718    
                          ENDP

                  HEADER_AddItem PROC
;;;722    */
;;;723    void HEADER_AddItem(HEADER_Handle hObj, int Width, const char * s, int Align) {
000884  e92d43f0          PUSH     {r4-r9,lr}
000888  b083              SUB      sp,sp,#0xc
00088a  4607              MOV      r7,r0
00088c  460d              MOV      r5,r1
00088e  4690              MOV      r8,r2
000890  461e              MOV      r6,r3
;;;724      if (hObj) {
000892  2f00              CMP      r7,#0
000894  d042              BEQ      |L1.2332|
;;;725        HEADER_Obj * pObj;
;;;726        HEADER_COLUMN Column;
;;;727        int Index;
;;;728        WM_LOCK();
000896  f7fffffe          BL       GUI_Lock
;;;729        pObj = HEADER_H2P(hObj);
00089a  4638              MOV      r0,r7
00089c  f7fffffe          BL       GUI_ALLOC_h2p
0008a0  4604              MOV      r4,r0
;;;730        if (!Width) {
0008a2  b985              CBNZ     r5,|L1.2246|
;;;731          const GUI_FONT GUI_UNI_PTR * pFont = GUI_SetFont(pObj->pFont);
0008a4  6ce0              LDR      r0,[r4,#0x4c]
0008a6  f7fffffe          BL       GUI_SetFont
0008aa  4681              MOV      r9,r0
;;;732          Width = GUI_GetStringDistX(s) + 2 * (pObj->Widget.pEffect->EffectSize + _DefaultBorderH);
0008ac  4640              MOV      r0,r8
0008ae  f7fffffe          BL       GUI_GetStringDistX
0008b2  6a21              LDR      r1,[r4,#0x20]
0008b4  4a63              LDR      r2,|L1.2628|
0008b6  6949              LDR      r1,[r1,#0x14]
0008b8  68d2              LDR      r2,[r2,#0xc]  ; _DefaultBorderH
0008ba  4411              ADD      r1,r1,r2
0008bc  eb000541          ADD      r5,r0,r1,LSL #1
;;;733          GUI_SetFont(pFont);
0008c0  4648              MOV      r0,r9
0008c2  f7fffffe          BL       GUI_SetFont
                  |L1.2246|
;;;734        }
;;;735        Column.Width    = Width;
0008c6  9500              STR      r5,[sp,#0]
;;;736        Column.Align    = Align;
0008c8  f8ad6004          STRH     r6,[sp,#4]
;;;737        Column.hDrawObj = 0;
0008cc  2000              MOVS     r0,#0
0008ce  f8ad0006          STRH     r0,[sp,#6]
;;;738        Index = GUI_ARRAY_GetNumItems(&pObj->Columns);
0008d2  f1040030          ADD      r0,r4,#0x30
0008d6  f7fffffe          BL       GUI_ARRAY_GetNumItems
0008da  4605              MOV      r5,r0
;;;739        if (GUI_ARRAY_AddItem(&pObj->Columns, &Column, sizeof(HEADER_COLUMN) + strlen(s) + 1) == 0) {
0008dc  4640              MOV      r0,r8
0008de  f7fffffe          BL       strlen
0008e2  f100020d          ADD      r2,r0,#0xd
0008e6  4669              MOV      r1,sp
0008e8  f1040030          ADD      r0,r4,#0x30
0008ec  f7fffffe          BL       GUI_ARRAY_AddItem
0008f0  b990              CBNZ     r0,|L1.2328|
;;;740          HEADER_COLUMN * pColumn;
;;;741          pObj = HEADER_H2P(hObj);
0008f2  4638              MOV      r0,r7
0008f4  f7fffffe          BL       GUI_ALLOC_h2p
;;;742          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
0008f8  4629              MOV      r1,r5
0008fa  3030              ADDS     r0,r0,#0x30
0008fc  f7fffffe          BL       GUI_ARRAY_GetpItem
;;;743          strcpy(pColumn->acText, s);
000900  4641              MOV      r1,r8
000902  3008              ADDS     r0,r0,#8
000904  f7fffffe          BL       strcpy
;;;744          WM_InvalidateWindow(hObj);
000908  4638              MOV      r0,r7
00090a  f7fffffe          BL       WM_InvalidateWindow
;;;745          WM_InvalidateWindow(WM_GetParent(hObj));
00090e  4638              MOV      r0,r7
000910  f7fffffe          BL       WM_GetParent
000914  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2328|
;;;746        }
;;;747        WM_UNLOCK();
000918  f7fffffe          BL       GUI_Unlock
                  |L1.2332|
;;;748      }
;;;749    }
00091c  b003              ADD      sp,sp,#0xc
00091e  e8bd83f0          POP      {r4-r9,pc}
;;;750    
                          ENDP

                  HEADER_DeleteItem PROC
;;;754    */
;;;755    void HEADER_DeleteItem(HEADER_Handle hObj, unsigned Index) {
000922  b570              PUSH     {r4-r6,lr}
000924  4606              MOV      r6,r0
000926  460d              MOV      r5,r1
;;;756      if (hObj) {
000928  2e00              CMP      r6,#0
00092a  d01c              BEQ      |L1.2406|
;;;757        HEADER_Obj* pObj;
;;;758        WM_LOCK();
00092c  f7fffffe          BL       GUI_Lock
;;;759        pObj = HEADER_H2P(hObj);
000930  4630              MOV      r0,r6
000932  f7fffffe          BL       GUI_ALLOC_h2p
000936  4604              MOV      r4,r0
;;;760        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000938  f1040030          ADD      r0,r4,#0x30
00093c  f7fffffe          BL       GUI_ARRAY_GetNumItems
000940  42a8              CMP      r0,r5
000942  d90c              BLS      |L1.2398|
;;;761          GUI_ARRAY_DeleteItem(&pObj->Columns, Index);
000944  4629              MOV      r1,r5
000946  f1040030          ADD      r0,r4,#0x30
00094a  f7fffffe          BL       GUI_ARRAY_DeleteItem
;;;762          WM_InvalidateWindow(hObj);
00094e  4630              MOV      r0,r6
000950  f7fffffe          BL       WM_InvalidateWindow
;;;763          WM_InvalidateWindow(WM_GetParent(hObj));
000954  4630              MOV      r0,r6
000956  f7fffffe          BL       WM_GetParent
00095a  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2398|
;;;764        }
;;;765        WM_UNLOCK();
00095e  e8bd4070          POP      {r4-r6,lr}
000962  f7ffbffe          B.W      GUI_Unlock
                  |L1.2406|
;;;766      }
;;;767    }
000966  bd70              POP      {r4-r6,pc}
;;;768    
                          ENDP

                  HEADER_SetItemText PROC
;;;772    */
;;;773    void HEADER_SetItemText(HEADER_Handle hObj, unsigned int Index, const char* s) {
000968  b570              PUSH     {r4-r6,lr}
00096a  4604              MOV      r4,r0
00096c  460e              MOV      r6,r1
00096e  4615              MOV      r5,r2
;;;774      if (hObj) {
000970  2c00              CMP      r4,#0
000972  d01e              BEQ      |L1.2482|
;;;775        HEADER_Obj* pObj;
;;;776        WM_LOCK();
000974  f7fffffe          BL       GUI_Lock
;;;777        pObj = HEADER_H2P(hObj);
000978  4620              MOV      r0,r4
00097a  f7fffffe          BL       GUI_ALLOC_h2p
00097e  4604              MOV      r4,r0
;;;778        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000980  f1040030          ADD      r0,r4,#0x30
000984  f7fffffe          BL       GUI_ARRAY_GetNumItems
000988  42b0              CMP      r0,r6
00098a  d90e              BLS      |L1.2474|
;;;779          HEADER_COLUMN* pColumn;
;;;780          pColumn = (HEADER_COLUMN*)GUI_ARRAY_ResizeItem(&pObj->Columns, Index, sizeof(HEADER_COLUMN) + strlen(s));
00098c  4628              MOV      r0,r5
00098e  f7fffffe          BL       strlen
000992  f100020c          ADD      r2,r0,#0xc
000996  4631              MOV      r1,r6
000998  f1040030          ADD      r0,r4,#0x30
00099c  f7fffffe          BL       GUI_ARRAY_ResizeItem
;;;781          if (pColumn) {
0009a0  b118              CBZ      r0,|L1.2474|
;;;782            strcpy(pColumn->acText, s);
0009a2  4629              MOV      r1,r5
0009a4  3008              ADDS     r0,r0,#8
0009a6  f7fffffe          BL       strcpy
                  |L1.2474|
;;;783          }
;;;784        }
;;;785        WM_UNLOCK();
0009aa  e8bd4070          POP      {r4-r6,lr}
0009ae  f7ffbffe          B.W      GUI_Unlock
                  |L1.2482|
;;;786      }
;;;787    }
0009b2  bd70              POP      {r4-r6,pc}
;;;788    
                          ENDP

                  HEADER_GetHeight PROC
;;;820    */
;;;821    int HEADER_GetHeight(HEADER_Handle hObj) {
0009b4  b500              PUSH     {lr}
0009b6  b083              SUB      sp,sp,#0xc
0009b8  4602              MOV      r2,r0
;;;822      int Height = 0;
0009ba  2000              MOVS     r0,#0
;;;823      if (hObj) {
0009bc  2a00              CMP      r2,#0
0009be  d012              BEQ      |L1.2534|
;;;824        GUI_RECT Rect;
;;;825        WM_GetClientRectEx(hObj, &Rect);
0009c0  4669              MOV      r1,sp
0009c2  4610              MOV      r0,r2
0009c4  f7fffffe          BL       WM_GetClientRectEx
;;;826        GUI_MoveRect(&Rect, -Rect.x0, -Rect.y0);
0009c8  f9bd0002          LDRSH    r0,[sp,#2]
0009cc  4242              RSBS     r2,r0,#0
0009ce  f9bd0000          LDRSH    r0,[sp,#0]
0009d2  4241              RSBS     r1,r0,#0
0009d4  4668              MOV      r0,sp
0009d6  f7fffffe          BL       GUI_MoveRect
;;;827        Height = Rect.y1 - Rect.y0 + 1;
0009da  f9bd0006          LDRSH    r0,[sp,#6]
0009de  f9bd1002          LDRSH    r1,[sp,#2]
0009e2  1a40              SUBS     r0,r0,r1
0009e4  1c40              ADDS     r0,r0,#1
                  |L1.2534|
;;;828      }
;;;829      return Height;
;;;830    }
0009e6  b003              ADD      sp,sp,#0xc
0009e8  bd00              POP      {pc}
;;;831    
                          ENDP

                  HEADER_GetNumItems PROC
;;;855    */
;;;856    int  HEADER_GetNumItems(HEADER_Handle hObj) {
0009ea  b570              PUSH     {r4-r6,lr}
0009ec  4605              MOV      r5,r0
;;;857      int NumCols = 0;
0009ee  2400              MOVS     r4,#0
;;;858      if (hObj) {
0009f0  b155              CBZ      r5,|L1.2568|
;;;859        HEADER_Obj * pObj;
;;;860        WM_LOCK();
0009f2  f7fffffe          BL       GUI_Lock
;;;861        pObj = HEADER_H2P(hObj);
0009f6  4628              MOV      r0,r5
0009f8  f7fffffe          BL       GUI_ALLOC_h2p
;;;862        NumCols = GUI_ARRAY_GetNumItems(&pObj->Columns);
0009fc  3030              ADDS     r0,r0,#0x30
0009fe  f7fffffe          BL       GUI_ARRAY_GetNumItems
000a02  4604              MOV      r4,r0
;;;863        WM_UNLOCK();
000a04  f7fffffe          BL       GUI_Unlock
                  |L1.2568|
;;;864      }
;;;865      return NumCols;
000a08  4620              MOV      r0,r4
;;;866    }
000a0a  bd70              POP      {r4-r6,pc}
;;;867    
                          ENDP

                  HEADER_SetDirIndicator PROC
;;;871    */
;;;872    void HEADER_SetDirIndicator(HEADER_Handle hObj, int Column, int Reverse) {
000a0c  b570              PUSH     {r4-r6,lr}
000a0e  4606              MOV      r6,r0
000a10  460c              MOV      r4,r1
000a12  4615              MOV      r5,r2
;;;873      if (hObj) {
000a14  2e00              CMP      r6,#0
000a16  d013              BEQ      |L1.2624|
;;;874        HEADER_Obj * pObj;
;;;875        WM_LOCK();
000a18  f7fffffe          BL       GUI_Lock
;;;876        pObj = HEADER_H2P(hObj);
000a1c  4630              MOV      r0,r6
000a1e  f7fffffe          BL       GUI_ALLOC_h2p
;;;877        if ((pObj->DirIndicatorColumn != Column) || (pObj->DirIndicatorReverse != Reverse)) {
000a22  6c41              LDR      r1,[r0,#0x44]
000a24  42a1              CMP      r1,r4
000a26  d102              BNE      |L1.2606|
000a28  6c81              LDR      r1,[r0,#0x48]
000a2a  42a9              CMP      r1,r5
000a2c  d004              BEQ      |L1.2616|
                  |L1.2606|
;;;878          pObj->DirIndicatorColumn = Column;
000a2e  6444              STR      r4,[r0,#0x44]
;;;879          pObj->DirIndicatorReverse = Reverse;
000a30  6485              STR      r5,[r0,#0x48]
;;;880          WM_InvalidateWindow(hObj);
000a32  4630              MOV      r0,r6
000a34  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2616|
;;;881        }
;;;882        WM_UNLOCK();
000a38  e8bd4070          POP      {r4-r6,lr}
000a3c  f7ffbffe          B.W      GUI_Unlock
                  |L1.2624|
;;;883      }
;;;884    }
000a40  bd70              POP      {r4-r6,pc}
;;;885    
                          ENDP

000a42  0000              DCW      0x0000
                  |L1.2628|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  _pDefaultCursor
                          DCD      GUI_CursorHeaderM
                  _DefaultBkColor
                          DCD      0x00aaaaaa
                  _DefaultTextColor
                          DCD      0x00000000
                  _DefaultBorderH
                          DCD      0x00000002
                  _DefaultBorderV
                          DCD      0x00000000
                  _pDefaultFont
                          DCD      GUI_Font13_1
                  _pOldCursor
                          DCD      0x00000000
