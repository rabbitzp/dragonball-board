; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\editulong.o --depend=.\rvmdk\editulong.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\editulong.crf ..\..\..\..\..\uCGUI\GUI\Widget\EDITUlong.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _IncrementCursor PROC
;;;36     */
;;;37     static void _IncrementCursor(EDIT_Obj* pObj) {
000000  6c01              LDR      r1,[r0,#0x40]
;;;38       EDIT__SetCursorPos(pObj, pObj->CursorPos + 1);
000002  1c49              ADDS     r1,r1,#1
000004  f7ffbffe          B.W      EDIT__SetCursorPos
;;;39     }
;;;40     
                          ENDP

                  _DecChar2Int PROC
;;;44     */
;;;45     static int _DecChar2Int(int Char) {
000008  f1a00130          SUB      r1,r0,#0x30
;;;46       if ((Char >= '0') && (Char <= '9')) {
00000c  2909              CMP      r1,#9
00000e  d801              BHI      |L1.20|
;;;47         return Char - '0';
000010  3830              SUBS     r0,r0,#0x30
;;;48       }
;;;49       return -1;
;;;50     }
000012  4770              BX       lr
                  |L1.20|
000014  f04f30ff          MOV      r0,#0xffffffff        ;49
000018  4770              BX       lr
;;;51     
                          ENDP

                  _UpdateBuffer PROC
;;;55     */
;;;56     static void _UpdateBuffer(EDIT_Handle hObj) {
00001a  b570              PUSH     {r4-r6,lr}
00001c  b084              SUB      sp,sp,#0x10
;;;57       char acValue[10] = {0};
00001e  2100              MOVS     r1,#0
000020  9101              STR      r1,[sp,#4]
000022  9102              STR      r1,[sp,#8]
000024  9103              STR      r1,[sp,#0xc]
;;;58       int NumDigits = 0;
000026  2400              MOVS     r4,#0
;;;59       U32 Value;
;;;60       char * s;
;;;61       EDIT_Obj * pObj;
;;;62       pObj = EDIT_H2P(hObj); /* The GUI needs not to be locked here. This function is called only from EDIT_AddKey which has already locked the GUI */
000028  f7fffffe          BL       GUI_ALLOC_h2p
00002c  4605              MOV      r5,r0
;;;63       s = (char*) GUI_ALLOC_h2p(pObj->hpText);
00002e  f9b50028          LDRSH    r0,[r5,#0x28]
000032  f7fffffe          BL       GUI_ALLOC_h2p
;;;64       /* Convert an unsigned long value into text */
;;;65       Value = pObj->CurrentValue;
000036  6be9              LDR      r1,[r5,#0x3c]
000038  f10d0c04          ADD      r12,sp,#4             ;57
;;;66       /* Fill the buffer with the digits (reverse order) */
;;;67       while (Value) {
00003c  b181              CBZ      r1,|L1.96|
;;;68         U8 c = Value % 10;
00003e  4e81              LDR      r6,|L1.580|
                  |L1.64|
000040  fba63201          UMULL    r3,r2,r6,r1
000044  08d2              LSRS     r2,r2,#3
000046  4253              RSBS     r3,r2,#0
000048  eb030383          ADD      r3,r3,r3,LSL #2
00004c  eb010143          ADD      r1,r1,r3,LSL #1
;;;69         acValue[NumDigits++] = '0' + c;
000050  3130              ADDS     r1,r1,#0x30
000052  4623              MOV      r3,r4
000054  1c64              ADDS     r4,r4,#1
000056  f80c1003          STRB     r1,[r12,r3]
;;;70         Value /= 10;
00005a  4611              MOV      r1,r2
00005c  2900              CMP      r1,#0                 ;67
00005e  d1ef              BNE      |L1.64|
                  |L1.96|
;;;71       }
;;;72       /* Fill with leading spaces */
;;;73       while (NumDigits < pObj->MaxLen) {
000060  f9b5102a          LDRSH    r1,[r5,#0x2a]
000064  42a1              CMP      r1,r4
000066  dd06              BLE      |L1.118|
;;;74         acValue[NumDigits++] = '0';
000068  2230              MOVS     r2,#0x30
                  |L1.106|
00006a  4623              MOV      r3,r4
00006c  1c64              ADDS     r4,r4,#1
00006e  f80c2003          STRB     r2,[r12,r3]
000072  42a1              CMP      r1,r4                 ;73
000074  dcf9              BGT      |L1.106|
                  |L1.118|
;;;75       }
;;;76       /* Reverse order */
;;;77       while (NumDigits) {
000076  2c00              CMP      r4,#0
000078  d006              BEQ      |L1.136|
                  |L1.122|
;;;78         *(s++) = acValue[--NumDigits];
00007a  1e64              SUBS     r4,r4,#1
00007c  f81c1004          LDRB     r1,[r12,r4]
000080  f8001b01          STRB     r1,[r0],#1
000084  2c00              CMP      r4,#0                 ;77
000086  d1f8              BNE      |L1.122|
                  |L1.136|
;;;79       }
;;;80     }
000088  b004              ADD      sp,sp,#0x10
00008a  bd70              POP      {r4-r6,pc}
;;;81     
                          ENDP

                  _EditULong PROC
;;;85     */
;;;86     static void _EditULong(int Digit, EDIT_Obj* pObj, EDIT_Handle hObj) {
00008c  e92d5ff0          PUSH     {r4-r12,lr}
000090  4680              MOV      r8,r0
000092  460e              MOV      r6,r1
000094  4693              MOV      r11,r2
;;;87       U32 Result = 0;
000096  2400              MOVS     r4,#0
;;;88       int i, j, Pos = 0;
000098  2500              MOVS     r5,#0
;;;89       char * s = (char*) GUI_ALLOC_h2p(pObj->hpText);
00009a  f9b60028          LDRSH    r0,[r6,#0x28]
00009e  f7fffffe          BL       GUI_ALLOC_h2p
0000a2  4681              MOV      r9,r0
;;;90       for (i = 0; i < pObj->MaxLen; i++) {
0000a4  2700              MOVS     r7,#0
0000a6  f9b6002a          LDRSH    r0,[r6,#0x2a]
0000aa  2800              CMP      r0,#0
0000ac  dd42              BLE      |L1.308|
;;;91         int Index = pObj->MaxLen - i - 1;
;;;92         if (Index == pObj->CursorPos) {
;;;93           /* In this case we need to check if an overflow occures */
;;;94           char c;
;;;95           int Value;
;;;96           U32 OldResult;
;;;97           /* Calculate old value (until cursor position) */
;;;98           c         = *(s + Index);
;;;99           Value     = _DecChar2Int(c);
;;;100          OldResult = Result;
;;;101          if (Value >= 0) {
;;;102            OldResult += GUI_Pow10[Pos] * Value;
0000ae  f8dfa198          LDR      r10,|L1.584|
                  |L1.178|
0000b2  f9b6002a          LDRSH    r0,[r6,#0x2a]         ;91
0000b6  1bc0              SUBS     r0,r0,r7              ;91
0000b8  1e40              SUBS     r0,r0,#1              ;91
0000ba  6c31              LDR      r1,[r6,#0x40]         ;92
0000bc  4281              CMP      r1,r0                 ;92
0000be  d123              BNE      |L1.264|
0000c0  f8190000          LDRB     r0,[r9,r0]            ;98
0000c4  f7fffffe          BL       _DecChar2Int
0000c8  4603              MOV      r3,r0                 ;99
0000ca  4622              MOV      r2,r4                 ;100
0000cc  2b00              CMP      r3,#0                 ;101
0000ce  db03              BLT      |L1.216|
0000d0  f85a0025          LDR      r0,[r10,r5,LSL #2]
0000d4  fb002203          MLA      r2,r0,r3,r2
                  |L1.216|
;;;103          }
;;;104          /* Calculate new value (until cursor position).
;;;105           * A multiplication like Result += GUI_Pow10[Pos++] * Digit
;;;106           * does not work, because in this case we have no chance to
;;;107           * notice an overflow.
;;;108           */
;;;109          for (j = 0; j < Digit; j++) {
0000d8  2000              MOVS     r0,#0
0000da  f1b80f00          CMP      r8,#0
0000de  dd0b              BLE      |L1.248|
0000e0  f85ac025          LDR      r12,[r10,r5,LSL #2]   ;102
                  |L1.228|
;;;110            U32 NewResult;
;;;111            NewResult = Result + GUI_Pow10[Pos];
0000e4  eb0c0104          ADD      r1,r12,r4
;;;112            /* Check if we have an overflow */
;;;113            if (NewResult < Result) {
0000e8  42a1              CMP      r1,r4
0000ea  d201              BCS      |L1.240|
;;;114              Result = pObj->Max;
0000ec  6b74              LDR      r4,[r6,#0x34]
;;;115              break;
0000ee  e003              B        |L1.248|
                  |L1.240|
;;;116            }
;;;117            Result = NewResult;
0000f0  460c              MOV      r4,r1
0000f2  1c40              ADDS     r0,r0,#1              ;109
0000f4  4540              CMP      r0,r8                 ;109
0000f6  dbf5              BLT      |L1.228|
                  |L1.248|
;;;118          }
;;;119          /* Check if we have an overflow */
;;;120          if (Digit > Value) {
0000f8  4598              CMP      r8,r3
0000fa  dd03              BLE      |L1.260|
;;;121            if (Result < OldResult) {
0000fc  4294              CMP      r4,r2
0000fe  d201              BCS      |L1.260|
;;;122              Result = pObj->Max;
000100  6b74              LDR      r4,[r6,#0x34]
;;;123              break;
000102  e017              B        |L1.308|
                  |L1.260|
;;;124            }
;;;125          }
;;;126          Pos++;
000104  1c6d              ADDS     r5,r5,#1
;;;127        } else {
000106  e010              B        |L1.298|
                  |L1.264|
;;;128          /* If current index is not the cursor position */
;;;129          char c = *(s + Index);
000108  f8190000          LDRB     r0,[r9,r0]
;;;130          int Value = _DecChar2Int(c);
00010c  f7fffffe          BL       _DecChar2Int
;;;131          if (Value >= 0) {
000110  2800              CMP      r0,#0
000112  db0a              BLT      |L1.298|
;;;132            U32 OldResult;
;;;133            OldResult = Result;
;;;134            Result += GUI_Pow10[Pos++] * Value;
000114  462a              MOV      r2,r5
000116  4621              MOV      r1,r4
000118  f85a2022          LDR      r2,[r10,r2,LSL #2]
00011c  1c6d              ADDS     r5,r5,#1
00011e  fb024400          MLA      r4,r2,r0,r4
;;;135            /* Check if we have an overflow */
;;;136            if (Result < OldResult) {
000122  428c              CMP      r4,r1
000124  d201              BCS      |L1.298|
;;;137              Result = pObj->Max;
000126  6b74              LDR      r4,[r6,#0x34]
;;;138              break;
000128  e004              B        |L1.308|
                  |L1.298|
00012a  1c7f              ADDS     r7,r7,#1              ;90
00012c  f9b6002a          LDRSH    r0,[r6,#0x2a]         ;90
000130  42b8              CMP      r0,r7                 ;90
000132  dcbe              BGT      |L1.178|
                  |L1.308|
;;;139            }
;;;140          }
;;;141        }
;;;142      }
;;;143      EDIT__SetValueUnsigned(hObj, Result);
000134  4621              MOV      r1,r4
000136  4658              MOV      r0,r11
000138  e8bd5ff0          POP      {r4-r12,lr}
00013c  f7ffbffe          B.W      EDIT__SetValueUnsigned
;;;144    }
;;;145    
                          ENDP

                  _AddPosition PROC
;;;149    */
;;;150    static void _AddPosition(EDIT_Obj* pObj, EDIT_Handle hObj, int Sign) {
000140  468c              MOV      r12,r1
;;;151      int Pos;
;;;152      I32 v, NewValue;
;;;153      v = Sign;
;;;154      Pos = pObj->MaxLen - pObj->CursorPos-1;
000142  f9b0102a          LDRSH    r1,[r0,#0x2a]
000146  6c03              LDR      r3,[r0,#0x40]
000148  1ac9              SUBS     r1,r1,r3
00014a  1e49              SUBS     r1,r1,#1
;;;155      if (pObj->NumDecs && (Pos > pObj->NumDecs)) {
00014c  f8903038          LDRB     r3,[r0,#0x38]
000150  b113              CBZ      r3,|L1.344|
000152  428b              CMP      r3,r1
000154  da00              BGE      |L1.344|
;;;156        Pos--;
000156  1e49              SUBS     r1,r1,#1
                  |L1.344|
;;;157      }
;;;158      while (Pos--) {
000158  1e49              SUBS     r1,r1,#1
00015a  d304              BCC      |L1.358|
                  |L1.348|
;;;159        v *= 10;
00015c  eb020282          ADD      r2,r2,r2,LSL #2
000160  0052              LSLS     r2,r2,#1
000162  1e49              SUBS     r1,r1,#1              ;158
000164  d2fa              BCS      |L1.348|
                  |L1.358|
;;;160      }
;;;161      NewValue = pObj->CurrentValue + v;
000166  6bc3              LDR      r3,[r0,#0x3c]
000168  1899              ADDS     r1,r3,r2
;;;162      /*
;;;163       * Check if overflow occurs
;;;164       */
;;;165      if (v > 0) {
00016a  2a00              CMP      r2,#0
00016c  dd03              BLE      |L1.374|
;;;166        /* If result of addition is less than previous value he have an overflow */
;;;167        if (((U32)pObj->CurrentValue + v) < (U32)pObj->CurrentValue) {
00016e  4299              CMP      r1,r3
000170  d205              BCS      |L1.382|
;;;168          NewValue = pObj->Max; /* Set maximum value */
000172  6b41              LDR      r1,[r0,#0x34]
000174  e003              B        |L1.382|
                  |L1.374|
;;;169        }
;;;170      } else if (v < 0) {
000176  da02              BGE      |L1.382|
;;;171        /* If result of addition is more than previous value he have an overflow */
;;;172        if (((U32)pObj->CurrentValue + v) > (U32)pObj->CurrentValue) {
000178  4299              CMP      r1,r3
00017a  d900              BLS      |L1.382|
;;;173          NewValue = pObj->Min; /* Set minimum value */
00017c  6b01              LDR      r1,[r0,#0x30]
                  |L1.382|
;;;174        }
;;;175      }
;;;176      EDIT__SetValueUnsigned(hObj, NewValue);
00017e  4660              MOV      r0,r12
000180  f7ffbffe          B.W      EDIT__SetValueUnsigned
;;;177    }
;;;178    
                          ENDP

                  _AddKey PROC
;;;182    */
;;;183    static void _AddKey(EDIT_Handle hObj, int Key) {
000184  b570              PUSH     {r4-r6,lr}
000186  4606              MOV      r6,r0
000188  460c              MOV      r4,r1
;;;184      EDIT_Obj * pObj;
;;;185      pObj = EDIT_H2P(hObj); /* The GUI needs not to be locked here. This function is called only from EDIT_AddKey which has already locked the GUI */
00018a  4630              MOV      r0,r6
00018c  f7fffffe          BL       GUI_ALLOC_h2p
000190  4605              MOV      r5,r0
;;;186      if (pObj) {
000192  b19d              CBZ      r5,|L1.444|
;;;187        switch (Key) {
000194  2c10              CMP      r4,#0x10
000196  d026              BEQ      |L1.486|
000198  2c11              CMP      r4,#0x11
00019a  d013              BEQ      |L1.452|
00019c  2c12              CMP      r4,#0x12
00019e  d01e              BEQ      |L1.478|
0001a0  2c13              CMP      r4,#0x13
0001a2  d015              BEQ      |L1.464|
;;;188        case GUI_KEY_UP:
;;;189          _AddPosition(pObj, hObj, 1);
;;;190          break;
;;;191        case GUI_KEY_DOWN:
;;;192          _AddPosition(pObj, hObj, -1);
;;;193          break;
;;;194        case GUI_KEY_RIGHT:
;;;195          _IncrementCursor(pObj);
;;;196          break;
;;;197        case GUI_KEY_LEFT:
;;;198          EDIT__SetCursorPos(pObj, pObj->CursorPos - 1);
;;;199          break;
;;;200        default:
;;;201          {
;;;202            int Digit = _DecChar2Int(Key);
0001a4  4620              MOV      r0,r4
0001a6  f7fffffe          BL       _DecChar2Int
;;;203            if (Digit >= 0) {
0001aa  2800              CMP      r0,#0
0001ac  db06              BLT      |L1.444|
;;;204              _EditULong(Digit, pObj, hObj);
0001ae  4632              MOV      r2,r6
0001b0  4629              MOV      r1,r5
0001b2  f7fffffe          BL       _EditULong
;;;205              _IncrementCursor(pObj);
0001b6  4628              MOV      r0,r5
0001b8  f7fffffe          BL       _IncrementCursor
                  |L1.444|
;;;206            }
;;;207          }
;;;208          break;
;;;209        }
;;;210      }
;;;211      _UpdateBuffer(hObj);
0001bc  4630              MOV      r0,r6
0001be  e8bd4070          POP      {r4-r6,lr}
0001c2  e7fe              B        _UpdateBuffer
                  |L1.452|
0001c4  2201              MOVS     r2,#1                 ;189
0001c6  4631              MOV      r1,r6                 ;189
0001c8  4628              MOV      r0,r5                 ;189
0001ca  f7fffffe          BL       _AddPosition
0001ce  e7f5              B        |L1.444|
                  |L1.464|
0001d0  f04f32ff          MOV      r2,#0xffffffff        ;192
0001d4  4631              MOV      r1,r6                 ;192
0001d6  4628              MOV      r0,r5                 ;192
0001d8  f7fffffe          BL       _AddPosition
0001dc  e7ee              B        |L1.444|
                  |L1.478|
0001de  4628              MOV      r0,r5                 ;195
0001e0  f7fffffe          BL       _IncrementCursor
0001e4  e7ea              B        |L1.444|
                  |L1.486|
0001e6  6c28              LDR      r0,[r5,#0x40]         ;198
0001e8  1e41              SUBS     r1,r0,#1              ;198
0001ea  4628              MOV      r0,r5                 ;198
0001ec  f7fffffe          BL       EDIT__SetCursorPos
0001f0  e7e4              B        |L1.444|
;;;212    }
;;;213    
                          ENDP

                  EDIT_SetUlongMode PROC
;;;223    */
;;;224    void EDIT_SetUlongMode(EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max) {
0001f2  e92d41f0          PUSH     {r4-r8,lr}
0001f6  4607              MOV      r7,r0
0001f8  460c              MOV      r4,r1
0001fa  4615              MOV      r5,r2
0001fc  461e              MOV      r6,r3
;;;225      EDIT_Obj* pObj;
;;;226      WM_LOCK();
0001fe  f7fffffe          BL       GUI_Lock
;;;227      if (hEdit) {
000202  b1df              CBZ      r7,|L1.572|
;;;228        pObj = EDIT_H2P(hEdit);
000204  4638              MOV      r0,r7
000206  f7fffffe          BL       GUI_ALLOC_h2p
;;;229        if (Value > Max) {
00020a  42b4              CMP      r4,r6
00020c  d901              BLS      |L1.530|
;;;230          Value = Max;
00020e  4634              MOV      r4,r6
000210  e002              B        |L1.536|
                  |L1.530|
;;;231        } else if (Value < Min) {
000212  42ac              CMP      r4,r5
000214  d200              BCS      |L1.536|
;;;232          Value = Min;
000216  462c              MOV      r4,r5
                  |L1.536|
;;;233        }
;;;234        pObj->pfAddKeyEx    = _AddKey;
000218  490c              LDR      r1,|L1.588|
00021a  64c1              STR      r1,[r0,#0x4c]
;;;235        pObj->pfUpdateBuffer= _UpdateBuffer;
00021c  490c              LDR      r1,|L1.592|
00021e  6501              STR      r1,[r0,#0x50]
;;;236        pObj->CurrentValue  = Value;
000220  63c4              STR      r4,[r0,#0x3c]
;;;237        pObj->CursorPos     = 0;
000222  2100              MOVS     r1,#0
000224  6401              STR      r1,[r0,#0x40]
;;;238        pObj->Min           = Min;
000226  6305              STR      r5,[r0,#0x30]
;;;239        pObj->Max           = Max;
000228  6346              STR      r6,[r0,#0x34]
;;;240        pObj->EditMode      = GUI_EDIT_MODE_OVERWRITE;
00022a  2101              MOVS     r1,#1
00022c  f8801048          STRB     r1,[r0,#0x48]
;;;241        _UpdateBuffer(hEdit);
000230  4638              MOV      r0,r7
000232  f7fffffe          BL       _UpdateBuffer
;;;242        WM_Invalidate(hEdit);
000236  4638              MOV      r0,r7
000238  f7fffffe          BL       WM_InvalidateWindow
                  |L1.572|
;;;243      }
;;;244      WM_UNLOCK();
00023c  e8bd41f0          POP      {r4-r8,lr}
000240  f7ffbffe          B.W      GUI_Unlock
;;;245    }
;;;246    
                          ENDP

                  |L1.580|
                          DCD      0xcccccccd
                  |L1.584|
                          DCD      GUI_Pow10
                  |L1.588|
                          DCD      _AddKey
                  |L1.592|
                          DCD      _UpdateBuffer
