; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\os_q.o --depend=.\rvmdk\os_q.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\os_q.crf ..\..\..\..\..\uCOS-II\Source\os_q.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OSQAccept PROC
;;;60     #if OS_Q_ACCEPT_EN > 0
;;;61     void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;63         void      *pmsg;
;;;64         OS_Q      *pq;
;;;65     #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;66         OS_CPU_SR  cpu_sr = 0;
;;;67     #endif
;;;68     
;;;69     
;;;70     
;;;71     #if OS_ARG_CHK_EN > 0
;;;72         if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;73             return ((void *)0);
;;;74         }
;;;75         if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
;;;76             *perr = OS_ERR_PEVENT_NULL;
;;;77             return ((void *)0);
;;;78         }
;;;79     #endif
;;;80         if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
000006  7828              LDRB     r0,[r5,#0]
000008  2802              CMP      r0,#2
00000a  d003              BEQ      |L1.20|
;;;81             *perr = OS_ERR_EVENT_TYPE;
00000c  2001              MOVS     r0,#1
00000e  7020              STRB     r0,[r4,#0]
;;;82             return ((void *)0);
000010  2000              MOVS     r0,#0
;;;83         }
;;;84         OS_ENTER_CRITICAL();
;;;85         pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
;;;86         if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
;;;87             pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
;;;88             pq->OSQEntries--;                        /* Update the number of entries in the queue          */
;;;89             if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
;;;90                 pq->OSQOut = pq->OSQStart;
;;;91             }
;;;92             *perr = OS_ERR_NONE;
;;;93         } else {
;;;94             *perr = OS_ERR_Q_EMPTY;
;;;95             pmsg  = (void *)0;                       /* Queue is empty                                     */
;;;96         }
;;;97         OS_EXIT_CRITICAL();
;;;98         return (pmsg);                               /* Return message received (or NULL)                  */
;;;99     }
000012  bd70              POP      {r4-r6,pc}
                  |L1.20|
000014  f7fffffe          BL       OS_CPU_SR_Save
000018  4603              MOV      r3,r0                 ;84
00001a  686a              LDR      r2,[r5,#4]            ;85
00001c  8ad0              LDRH     r0,[r2,#0x16]         ;86
00001e  b170              CBZ      r0,|L1.62|
000020  6910              LDR      r0,[r2,#0x10]         ;87
000022  1d01              ADDS     r1,r0,#4              ;87
000024  6111              STR      r1,[r2,#0x10]         ;87
000026  6805              LDR      r5,[r0,#0]            ;87
000028  8ad0              LDRH     r0,[r2,#0x16]         ;88
00002a  1e40              SUBS     r0,r0,#1              ;88
00002c  82d0              STRH     r0,[r2,#0x16]         ;88
00002e  6890              LDR      r0,[r2,#8]            ;89
000030  4281              CMP      r1,r0                 ;89
000032  d101              BNE      |L1.56|
000034  6850              LDR      r0,[r2,#4]            ;90
000036  6110              STR      r0,[r2,#0x10]         ;90
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;92
00003a  7020              STRB     r0,[r4,#0]            ;92
00003c  e002              B        |L1.68|
                  |L1.62|
00003e  201f              MOVS     r0,#0x1f              ;94
000040  7020              STRB     r0,[r4,#0]            ;94
000042  2500              MOVS     r5,#0                 ;95
                  |L1.68|
000044  4618              MOV      r0,r3                 ;97
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  4628              MOV      r0,r5                 ;98
00004c  bd70              POP      {r4-r6,pc}
;;;100    #endif
                          ENDP

                  OSQCreate PROC
;;;120    
;;;121    OS_EVENT  *OSQCreate (void **start, INT16U size)
00004e  e92d41f0          PUSH     {r4-r8,lr}
;;;122    {
000052  4606              MOV      r6,r0
000054  460f              MOV      r7,r1
;;;123        OS_EVENT  *pevent;
;;;124        OS_Q      *pq;
;;;125    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;126        OS_CPU_SR  cpu_sr = 0;
;;;127    #endif
;;;128    
;;;129    
;;;130    
;;;131        if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
000056  48fa              LDR      r0,|L1.1088|
000058  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00005a  b110              CBZ      r0,|L1.98|
;;;132            return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00005c  2000              MOVS     r0,#0
;;;133        }
;;;134        OS_ENTER_CRITICAL();
;;;135        pevent = OSEventFreeList;                    /* Get next free event control block                  */
;;;136        if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
;;;137            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;138        }
;;;139        OS_EXIT_CRITICAL();
;;;140        if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
;;;141            OS_ENTER_CRITICAL();
;;;142            pq = OSQFreeList;                        /* Get a free queue control block                     */
;;;143            if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
;;;144                OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
;;;145                OS_EXIT_CRITICAL();
;;;146                pq->OSQStart           = start;               /*      Initialize the queue                 */
;;;147                pq->OSQEnd             = &start[size];
;;;148                pq->OSQIn              = start;
;;;149                pq->OSQOut             = start;
;;;150                pq->OSQSize            = size;
;;;151                pq->OSQEntries         = 0;
;;;152                pevent->OSEventType    = OS_EVENT_TYPE_Q;
;;;153                pevent->OSEventCnt     = 0;
;;;154                pevent->OSEventPtr     = pq;
;;;155    #if OS_EVENT_NAME_SIZE > 1
;;;156                pevent->OSEventName[0] = '?';                  /* Unknown name                             */
;;;157                pevent->OSEventName[1] = OS_ASCII_NUL;
;;;158    #endif
;;;159                OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
;;;160            } else {
;;;161                pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
;;;162                OSEventFreeList    = pevent;
;;;163                OS_EXIT_CRITICAL();
;;;164                pevent = (OS_EVENT *)0;
;;;165            }
;;;166        }
;;;167        return (pevent);
;;;168    }
00005e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.98|
000062  f7fffffe          BL       OS_CPU_SR_Save
000066  f8df83dc          LDR      r8,|L1.1092|
00006a  f8d84000          LDR      r4,[r8,#0]            ;135  ; OSEventFreeList
00006e  b114              CBZ      r4,|L1.118|
000070  6861              LDR      r1,[r4,#4]            ;137
000072  f8c81000          STR      r1,[r8,#0]            ;137  ; OSEventFreeList
                  |L1.118|
000076  f7fffffe          BL       OS_CPU_SR_Restore
00007a  b33c              CBZ      r4,|L1.204|
00007c  f7fffffe          BL       OS_CPU_SR_Save
000080  4601              MOV      r1,r0                 ;141
000082  48f1              LDR      r0,|L1.1096|
000084  6805              LDR      r5,[r0,#0]            ;142  ; OSQFreeList
000086  b1c5              CBZ      r5,|L1.186|
000088  682a              LDR      r2,[r5,#0]            ;144
00008a  6002              STR      r2,[r0,#0]            ;144  ; OSQFreeList
00008c  4608              MOV      r0,r1                 ;145
00008e  f7fffffe          BL       OS_CPU_SR_Restore
000092  606e              STR      r6,[r5,#4]            ;146
000094  eb060087          ADD      r0,r6,r7,LSL #2       ;147
000098  60a8              STR      r0,[r5,#8]            ;147
00009a  60ee              STR      r6,[r5,#0xc]          ;148
00009c  612e              STR      r6,[r5,#0x10]         ;149
00009e  82af              STRH     r7,[r5,#0x14]         ;150
0000a0  2000              MOVS     r0,#0                 ;151
0000a2  82e8              STRH     r0,[r5,#0x16]         ;151
0000a4  2102              MOVS     r1,#2                 ;152
0000a6  7021              STRB     r1,[r4,#0]            ;152
0000a8  8120              STRH     r0,[r4,#8]            ;153
0000aa  6065              STR      r5,[r4,#4]            ;154
0000ac  213f              MOVS     r1,#0x3f              ;156
0000ae  73e1              STRB     r1,[r4,#0xf]          ;156
0000b0  7420              STRB     r0,[r4,#0x10]         ;157
0000b2  4620              MOV      r0,r4                 ;159
0000b4  f7fffffe          BL       OS_EventWaitListInit
0000b8  e008              B        |L1.204|
                  |L1.186|
0000ba  f8d80000          LDR      r0,[r8,#0]            ;161  ; OSEventFreeList
0000be  6060              STR      r0,[r4,#4]            ;161
0000c0  f8c84000          STR      r4,[r8,#0]            ;162  ; OSEventFreeList
0000c4  4608              MOV      r0,r1                 ;163
0000c6  f7fffffe          BL       OS_CPU_SR_Restore
0000ca  2400              MOVS     r4,#0                 ;164
                  |L1.204|
0000cc  4620              MOV      r0,r4                 ;167
0000ce  e8bd81f0          POP      {r4-r8,pc}
;;;169    /*$PAGE*/
                          ENDP

                  OSQDel PROC
;;;211    #if OS_Q_DEL_EN > 0
;;;212    OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
0000d2  e92d5ff0          PUSH     {r4-r12,lr}
;;;213    {
0000d6  4604              MOV      r4,r0
0000d8  460f              MOV      r7,r1
0000da  4615              MOV      r5,r2
;;;214        BOOLEAN    tasks_waiting;
;;;215        OS_EVENT  *pevent_return;
;;;216        OS_Q      *pq;
;;;217    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;218        OS_CPU_SR  cpu_sr = 0;
;;;219    #endif
;;;220    
;;;221    
;;;222    
;;;223    #if OS_ARG_CHK_EN > 0
;;;224        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
;;;225            return (pevent);
;;;226        }
;;;227        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;228            *perr = OS_ERR_PEVENT_NULL;
;;;229            return (pevent);
;;;230        }
;;;231    #endif
;;;232        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
0000dc  7820              LDRB     r0,[r4,#0]
0000de  2802              CMP      r0,#2
0000e0  d004              BEQ      |L1.236|
;;;233            *perr = OS_ERR_EVENT_TYPE;
0000e2  2001              MOVS     r0,#1
0000e4  7028              STRB     r0,[r5,#0]
;;;234            return (pevent);
0000e6  4620              MOV      r0,r4
;;;235        }
;;;236        if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
;;;237            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;238            return (pevent);
;;;239        }
;;;240        OS_ENTER_CRITICAL();
;;;241        if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
;;;242            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;243        } else {
;;;244            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;245        }
;;;246        switch (opt) {
;;;247            case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
;;;248                 if (tasks_waiting == OS_FALSE) {
;;;249    #if OS_EVENT_NAME_SIZE > 1
;;;250                     pevent->OSEventName[0] = '?';             /* Unknown name                             */
;;;251                     pevent->OSEventName[1] = OS_ASCII_NUL;
;;;252    #endif
;;;253                     pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
;;;254                     pq->OSQPtr             = OSQFreeList;
;;;255                     OSQFreeList            = pq;
;;;256                     pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;257                     pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
;;;258                     pevent->OSEventCnt     = 0;
;;;259                     OSEventFreeList        = pevent;          /* Get next free event control block        */
;;;260                     OS_EXIT_CRITICAL();
;;;261                     *perr                  = OS_ERR_NONE;
;;;262                     pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
;;;263                 } else {
;;;264                     OS_EXIT_CRITICAL();
;;;265                     *perr                  = OS_ERR_TASK_WAITING;
;;;266                     pevent_return          = pevent;
;;;267                 }
;;;268                 break;
;;;269    
;;;270            case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
;;;271                 while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
;;;272                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
;;;273                 }
;;;274    #if OS_EVENT_NAME_SIZE > 1
;;;275                 pevent->OSEventName[0] = '?';                 /* Unknown name                             */
;;;276                 pevent->OSEventName[1] = OS_ASCII_NUL;
;;;277    #endif
;;;278                 pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
;;;279                 pq->OSQPtr             = OSQFreeList;
;;;280                 OSQFreeList            = pq;
;;;281                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;282                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;283                 pevent->OSEventCnt     = 0;
;;;284                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;285                 OS_EXIT_CRITICAL();
;;;286                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;287                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;288                 }
;;;289                 *perr                  = OS_ERR_NONE;
;;;290                 pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
;;;291                 break;
;;;292    
;;;293            default:
;;;294                 OS_EXIT_CRITICAL();
;;;295                 *perr                  = OS_ERR_INVALID_OPT;
;;;296                 pevent_return          = pevent;
;;;297                 break;
;;;298        }
;;;299        return (pevent_return);
;;;300    }
0000e8  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.236|
0000ec  48d4              LDR      r0,|L1.1088|
0000ee  7800              LDRB     r0,[r0,#0]            ;236  ; OSIntNesting
0000f0  b120              CBZ      r0,|L1.252|
0000f2  200f              MOVS     r0,#0xf               ;237
0000f4  7028              STRB     r0,[r5,#0]            ;237
0000f6  4620              MOV      r0,r4                 ;238
0000f8  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.252|
0000fc  f7fffffe          BL       OS_CPU_SR_Save
000100  4683              MOV      r11,r0                ;240
000102  7aa0              LDRB     r0,[r4,#0xa]          ;241
000104  b108              CBZ      r0,|L1.266|
000106  2601              MOVS     r6,#1                 ;242
000108  e000              B        |L1.268|
                  |L1.266|
00010a  2600              MOVS     r6,#0                 ;244
                  |L1.268|
00010c  0039              MOVS     r1,r7                 ;246
00010e  f8df8338          LDR      r8,|L1.1096|
000112  f8df9330          LDR      r9,|L1.1092|
000116  f04f0a3f          MOV      r10,#0x3f             ;250
00011a  f04f0700          MOV      r7,#0                 ;218
00011e  d009              BEQ      |L1.308|
000120  2901              CMP      r1,#1                 ;246
000122  d027              BEQ      |L1.372|
000124  4658              MOV      r0,r11                ;294
000126  f7fffffe          BL       OS_CPU_SR_Restore
00012a  2007              MOVS     r0,#7                 ;295
00012c  7028              STRB     r0,[r5,#0]            ;295
00012e  4620              MOV      r0,r4                 ;296
000130  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.308|
000134  b13e              CBZ      r6,|L1.326|
000136  4658              MOV      r0,r11                ;264
000138  f7fffffe          BL       OS_CPU_SR_Restore
00013c  2049              MOVS     r0,#0x49              ;265
00013e  7028              STRB     r0,[r5,#0]            ;265
000140  4620              MOV      r0,r4                 ;266
000142  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.326|
000146  f884a00f          STRB     r10,[r4,#0xf]         ;250
00014a  7427              STRB     r7,[r4,#0x10]         ;251
00014c  6860              LDR      r0,[r4,#4]            ;253
00014e  f8d81000          LDR      r1,[r8,#0]            ;254  ; OSQFreeList
000152  6001              STR      r1,[r0,#0]            ;254
000154  f8c80000          STR      r0,[r8,#0]            ;255  ; OSQFreeList
000158  7027              STRB     r7,[r4,#0]            ;256
00015a  f8d90000          LDR      r0,[r9,#0]            ;257  ; OSEventFreeList
00015e  6060              STR      r0,[r4,#4]            ;257
000160  8127              STRH     r7,[r4,#8]            ;258
000162  f8c94000          STR      r4,[r9,#0]            ;259  ; OSEventFreeList
000166  4658              MOV      r0,r11                ;260
000168  f7fffffe          BL       OS_CPU_SR_Restore
00016c  702f              STRB     r7,[r5,#0]            ;261
00016e  2000              MOVS     r0,#0                 ;262
000170  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.372|
000174  b140              CBZ      r0,|L1.392|
                  |L1.374|
000176  2300              MOVS     r3,#0                 ;272
000178  2204              MOVS     r2,#4                 ;272
00017a  4619              MOV      r1,r3                 ;272
00017c  4620              MOV      r0,r4                 ;272
00017e  f7fffffe          BL       OS_EventTaskRdy
000182  7aa0              LDRB     r0,[r4,#0xa]          ;271
000184  2800              CMP      r0,#0                 ;271
000186  d1f6              BNE      |L1.374|
                  |L1.392|
000188  f884a00f          STRB     r10,[r4,#0xf]         ;275
00018c  7427              STRB     r7,[r4,#0x10]         ;276
00018e  6860              LDR      r0,[r4,#4]            ;278
000190  f8d81000          LDR      r1,[r8,#0]            ;279  ; OSQFreeList
000194  6001              STR      r1,[r0,#0]            ;279
000196  f8c80000          STR      r0,[r8,#0]            ;280  ; OSQFreeList
00019a  7027              STRB     r7,[r4,#0]            ;281
00019c  f8d90000          LDR      r0,[r9,#0]            ;282  ; OSEventFreeList
0001a0  6060              STR      r0,[r4,#4]            ;282
0001a2  8127              STRH     r7,[r4,#8]            ;283
0001a4  f8c94000          STR      r4,[r9,#0]            ;284  ; OSEventFreeList
0001a8  4658              MOV      r0,r11                ;285
0001aa  f7fffffe          BL       OS_CPU_SR_Restore
0001ae  2e01              CMP      r6,#1                 ;286
0001b0  d101              BNE      |L1.438|
0001b2  f7fffffe          BL       OS_Sched
                  |L1.438|
0001b6  702f              STRB     r7,[r5,#0]            ;289
0001b8  2000              MOVS     r0,#0                 ;290
0001ba  e8bd9ff0          POP      {r4-r12,pc}
;;;301    #endif
                          ENDP

                  OSQFlush PROC
;;;323    #if OS_Q_FLUSH_EN > 0
;;;324    INT8U  OSQFlush (OS_EVENT *pevent)
0001be  b510              PUSH     {r4,lr}
;;;325    {
0001c0  4604              MOV      r4,r0
;;;326        OS_Q      *pq;
;;;327    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;328        OS_CPU_SR  cpu_sr = 0;
;;;329    #endif
;;;330    
;;;331    
;;;332    
;;;333    #if OS_ARG_CHK_EN > 0
;;;334        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;335            return (OS_ERR_PEVENT_NULL);
;;;336        }
;;;337        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
;;;338            return (OS_ERR_EVENT_TYPE);
;;;339        }
;;;340    #endif
;;;341        OS_ENTER_CRITICAL();
0001c2  f7fffffe          BL       OS_CPU_SR_Save
;;;342        pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
0001c6  6861              LDR      r1,[r4,#4]
;;;343        pq->OSQIn      = pq->OSQStart;
0001c8  684a              LDR      r2,[r1,#4]
0001ca  60ca              STR      r2,[r1,#0xc]
;;;344        pq->OSQOut     = pq->OSQStart;
0001cc  684a              LDR      r2,[r1,#4]
0001ce  610a              STR      r2,[r1,#0x10]
;;;345        pq->OSQEntries = 0;
0001d0  2200              MOVS     r2,#0
0001d2  82ca              STRH     r2,[r1,#0x16]
;;;346        OS_EXIT_CRITICAL();
0001d4  f7fffffe          BL       OS_CPU_SR_Restore
;;;347        return (OS_ERR_NONE);
0001d8  2000              MOVS     r0,#0
;;;348    }
0001da  bd10              POP      {r4,pc}
;;;349    #endif
                          ENDP

                  OSQPend PROC
;;;387    
;;;388    void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
0001dc  e92d47f0          PUSH     {r4-r10,lr}
;;;389    {
0001e0  4605              MOV      r5,r0
0001e2  4688              MOV      r8,r1
0001e4  4614              MOV      r4,r2
;;;390        void      *pmsg;
;;;391        OS_Q      *pq;
;;;392    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;393        OS_CPU_SR  cpu_sr = 0;
;;;394    #endif
;;;395    
;;;396    
;;;397    
;;;398    #if OS_ARG_CHK_EN > 0
;;;399        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;400            return ((void *)0);
;;;401        }
;;;402        if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
;;;403            *perr = OS_ERR_PEVENT_NULL;
;;;404            return ((void *)0);
;;;405        }
;;;406    #endif
;;;407        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
0001e6  7828              LDRB     r0,[r5,#0]
0001e8  2802              CMP      r0,#2
0001ea  d004              BEQ      |L1.502|
;;;408            *perr = OS_ERR_EVENT_TYPE;
0001ec  2001              MOVS     r0,#1
0001ee  7020              STRB     r0,[r4,#0]
;;;409            return ((void *)0);
0001f0  2000              MOVS     r0,#0
;;;410        }
;;;411        if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
;;;412            *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
;;;413            return ((void *)0);
;;;414        }
;;;415        if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
;;;416            *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
;;;417            return ((void *)0);
;;;418        }
;;;419        OS_ENTER_CRITICAL();
;;;420        pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
;;;421        if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
;;;422            pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
;;;423            pq->OSQEntries--;                        /* Update the number of entries in the queue          */
;;;424            if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
;;;425                pq->OSQOut = pq->OSQStart;
;;;426            }
;;;427            OS_EXIT_CRITICAL();
;;;428            *perr = OS_ERR_NONE;
;;;429            return (pmsg);                           /* Return message received                            */
;;;430        }
;;;431        OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
;;;432        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;433        OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
;;;434        OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
;;;435        OS_EXIT_CRITICAL();
;;;436        OS_Sched();                                  /* Find next highest priority task ready to run       */
;;;437        OS_ENTER_CRITICAL();
;;;438        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;439            case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
;;;440                 pmsg =  OSTCBCur->OSTCBMsg;
;;;441                *perr =  OS_ERR_NONE;
;;;442                 break;
;;;443    
;;;444            case OS_STAT_PEND_ABORT:
;;;445                 pmsg = (void *)0;
;;;446                *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;447                 break;
;;;448    
;;;449            case OS_STAT_PEND_TO:
;;;450            default:
;;;451                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;452                 pmsg = (void *)0;
;;;453                *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;454                 break;
;;;455        }
;;;456        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;457        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;458        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;459    #if (OS_EVENT_MULTI_EN > 0)
;;;460        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;461    #endif
;;;462        OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
;;;463        OS_EXIT_CRITICAL();
;;;464        return (pmsg);                                    /* Return received message                       */
;;;465    }
0001f2  e8bd87f0          POP      {r4-r10,pc}
                  |L1.502|
0001f6  4892              LDR      r0,|L1.1088|
0001f8  7800              LDRB     r0,[r0,#0]            ;411  ; OSIntNesting
0001fa  b120              CBZ      r0,|L1.518|
0001fc  2002              MOVS     r0,#2                 ;412
0001fe  7020              STRB     r0,[r4,#0]            ;412
000200  2000              MOVS     r0,#0                 ;413
000202  e8bd87f0          POP      {r4-r10,pc}
                  |L1.518|
000206  4891              LDR      r0,|L1.1100|
000208  7800              LDRB     r0,[r0,#0]            ;415  ; OSLockNesting
00020a  b120              CBZ      r0,|L1.534|
00020c  200d              MOVS     r0,#0xd               ;416
00020e  7020              STRB     r0,[r4,#0]            ;416
000210  2000              MOVS     r0,#0                 ;417
000212  e8bd87f0          POP      {r4-r10,pc}
                  |L1.534|
000216  f7fffffe          BL       OS_CPU_SR_Save
00021a  4681              MOV      r9,r0                 ;419
00021c  686b              LDR      r3,[r5,#4]            ;420
00021e  2600              MOVS     r6,#0                 ;393
000220  8ad8              LDRH     r0,[r3,#0x16]         ;421
000222  b190              CBZ      r0,|L1.586|
000224  6919              LDR      r1,[r3,#0x10]         ;422
000226  1d08              ADDS     r0,r1,#4              ;422
000228  6118              STR      r0,[r3,#0x10]         ;422
00022a  680d              LDR      r5,[r1,#0]            ;422
00022c  8ad9              LDRH     r1,[r3,#0x16]         ;423
00022e  1e49              SUBS     r1,r1,#1              ;423
000230  82d9              STRH     r1,[r3,#0x16]         ;423
000232  6899              LDR      r1,[r3,#8]            ;424
000234  4288              CMP      r0,r1                 ;424
000236  d101              BNE      |L1.572|
000238  6858              LDR      r0,[r3,#4]            ;425
00023a  6118              STR      r0,[r3,#0x10]         ;425
                  |L1.572|
00023c  4648              MOV      r0,r9                 ;427
00023e  f7fffffe          BL       OS_CPU_SR_Restore
000242  7026              STRB     r6,[r4,#0]            ;428
000244  4628              MOV      r0,r5                 ;429
000246  e8bd87f0          POP      {r4-r10,pc}
                  |L1.586|
00024a  4f81              LDR      r7,|L1.1104|
00024c  683a              LDR      r2,[r7,#0]            ;431  ; OSTCBCur
00024e  f8920030          LDRB     r0,[r2,#0x30]         ;431
000252  f0400004          ORR      r0,r0,#4              ;431
000256  f8820030          STRB     r0,[r2,#0x30]         ;431
00025a  f8826031          STRB     r6,[r2,#0x31]         ;432
00025e  f8a2802e          STRH     r8,[r2,#0x2e]         ;433
000262  4628              MOV      r0,r5                 ;434
000264  f7fffffe          BL       OS_EventTaskWait
000268  4648              MOV      r0,r9                 ;435
00026a  f7fffffe          BL       OS_CPU_SR_Restore
00026e  f7fffffe          BL       OS_Sched
000272  f7fffffe          BL       OS_CPU_SR_Save
000276  4680              MOV      r8,r0                 ;437
000278  6838              LDR      r0,[r7,#0]            ;438  ; OSTCBCur
00027a  f8901031          LDRB     r1,[r0,#0x31]         ;438
00027e  b1a9              CBZ      r1,|L1.684|
000280  2902              CMP      r1,#2                 ;438
000282  d016              BEQ      |L1.690|
000284  4629              MOV      r1,r5                 ;451
000286  f7fffffe          BL       OS_EventTaskRemove
00028a  2500              MOVS     r5,#0                 ;452
00028c  200a              MOVS     r0,#0xa               ;453
00028e  7020              STRB     r0,[r4,#0]            ;453
                  |L1.656|
000290  6838              LDR      r0,[r7,#0]            ;456  ; OSTCBCur
000292  f8806030          STRB     r6,[r0,#0x30]         ;456
000296  f8806031          STRB     r6,[r0,#0x31]         ;457
00029a  61c6              STR      r6,[r0,#0x1c]         ;458
00029c  6206              STR      r6,[r0,#0x20]         ;460
00029e  6246              STR      r6,[r0,#0x24]         ;462
0002a0  4640              MOV      r0,r8                 ;463
0002a2  f7fffffe          BL       OS_CPU_SR_Restore
0002a6  4628              MOV      r0,r5                 ;464
0002a8  e8bd87f0          POP      {r4-r10,pc}
                  |L1.684|
0002ac  6a45              LDR      r5,[r0,#0x24]         ;440
0002ae  7026              STRB     r6,[r4,#0]            ;441
0002b0  e7ee              B        |L1.656|
                  |L1.690|
0002b2  2500              MOVS     r5,#0                 ;445
0002b4  200e              MOVS     r0,#0xe               ;446
0002b6  7020              STRB     r0,[r4,#0]            ;446
0002b8  e7ea              B        |L1.656|
;;;466    /*$PAGE*/
                          ENDP

                  OSQPendAbort PROC
;;;499    #if OS_Q_PEND_ABORT_EN > 0
;;;500    INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
0002ba  e92d41f0          PUSH     {r4-r8,lr}
;;;501    {
0002be  4605              MOV      r5,r0
0002c0  4688              MOV      r8,r1
0002c2  4616              MOV      r6,r2
;;;502        INT8U      nbr_tasks;
;;;503    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;504        OS_CPU_SR  cpu_sr = 0;
;;;505    #endif
;;;506    
;;;507    
;;;508    
;;;509    #if OS_ARG_CHK_EN > 0
;;;510        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
;;;511            return (0);
;;;512        }
;;;513        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;514            *perr = OS_ERR_PEVENT_NULL;
;;;515            return (0);
;;;516        }
;;;517    #endif
;;;518        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
0002c4  7829              LDRB     r1,[r5,#0]
;;;519            *perr = OS_ERR_EVENT_TYPE;
0002c6  2001              MOVS     r0,#1
0002c8  2902              CMP      r1,#2                 ;518
0002ca  d003              BEQ      |L1.724|
0002cc  7030              STRB     r0,[r6,#0]
;;;520            return (0);
0002ce  2000              MOVS     r0,#0
;;;521        }
;;;522        OS_ENTER_CRITICAL();
;;;523        if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
;;;524            nbr_tasks = 0;
;;;525            switch (opt) {
;;;526                case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
;;;527                     while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
;;;528                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
;;;529                         nbr_tasks++;
;;;530                     }
;;;531                     break;
;;;532                   
;;;533                case OS_PEND_OPT_NONE:
;;;534                default:                                       /* No,  ready HPT       waiting on queue    */
;;;535                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
;;;536                     nbr_tasks++;
;;;537                     break;
;;;538            }
;;;539            OS_EXIT_CRITICAL();
;;;540            OS_Sched();                                        /* Find HPT ready to run                    */
;;;541            *perr = OS_ERR_PEND_ABORT;
;;;542            return (nbr_tasks);
;;;543        }
;;;544        OS_EXIT_CRITICAL();
;;;545        *perr = OS_ERR_NONE;
;;;546        return (0);                                            /* No tasks waiting on queue                */
;;;547    }
0002d0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.724|
0002d4  f7fffffe          BL       OS_CPU_SR_Save
0002d8  4607              MOV      r7,r0                 ;522
0002da  7aa8              LDRB     r0,[r5,#0xa]          ;523
0002dc  b300              CBZ      r0,|L1.800|
0002de  2400              MOVS     r4,#0                 ;524
0002e0  f1b80f01          CMP      r8,#1                 ;525
0002e4  d010              BEQ      |L1.776|
0002e6  2302              MOVS     r3,#2                 ;535
0002e8  2204              MOVS     r2,#4                 ;535
0002ea  2100              MOVS     r1,#0                 ;535
0002ec  4628              MOV      r0,r5                 ;535
0002ee  f7fffffe          BL       OS_EventTaskRdy
0002f2  2401              MOVS     r4,#1                 ;536
                  |L1.756|
0002f4  4638              MOV      r0,r7                 ;539
0002f6  f7fffffe          BL       OS_CPU_SR_Restore
0002fa  f7fffffe          BL       OS_Sched
0002fe  200e              MOVS     r0,#0xe               ;541
000300  7030              STRB     r0,[r6,#0]            ;541
000302  4620              MOV      r0,r4                 ;542
000304  e8bd81f0          POP      {r4-r8,pc}
                  |L1.776|
000308  2302              MOVS     r3,#2                 ;528
00030a  2204              MOVS     r2,#4                 ;528
00030c  2100              MOVS     r1,#0                 ;528
00030e  4628              MOV      r0,r5                 ;528
000310  f7fffffe          BL       OS_EventTaskRdy
000314  1c60              ADDS     r0,r4,#1              ;529
000316  b2c4              UXTB     r4,r0                 ;529
000318  7aa8              LDRB     r0,[r5,#0xa]          ;527
00031a  2800              CMP      r0,#0                 ;527
00031c  d1f4              BNE      |L1.776|
00031e  e7e9              B        |L1.756|
                  |L1.800|
000320  4638              MOV      r0,r7                 ;544
000322  f7fffffe          BL       OS_CPU_SR_Restore
000326  2000              MOVS     r0,#0                 ;545
000328  7030              STRB     r0,[r6,#0]            ;545
00032a  e8bd81f0          POP      {r4-r8,pc}
;;;548    #endif
                          ENDP

                  OSQPost PROC
;;;570    #if OS_Q_POST_EN > 0
;;;571    INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
00032e  b570              PUSH     {r4-r6,lr}
;;;572    {
000330  4604              MOV      r4,r0
000332  460d              MOV      r5,r1
;;;573        OS_Q      *pq;
;;;574    #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;575        OS_CPU_SR  cpu_sr = 0;
;;;576    #endif
;;;577    
;;;578    
;;;579    
;;;580    #if OS_ARG_CHK_EN > 0
;;;581        if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
;;;582            return (OS_ERR_PEVENT_NULL);
;;;583        }
;;;584    #endif
;;;585        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
000334  7820              LDRB     r0,[r4,#0]
000336  2802              CMP      r0,#2
000338  d001              BEQ      |L1.830|
;;;586            return (OS_ERR_EVENT_TYPE);
00033a  2001              MOVS     r0,#1
;;;587        }
;;;588        OS_ENTER_CRITICAL();
;;;589        if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
;;;590                                                           /* Ready highest priority task waiting on event */
;;;591            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;592            OS_EXIT_CRITICAL();
;;;593            OS_Sched();                                    /* Find highest priority task ready to run      */
;;;594            return (OS_ERR_NONE);
;;;595        }
;;;596        pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
;;;597        if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
;;;598            OS_EXIT_CRITICAL();
;;;599            return (OS_ERR_Q_FULL);
;;;600        }
;;;601        *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
;;;602        pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
;;;603        if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
;;;604            pq->OSQIn = pq->OSQStart;
;;;605        }
;;;606        OS_EXIT_CRITICAL();
;;;607        return (OS_ERR_NONE);
;;;608    }
00033c  bd70              POP      {r4-r6,pc}
                  |L1.830|
00033e  f7fffffe          BL       OS_CPU_SR_Save
000342  4606              MOV      r6,r0                 ;588
000344  7aa0              LDRB     r0,[r4,#0xa]          ;589
000346  b160              CBZ      r0,|L1.866|
000348  2300              MOVS     r3,#0                 ;591
00034a  2204              MOVS     r2,#4                 ;591
00034c  4629              MOV      r1,r5                 ;591
00034e  4620              MOV      r0,r4                 ;591
000350  f7fffffe          BL       OS_EventTaskRdy
000354  4630              MOV      r0,r6                 ;592
000356  f7fffffe          BL       OS_CPU_SR_Restore
00035a  f7fffffe          BL       OS_Sched
00035e  2000              MOVS     r0,#0                 ;594
000360  bd70              POP      {r4-r6,pc}
                  |L1.866|
000362  6860              LDR      r0,[r4,#4]            ;596
000364  8ac1              LDRH     r1,[r0,#0x16]         ;597
000366  8a82              LDRH     r2,[r0,#0x14]         ;597
000368  4291              CMP      r1,r2                 ;597
00036a  d304              BCC      |L1.886|
00036c  4630              MOV      r0,r6                 ;598
00036e  f7fffffe          BL       OS_CPU_SR_Restore
000372  201e              MOVS     r0,#0x1e              ;599
000374  bd70              POP      {r4-r6,pc}
                  |L1.886|
000376  68c2              LDR      r2,[r0,#0xc]          ;601
000378  1d11              ADDS     r1,r2,#4              ;601
00037a  60c1              STR      r1,[r0,#0xc]          ;601
00037c  6015              STR      r5,[r2,#0]            ;601
00037e  8ac1              LDRH     r1,[r0,#0x16]         ;602
000380  1c49              ADDS     r1,r1,#1              ;602
000382  82c1              STRH     r1,[r0,#0x16]         ;602
000384  6882              LDR      r2,[r0,#8]            ;603
000386  68c1              LDR      r1,[r0,#0xc]          ;603
000388  4291              CMP      r1,r2                 ;603
00038a  d101              BNE      |L1.912|
00038c  6841              LDR      r1,[r0,#4]            ;604
00038e  60c1              STR      r1,[r0,#0xc]          ;604
                  |L1.912|
000390  4630              MOV      r0,r6                 ;606
000392  f7fffffe          BL       OS_CPU_SR_Restore
000396  2000              MOVS     r0,#0                 ;607
000398  bd70              POP      {r4-r6,pc}
;;;609    #endif
                          ENDP

                  OSQPostFront PROC
;;;632    #if OS_Q_POST_FRONT_EN > 0
;;;633    INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
00039a  b570              PUSH     {r4-r6,lr}
;;;634    {
00039c  4604              MOV      r4,r0
00039e  460d              MOV      r5,r1
;;;635        OS_Q      *pq;
;;;636    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;637        OS_CPU_SR  cpu_sr = 0;
;;;638    #endif
;;;639    
;;;640    
;;;641    
;;;642    #if OS_ARG_CHK_EN > 0
;;;643        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;644            return (OS_ERR_PEVENT_NULL);
;;;645        }
;;;646    #endif
;;;647        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
0003a0  7820              LDRB     r0,[r4,#0]
0003a2  2802              CMP      r0,#2
0003a4  d001              BEQ      |L1.938|
;;;648            return (OS_ERR_EVENT_TYPE);
0003a6  2001              MOVS     r0,#1
;;;649        }
;;;650        OS_ENTER_CRITICAL();
;;;651        if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
;;;652                                                          /* Ready highest priority task waiting on event  */
;;;653            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;654            OS_EXIT_CRITICAL();
;;;655            OS_Sched();                                   /* Find highest priority task ready to run       */
;;;656            return (OS_ERR_NONE);
;;;657        }
;;;658        pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
;;;659        if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
;;;660            OS_EXIT_CRITICAL();
;;;661            return (OS_ERR_Q_FULL);
;;;662        }
;;;663        if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
;;;664            pq->OSQOut = pq->OSQEnd;
;;;665        }
;;;666        pq->OSQOut--;
;;;667        *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
;;;668        pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
;;;669        OS_EXIT_CRITICAL();
;;;670        return (OS_ERR_NONE);
;;;671    }
0003a8  bd70              POP      {r4-r6,pc}
                  |L1.938|
0003aa  f7fffffe          BL       OS_CPU_SR_Save
0003ae  4606              MOV      r6,r0                 ;650
0003b0  7aa0              LDRB     r0,[r4,#0xa]          ;651
0003b2  b160              CBZ      r0,|L1.974|
0003b4  2300              MOVS     r3,#0                 ;653
0003b6  2204              MOVS     r2,#4                 ;653
0003b8  4629              MOV      r1,r5                 ;653
0003ba  4620              MOV      r0,r4                 ;653
0003bc  f7fffffe          BL       OS_EventTaskRdy
0003c0  4630              MOV      r0,r6                 ;654
0003c2  f7fffffe          BL       OS_CPU_SR_Restore
0003c6  f7fffffe          BL       OS_Sched
0003ca  2000              MOVS     r0,#0                 ;656
0003cc  bd70              POP      {r4-r6,pc}
                  |L1.974|
0003ce  6860              LDR      r0,[r4,#4]            ;658
0003d0  8ac1              LDRH     r1,[r0,#0x16]         ;659
0003d2  8a82              LDRH     r2,[r0,#0x14]         ;659
0003d4  4291              CMP      r1,r2                 ;659
0003d6  d304              BCC      |L1.994|
0003d8  4630              MOV      r0,r6                 ;660
0003da  f7fffffe          BL       OS_CPU_SR_Restore
0003de  201e              MOVS     r0,#0x1e              ;661
0003e0  bd70              POP      {r4-r6,pc}
                  |L1.994|
0003e2  6842              LDR      r2,[r0,#4]            ;663
0003e4  6901              LDR      r1,[r0,#0x10]         ;663
0003e6  4291              CMP      r1,r2                 ;663
0003e8  d101              BNE      |L1.1006|
0003ea  6881              LDR      r1,[r0,#8]            ;664
0003ec  6101              STR      r1,[r0,#0x10]         ;664
                  |L1.1006|
0003ee  6901              LDR      r1,[r0,#0x10]         ;666
0003f0  1f0a              SUBS     r2,r1,#4              ;666
0003f2  6102              STR      r2,[r0,#0x10]         ;666
0003f4  6015              STR      r5,[r2,#0]            ;667
0003f6  8ac1              LDRH     r1,[r0,#0x16]         ;668
0003f8  1c49              ADDS     r1,r1,#1              ;668
0003fa  82c1              STRH     r1,[r0,#0x16]         ;668
0003fc  4630              MOV      r0,r6                 ;669
0003fe  f7fffffe          BL       OS_CPU_SR_Restore
000402  2000              MOVS     r0,#0                 ;670
000404  bd70              POP      {r4-r6,pc}
;;;672    #endif
                          ENDP

                  OSQPostOpt PROC
;;;703    #if OS_Q_POST_OPT_EN > 0
;;;704    INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
000406  e92d41f0          PUSH     {r4-r8,lr}
;;;705    {
00040a  4604              MOV      r4,r0
00040c  460e              MOV      r6,r1
00040e  4615              MOV      r5,r2
;;;706        OS_Q      *pq;
;;;707    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;708        OS_CPU_SR  cpu_sr = 0;
;;;709    #endif
;;;710    
;;;711    
;;;712    
;;;713    #if OS_ARG_CHK_EN > 0
;;;714        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;715            return (OS_ERR_PEVENT_NULL);
;;;716        }
;;;717    #endif
;;;718        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
000410  7820              LDRB     r0,[r4,#0]
000412  2802              CMP      r0,#2
000414  d002              BEQ      |L1.1052|
;;;719            return (OS_ERR_EVENT_TYPE);
000416  2001              MOVS     r0,#1
;;;720        }
;;;721        OS_ENTER_CRITICAL();
;;;722        if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
;;;723            if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
;;;724                while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
;;;725                    (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;726                }
;;;727            } else {                                      /* No,  Post to HPT waiting on queue             */
;;;728                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
;;;729            }
;;;730            OS_EXIT_CRITICAL();
;;;731            if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
;;;732                OS_Sched();                               /* Find highest priority task ready to run       */
;;;733            }
;;;734            return (OS_ERR_NONE);
;;;735        }
;;;736        pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
;;;737        if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
;;;738            OS_EXIT_CRITICAL();
;;;739            return (OS_ERR_Q_FULL);
;;;740        }
;;;741        if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
;;;742            if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
;;;743                pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
;;;744            }
;;;745            pq->OSQOut--;
;;;746            *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
;;;747        } else {                                          /* No,  Post as FIFO                             */
;;;748            *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
;;;749            if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
;;;750                pq->OSQIn = pq->OSQStart;
;;;751            }
;;;752        }
;;;753        pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
;;;754        OS_EXIT_CRITICAL();
;;;755        return (OS_ERR_NONE);
;;;756    }
000418  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1052|
00041c  f7fffffe          BL       OS_CPU_SR_Save
000420  4607              MOV      r7,r0                 ;721
000422  7aa0              LDRB     r0,[r4,#0xa]          ;722
000424  b338              CBZ      r0,|L1.1142|
000426  f0150f01          TST      r5,#1                 ;723
00042a  d013              BEQ      |L1.1108|
                  |L1.1068|
00042c  2300              MOVS     r3,#0                 ;725
00042e  2204              MOVS     r2,#4                 ;725
000430  4631              MOV      r1,r6                 ;725
000432  4620              MOV      r0,r4                 ;725
000434  f7fffffe          BL       OS_EventTaskRdy
000438  7aa0              LDRB     r0,[r4,#0xa]          ;724
00043a  2800              CMP      r0,#0                 ;724
00043c  d1f6              BNE      |L1.1068|
00043e  e00f              B        |L1.1120|
                  |L1.1088|
                          DCD      OSIntNesting
                  |L1.1092|
                          DCD      OSEventFreeList
                  |L1.1096|
                          DCD      OSQFreeList
                  |L1.1100|
                          DCD      OSLockNesting
                  |L1.1104|
                          DCD      OSTCBCur
                  |L1.1108|
000454  2300              MOVS     r3,#0                 ;728
000456  2204              MOVS     r2,#4                 ;728
000458  4631              MOV      r1,r6                 ;728
00045a  4620              MOV      r0,r4                 ;728
00045c  f7fffffe          BL       OS_EventTaskRdy
                  |L1.1120|
000460  4638              MOV      r0,r7                 ;730
000462  f7fffffe          BL       OS_CPU_SR_Restore
000466  f0150f04          TST      r5,#4                 ;731
00046a  d101              BNE      |L1.1136|
00046c  f7fffffe          BL       OS_Sched
                  |L1.1136|
000470  2000              MOVS     r0,#0                 ;734
000472  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1142|
000476  6860              LDR      r0,[r4,#4]            ;736
000478  8ac1              LDRH     r1,[r0,#0x16]         ;737
00047a  8a82              LDRH     r2,[r0,#0x14]         ;737
00047c  4291              CMP      r1,r2                 ;737
00047e  d305              BCC      |L1.1164|
000480  4638              MOV      r0,r7                 ;738
000482  f7fffffe          BL       OS_CPU_SR_Restore
000486  201e              MOVS     r0,#0x1e              ;739
000488  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1164|
00048c  f0150f02          TST      r5,#2                 ;741
000490  d00a              BEQ      |L1.1192|
000492  6842              LDR      r2,[r0,#4]            ;742
000494  6901              LDR      r1,[r0,#0x10]         ;742
000496  4291              CMP      r1,r2                 ;742
000498  d101              BNE      |L1.1182|
00049a  6881              LDR      r1,[r0,#8]            ;743
00049c  6101              STR      r1,[r0,#0x10]         ;743
                  |L1.1182|
00049e  6901              LDR      r1,[r0,#0x10]         ;745
0004a0  1f0a              SUBS     r2,r1,#4              ;745
0004a2  6102              STR      r2,[r0,#0x10]         ;745
0004a4  6016              STR      r6,[r2,#0]            ;746
0004a6  e009              B        |L1.1212|
                  |L1.1192|
0004a8  68c1              LDR      r1,[r0,#0xc]          ;748
0004aa  1d0a              ADDS     r2,r1,#4              ;748
0004ac  60c2              STR      r2,[r0,#0xc]          ;748
0004ae  600e              STR      r6,[r1,#0]            ;748
0004b0  6882              LDR      r2,[r0,#8]            ;749
0004b2  68c1              LDR      r1,[r0,#0xc]          ;749
0004b4  4291              CMP      r1,r2                 ;749
0004b6  d101              BNE      |L1.1212|
0004b8  6841              LDR      r1,[r0,#4]            ;750
0004ba  60c1              STR      r1,[r0,#0xc]          ;750
                  |L1.1212|
0004bc  8ac1              LDRH     r1,[r0,#0x16]         ;753
0004be  1c49              ADDS     r1,r1,#1              ;753
0004c0  82c1              STRH     r1,[r0,#0x16]         ;753
0004c2  4638              MOV      r0,r7                 ;754
0004c4  f7fffffe          BL       OS_CPU_SR_Restore
0004c8  2000              MOVS     r0,#0                 ;755
0004ca  e8bd81f0          POP      {r4-r8,pc}
;;;757    #endif
                          ENDP

                  OSQQuery PROC
;;;777    #if OS_Q_QUERY_EN > 0
;;;778    INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
0004ce  b570              PUSH     {r4-r6,lr}
;;;779    {
0004d0  4605              MOV      r5,r0
0004d2  460c              MOV      r4,r1
;;;780        OS_Q      *pq;
;;;781        INT8U      i;
;;;782    #if OS_LOWEST_PRIO <= 63
;;;783        INT8U     *psrc;
;;;784        INT8U     *pdest;
;;;785    #else
;;;786        INT16U    *psrc;
;;;787        INT16U    *pdest;
;;;788    #endif
;;;789    #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;790        OS_CPU_SR  cpu_sr = 0;
;;;791    #endif
;;;792    
;;;793    
;;;794    
;;;795    #if OS_ARG_CHK_EN > 0
;;;796        if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
;;;797            return (OS_ERR_PEVENT_NULL);
;;;798        }
;;;799        if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
;;;800            return (OS_ERR_PDATA_NULL);
;;;801        }
;;;802    #endif
;;;803        if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
0004d4  7828              LDRB     r0,[r5,#0]
0004d6  2802              CMP      r0,#2
0004d8  d001              BEQ      |L1.1246|
;;;804            return (OS_ERR_EVENT_TYPE);
0004da  2001              MOVS     r0,#1
;;;805        }
;;;806        OS_ENTER_CRITICAL();
;;;807        p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
;;;808        psrc                 = &pevent->OSEventTbl[0];
;;;809        pdest                = &p_q_data->OSEventTbl[0];
;;;810        for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
;;;811            *pdest++ = *psrc++;
;;;812        }
;;;813        pq = (OS_Q *)pevent->OSEventPtr;
;;;814        if (pq->OSQEntries > 0) {
;;;815            p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
;;;816        } else {
;;;817            p_q_data->OSMsg = (void *)0;
;;;818        }
;;;819        p_q_data->OSNMsgs = pq->OSQEntries;
;;;820        p_q_data->OSQSize = pq->OSQSize;
;;;821        OS_EXIT_CRITICAL();
;;;822        return (OS_ERR_NONE);
;;;823    }
0004dc  bd70              POP      {r4-r6,pc}
                  |L1.1246|
0004de  f7fffffe          BL       OS_CPU_SR_Save
0004e2  4601              MOV      r1,r0                 ;806
0004e4  7aa8              LDRB     r0,[r5,#0xa]          ;807
0004e6  7320              STRB     r0,[r4,#0xc]          ;807
0004e8  f105030b          ADD      r3,r5,#0xb            ;808
0004ec  f1040c08          ADD      r12,r4,#8             ;809
0004f0  2200              MOVS     r2,#0                 ;810
                  |L1.1266|
0004f2  f8130b01          LDRB     r0,[r3],#1            ;811
0004f6  f80c0b01          STRB     r0,[r12],#1           ;811
0004fa  1c50              ADDS     r0,r2,#1              ;810
0004fc  b2c2              UXTB     r2,r0                 ;810
0004fe  2a04              CMP      r2,#4                 ;810
000500  d3f7              BCC      |L1.1266|
000502  6868              LDR      r0,[r5,#4]            ;813
000504  8ac2              LDRH     r2,[r0,#0x16]         ;814
000506  b11a              CBZ      r2,|L1.1296|
000508  6902              LDR      r2,[r0,#0x10]         ;815
00050a  6812              LDR      r2,[r2,#0]            ;815
00050c  6022              STR      r2,[r4,#0]            ;815
00050e  e001              B        |L1.1300|
                  |L1.1296|
000510  2200              MOVS     r2,#0                 ;817
000512  6022              STR      r2,[r4,#0]            ;817
                  |L1.1300|
000514  8ac2              LDRH     r2,[r0,#0x16]         ;819
000516  80a2              STRH     r2,[r4,#4]            ;819
000518  8a80              LDRH     r0,[r0,#0x14]         ;820
00051a  80e0              STRH     r0,[r4,#6]            ;820
00051c  4608              MOV      r0,r1                 ;821
00051e  f7fffffe          BL       OS_CPU_SR_Restore
000522  2000              MOVS     r0,#0                 ;822
000524  bd70              POP      {r4-r6,pc}
;;;824    #endif                                                 /* OS_Q_QUERY_EN                                */
                          ENDP

                  OS_QInit PROC
;;;841    
;;;842    void  OS_QInit (void)
000526  b510              PUSH     {r4,lr}
;;;843    {
;;;844    #if OS_MAX_QS == 1
;;;845        OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
;;;846        OSQFreeList->OSQPtr = (OS_Q *)0;
;;;847    #endif
;;;848    
;;;849    #if OS_MAX_QS >= 2
;;;850        INT16U  i;
;;;851        OS_Q   *pq1;
;;;852        OS_Q   *pq2;
;;;853    
;;;854    
;;;855    
;;;856        OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
000528  21f0              MOVS     r1,#0xf0
00052a  480a              LDR      r0,|L1.1364|
00052c  f7fffffe          BL       OS_MemClr
;;;857        pq1 = &OSQTbl[0];
000530  4808              LDR      r0,|L1.1364|
;;;858        pq2 = &OSQTbl[1];
000532  4603              MOV      r3,r0
000534  f1030218          ADD      r2,r3,#0x18
;;;859        for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
000538  2100              MOVS     r1,#0
                  |L1.1338|
;;;860            pq1->OSQPtr = pq2;
00053a  6002              STR      r2,[r0,#0]
;;;861            pq1++;
00053c  3018              ADDS     r0,r0,#0x18
;;;862            pq2++;
00053e  3218              ADDS     r2,r2,#0x18
000540  1c49              ADDS     r1,r1,#1              ;859
000542  b289              UXTH     r1,r1                 ;859
000544  2909              CMP      r1,#9                 ;859
000546  d3f8              BCC      |L1.1338|
;;;863        }
;;;864        pq1->OSQPtr = (OS_Q *)0;
000548  2100              MOVS     r1,#0
00054a  6001              STR      r1,[r0,#0]
;;;865        OSQFreeList = &OSQTbl[0];
00054c  4802              LDR      r0,|L1.1368|
00054e  6003              STR      r3,[r0,#0]  ; OSQFreeList
;;;866    #endif
;;;867    }
000550  bd10              POP      {r4,pc}
;;;868    #endif                                               /* OS_Q_EN                                        */
                          ENDP

000552  0000              DCW      0x0000
                  |L1.1364|
                          DCD      OSQTbl
                  |L1.1368|
                          DCD      OSQFreeList
