; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\wm.o --depend=.\rvmdk\wm.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\wm.crf ..\..\..\..\..\uCGUI\GUI\WM\WM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _CheckCriticalHandles PROC
;;;99     */
;;;100    static void _CheckCriticalHandles(WM_HWIN hWin) {
000000  49fa              LDR      r1,|L1.1004|
;;;101      WM_CRITICAL_HANDLE * pCH;
;;;102      for (pCH = WM__pFirstCriticalHandle; pCH; pCH = pCH->pNext) {
000002  6989              LDR      r1,[r1,#0x18]  ; WM__pFirstCriticalHandle
000004  2900              CMP      r1,#0
000006  d008              BEQ      |L1.26|
000008  2200              MOVS     r2,#0
                  |L1.10|
;;;103        if (pCH->hWin == hWin) {
00000a  f9b13004          LDRSH    r3,[r1,#4]
00000e  4283              CMP      r3,r0
000010  d100              BNE      |L1.20|
;;;104          pCH->hWin = 0;
000012  808a              STRH     r2,[r1,#4]
                  |L1.20|
000014  6809              LDR      r1,[r1,#0]            ;102
000016  2900              CMP      r1,#0                 ;102
000018  d1f7              BNE      |L1.10|
                  |L1.26|
;;;105        }
;;;106      }
;;;107    }
00001a  4770              BX       lr
;;;108    
                          ENDP

                  _DesktopHandle2Index PROC
;;;119    */
;;;120    static int _DesktopHandle2Index(WM_HWIN hDesktop) {
00001c  49f4              LDR      r1,|L1.1008|
;;;121    #if GUI_NUM_LAYERS > 1
;;;122      int i;
;;;123      for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;124        if (hDesktop == WM__ahDesktopWin[i]) {
;;;125          return i;
;;;126        }
;;;127      }
;;;128    #else
;;;129      if (hDesktop == WM__ahDesktopWin[0]) {
00001e  f9b11000          LDRSH    r1,[r1,#0]  ; WM__ahDesktopWin
000022  4281              CMP      r1,r0
000024  d101              BNE      |L1.42|
;;;130        return 0;
000026  2000              MOVS     r0,#0
;;;131      }
;;;132    #endif
;;;133      return -1;
;;;134    }
000028  4770              BX       lr
                  |L1.42|
00002a  f04f30ff          MOV      r0,#0xffffffff        ;133
00002e  4770              BX       lr
;;;135    
                          ENDP

                  ResetNextDrawWin PROC
;;;155    */
;;;156    static void ResetNextDrawWin(void) {
000030  49ee              LDR      r1,|L1.1004|
;;;157      NextDrawWin = WM_HWIN_NULL;
000032  2000              MOVS     r0,#0
000034  8288              STRH     r0,[r1,#0x14]
;;;158    }
000036  4770              BX       lr
;;;159    
                          ENDP

                  _GethDrawWin PROC
;;;167    */
;;;168    static WM_HWIN _GethDrawWin(void) {
000038  48ec              LDR      r0,|L1.1004|
;;;169      WM_HWIN h;
;;;170      #if WM_SUPPORT_TRANSPARENCY
;;;171        if (WM__hATransWindow) {
00003a  f9b00012          LDRSH    r0,[r0,#0x12]  ; WM__hATransWindow
00003e  2800              CMP      r0,#0
000040  d102              BNE      |L1.72|
;;;172          h = WM__hATransWindow;
;;;173        } else
;;;174      #endif
;;;175      {
;;;176        h = GUI_Context.hAWin;
000042  48ec              LDR      r0,|L1.1012|
000044  f9b00040          LDRSH    r0,[r0,#0x40]  ; GUI_Context
                  |L1.72|
;;;177      }
;;;178      return h;
;;;179    }
000048  4770              BX       lr
;;;180    
                          ENDP

                  WM__Client2Screen PROC
;;;462    */
;;;463    void WM__Client2Screen(const WM_Obj* pWin, GUI_RECT *pRect) {
00004a  460b              MOV      r3,r1
;;;464      GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
00004c  f9b02002          LDRSH    r2,[r0,#2]
000050  f9b01000          LDRSH    r1,[r0,#0]
000054  4618              MOV      r0,r3
000056  f7ffbffe          B.W      GUI_MoveRect
;;;465    }
;;;466    
                          ENDP

                  _SetClipRectUserIntersect PROC
;;;184    */
;;;185    static void _SetClipRectUserIntersect(const GUI_RECT* prSrc) {
00005a  b510              PUSH     {r4,lr}
00005c  b082              SUB      sp,sp,#8
00005e  4604              MOV      r4,r0
;;;186      if (GUI_Context.WM__pUserClipRect == NULL) {
000060  48e4              LDR      r0,|L1.1012|
000062  6bc0              LDR      r0,[r0,#0x3c]  ; GUI_Context
000064  b198              CBZ      r0,|L1.142|
;;;187        LCD_SetClipRectEx(prSrc);
;;;188      } else {
;;;189        GUI_RECT r;
;;;190        r = *GUI_Context.WM__pUserClipRect;             
000066  6802              LDR      r2,[r0,#0]
000068  9200              STR      r2,[sp,#0]
00006a  6840              LDR      r0,[r0,#4]
00006c  9001              STR      r0,[sp,#4]
;;;191        WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
00006e  f7fffffe          BL       _GethDrawWin
000072  f7fffffe          BL       GUI_ALLOC_h2p
000076  4669              MOV      r1,sp
000078  f7fffffe          BL       WM__Client2Screen
;;;192        /* Set intersection as clip rect */    
;;;193        GUI__IntersectRect(&r, prSrc);
00007c  4621              MOV      r1,r4
00007e  4668              MOV      r0,sp
000080  f7fffffe          BL       GUI__IntersectRect
;;;194        LCD_SetClipRectEx(&r);
000084  4668              MOV      r0,sp
000086  f7fffffe          BL       LCD_SetClipRectEx
;;;195      }
;;;196    }
00008a  b002              ADD      sp,sp,#8
00008c  bd10              POP      {r4,pc}
                  |L1.142|
00008e  b002              ADD      sp,sp,#8              ;187
000090  4620              MOV      r0,r4                 ;187
000092  e8bd4010          POP      {r4,lr}               ;187
000096  f7ffbffe          B.W      LCD_SetClipRectEx
;;;197    
                          ENDP

                  WM__RectIsNZ PROC
;;;613    */
;;;614    int WM__RectIsNZ(const GUI_RECT* pr) {
00009a  f9b01000          LDRSH    r1,[r0,#0]
;;;615      if (pr->x0 > pr->x1)
00009e  f9b02004          LDRSH    r2,[r0,#4]
0000a2  4291              CMP      r1,r2
0000a4  dd01              BLE      |L1.170|
;;;616        return 0;
0000a6  2000              MOVS     r0,#0
;;;617      if (pr->y0 > pr->y1)
;;;618        return 0;
;;;619      return 1;
;;;620    }
0000a8  4770              BX       lr
                  |L1.170|
0000aa  f9b01002          LDRSH    r1,[r0,#2]            ;617
0000ae  f9b00006          LDRSH    r0,[r0,#6]            ;617
0000b2  4281              CMP      r1,r0                 ;617
0000b4  dd01              BLE      |L1.186|
0000b6  2000              MOVS     r0,#0                 ;618
0000b8  4770              BX       lr
                  |L1.186|
0000ba  2001              MOVS     r0,#1                 ;619
0000bc  4770              BX       lr
;;;621    
                          ENDP

                  WM__Invalidate1Abs PROC
;;;209    */
;;;210    void WM__Invalidate1Abs(WM_HWIN hWin, const GUI_RECT * pRect) {
0000be  b530              PUSH     {r4,r5,lr}
0000c0  b083              SUB      sp,sp,#0xc
0000c2  460d              MOV      r5,r1
;;;211      GUI_RECT r;
;;;212      WM_Obj* pWin;
;;;213      int Status;
;;;214      pWin = WM_H2P(hWin);
0000c4  f7fffffe          BL       GUI_ALLOC_h2p
0000c8  4604              MOV      r4,r0
;;;215      Status = pWin->Status;
0000ca  8ba0              LDRH     r0,[r4,#0x1c]
;;;216      if ((Status & WM_SF_ISVIS) == 0) {
0000cc  f0100f02          TST      r0,#2
0000d0  d01d              BEQ      |L1.270|
;;;217        return;   /* Window is not visible... we are done */
;;;218      }
;;;219      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
0000d2  f6400101          MOV      r1,#0x801
0000d6  4008              ANDS     r0,r0,r1
0000d8  2801              CMP      r0,#1
0000da  d018              BEQ      |L1.270|
;;;220        return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
;;;221      }
;;;222      if (WM__RectIsNZ(pRect) == 0) {
0000dc  4628              MOV      r0,r5
0000de  f7fffffe          BL       WM__RectIsNZ
0000e2  2800              CMP      r0,#0
0000e4  d013              BEQ      |L1.270|
;;;223        return;   /* Nothing to do ... */
;;;224      }
;;;225      /* Calc affected area */
;;;226      GUI__IntersectRects(&r, pRect, &pWin->Rect);
0000e6  4622              MOV      r2,r4
0000e8  4629              MOV      r1,r5
0000ea  4668              MOV      r0,sp
0000ec  f7fffffe          BL       GUI__IntersectRects
;;;227      if (WM__RectIsNZ(&r)) {
0000f0  4668              MOV      r0,sp
0000f2  f7fffffe          BL       WM__RectIsNZ
0000f6  2800              CMP      r0,#0
0000f8  d009              BEQ      |L1.270|
;;;228        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;229          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;230        #endif
;;;231    
;;;232        if (pWin->Status & WM_SF_INVALID) {
0000fa  8ba0              LDRH     r0,[r4,#0x1c]
0000fc  f0100f20          TST      r0,#0x20
000100  d007              BEQ      |L1.274|
;;;233          GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
000102  f1040108          ADD      r1,r4,#8
000106  466a              MOV      r2,sp
000108  4608              MOV      r0,r1
00010a  f7fffffe          BL       GUI_MergeRect
                  |L1.270|
;;;234        } else {
;;;235          pWin->InvalidRect = r;
;;;236          pWin->Status |= WM_SF_INVALID;
;;;237          WM__NumInvalidWindows++;
;;;238          /* Optional code: Call external routine to notify that drawing is required */
;;;239          #ifdef GUI_X_REDRAW
;;;240          if (_IsInited) {
;;;241            GUI_RECT r;
;;;242            r = pWin->Rect;
;;;243            if (WM__ClipAtParentBorders(&r,  hWin)) {
;;;244              GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
;;;245            }
;;;246          }
;;;247          #endif
;;;248          GUI_X_SIGNAL_EVENT();
;;;249        }
;;;250        /* Debug code: shows invalid areas */
;;;251        #if (WM_SUPPORT_DIAG)
;;;252          if (WM__pfShowInvalid) {
;;;253            (WM__pfShowInvalid)(hWin);
;;;254          }
;;;255        #endif
;;;256      }
;;;257    }
00010e  b003              ADD      sp,sp,#0xc
000110  bd30              POP      {r4,r5,pc}
                  |L1.274|
000112  9a01              LDR      r2,[sp,#4]            ;235
000114  9900              LDR      r1,[sp,#0]            ;235
000116  60e2              STR      r2,[r4,#0xc]          ;235
000118  60a1              STR      r1,[r4,#8]            ;235
00011a  f0400020          ORR      r0,r0,#0x20           ;236
00011e  83a0              STRH     r0,[r4,#0x1c]         ;236
000120  48b2              LDR      r0,|L1.1004|
000122  88c1              LDRH     r1,[r0,#6]            ;237  ; WM__NumInvalidWindows
000124  1c49              ADDS     r1,r1,#1              ;237
000126  80c1              STRH     r1,[r0,#6]            ;237
000128  b003              ADD      sp,sp,#0xc
00012a  bd30              POP      {r4,r5,pc}
;;;258    
                          ENDP

                  WM__ClipAtParentBorders PROC
;;;281    */
;;;282    int WM__ClipAtParentBorders(GUI_RECT* pRect, WM_HWIN hWin) {
00012c  b570              PUSH     {r4-r6,lr}
00012e  4605              MOV      r5,r0
000130  460e              MOV      r6,r1
                  |L1.306|
;;;283      WM_Obj* pWin;
;;;284    
;;;285      /* Iterate up the window hierarchy.
;;;286         If the window is invisible, we are done.
;;;287         Clip at parent boarders.
;;;288         We are done with iterating if hWin has no parent.
;;;289      */
;;;290      do {
;;;291        pWin = WM_H2P(hWin);
000132  4630              MOV      r0,r6
000134  f7fffffe          BL       GUI_ALLOC_h2p
000138  4604              MOV      r4,r0
;;;292        if ((pWin->Status & WM_SF_ISVIS) == 0) {
00013a  8ba0              LDRH     r0,[r4,#0x1c]
00013c  f0100f02          TST      r0,#2
000140  d008              BEQ      |L1.340|
;;;293          return 0;                     /* Invisible */
;;;294        }
;;;295        GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
000142  4621              MOV      r1,r4
000144  4628              MOV      r0,r5
000146  f7fffffe          BL       GUI__IntersectRect
;;;296        if (pWin->hParent == 0) {
00014a  f9b40016          LDRSH    r0,[r4,#0x16]
00014e  b118              CBZ      r0,|L1.344|
;;;297          break;   /* hWin is now the top level window which has no parent */
;;;298        }
;;;299        hWin = pWin->hParent;                    /* Go one level up (parent)*/
000150  4606              MOV      r6,r0
;;;300      } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
000152  e7ee              B        |L1.306|
                  |L1.340|
000154  2000              MOVS     r0,#0                 ;293
;;;301      
;;;302      /* Now check if the top level window is a desktop window. If it is not,
;;;303        then the window is not visible.
;;;304      */
;;;305      if (_DesktopHandle2Index(hWin) < 0) {
;;;306        return 0;           /* No desktop - (unattached) - Nothing to draw */
;;;307      }
;;;308      return 1;               /* Something may be visible */
;;;309    }
000156  bd70              POP      {r4-r6,pc}
                  |L1.344|
000158  4630              MOV      r0,r6                 ;305
00015a  f7fffffe          BL       _DesktopHandle2Index
00015e  2800              CMP      r0,#0                 ;305
000160  da01              BGE      |L1.358|
000162  2000              MOVS     r0,#0                 ;306
000164  bd70              POP      {r4-r6,pc}
                  |L1.358|
000166  2001              MOVS     r0,#1                 ;308
000168  bd70              POP      {r4-r6,pc}
;;;310    
                          ENDP

                  WM__ActivateClipRect PROC
;;;314    */
;;;315    void  WM__ActivateClipRect(void) {
00016a  b510              PUSH     {r4,lr}
00016c  b082              SUB      sp,sp,#8
;;;316      if (WM_IsActive) {
00016e  4c9f              LDR      r4,|L1.1004|
000170  7820              LDRB     r0,[r4,#0]  ; WM_IsActive
000172  b120              CBZ      r0,|L1.382|
;;;317        _SetClipRectUserIntersect(&_ClipContext.CurRect);
000174  b002              ADD      sp,sp,#8
000176  48a0              LDR      r0,|L1.1016|
000178  e8bd4010          POP      {r4,lr}
00017c  e7fe              B        _SetClipRectUserIntersect
                  |L1.382|
;;;318      } else {    /* Window manager disabled, typically because meory device is active */
;;;319        GUI_RECT r;
;;;320        WM_Obj *pAWin;
;;;321        pAWin = WM_H2P(GUI_Context.hAWin);
00017e  489d              LDR      r0,|L1.1012|
000180  f9b00040          LDRSH    r0,[r0,#0x40]  ; GUI_Context
000184  f7fffffe          BL       GUI_ALLOC_h2p
;;;322        r = pAWin->Rect;
000188  6841              LDR      r1,[r0,#4]
00018a  6800              LDR      r0,[r0,#0]
00018c  9101              STR      r1,[sp,#4]
00018e  9000              STR      r0,[sp,#0]
;;;323        #if WM_SUPPORT_TRANSPARENCY
;;;324          if (WM__hATransWindow) {
000190  f9b41012          LDRSH    r1,[r4,#0x12]  ; WM__hATransWindow
000194  b111              CBZ      r1,|L1.412|
;;;325            WM__ClipAtParentBorders(&r, WM__hATransWindow);
000196  4668              MOV      r0,sp
000198  f7fffffe          BL       WM__ClipAtParentBorders
                  |L1.412|
;;;326          }
;;;327        #endif
;;;328        /* Take UserClipRect into account */
;;;329        _SetClipRectUserIntersect(&r);
00019c  4668              MOV      r0,sp
00019e  f7fffffe          BL       _SetClipRectUserIntersect
;;;330      }
;;;331    }
0001a2  b002              ADD      sp,sp,#8
0001a4  bd10              POP      {r4,pc}
;;;332    
                          ENDP

                  WM__InsertWindowIntoList PROC
;;;341    */
;;;342    void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
0001a6  e92d47f0          PUSH     {r4-r10,lr}
0001aa  4607              MOV      r7,r0
0001ac  460c              MOV      r4,r1
;;;343      int OnTop;
;;;344      WM_HWIN hi;
;;;345      WM_Obj * pWin;
;;;346      WM_Obj * pParent;
;;;347      WM_Obj * pi;
;;;348    
;;;349      if (hParent) {
0001ae  2c00              CMP      r4,#0
0001b0  d01b              BEQ      |L1.490|
;;;350        pWin = WM_H2P(hWin);
0001b2  4638              MOV      r0,r7
0001b4  f7fffffe          BL       GUI_ALLOC_h2p
0001b8  4606              MOV      r6,r0
;;;351        pWin->hNext = 0;
0001ba  2000              MOVS     r0,#0
0001bc  8370              STRH     r0,[r6,#0x1a]
;;;352        pWin->hParent = hParent;
0001be  82f4              STRH     r4,[r6,#0x16]
;;;353        pParent = WM_H2P(hParent);
0001c0  4620              MOV      r0,r4
0001c2  f7fffffe          BL       GUI_ALLOC_h2p
0001c6  4605              MOV      r5,r0
;;;354        OnTop   = pWin->Status & WM_CF_STAYONTOP;
0001c8  8bb0              LDRH     r0,[r6,#0x1c]
0001ca  f0000808          AND      r8,r0,#8
;;;355        hi = pParent->hFirstChild;
0001ce  f9b59018          LDRSH    r9,[r5,#0x18]
;;;356        /* Put it at beginning of the list if there is no child */
;;;357        if (hi == 0) {   /* No child yet ... Makes things easy ! */
0001d2  f1b90f00          CMP      r9,#0
0001d6  d007              BEQ      |L1.488|
;;;358          pParent->hFirstChild = hWin;
;;;359          return;                         /* Early out ... We are done */
;;;360        }
;;;361        /* Put it at beginning of the list if first child is a TOP window and new one is not */
;;;362        pi = WM_H2P(hi);
0001d8  4648              MOV      r0,r9
0001da  f7fffffe          BL       GUI_ALLOC_h2p
0001de  4604              MOV      r4,r0
;;;363        if (!OnTop) {
0001e0  f1b80f00          CMP      r8,#0
0001e4  d003              BEQ      |L1.494|
0001e6  e00b              B        |L1.512|
                  |L1.488|
0001e8  832f              STRH     r7,[r5,#0x18]         ;358
                  |L1.490|
;;;364          if (pi->Status & WM_SF_STAYONTOP) {
;;;365            pWin->hNext = hi;
;;;366            pParent->hFirstChild = hWin;
;;;367            return;                         /* Early out ... We are done */
;;;368          }
;;;369        }
;;;370        /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
;;;371        do {
;;;372          WM_Obj* pNext;
;;;373          WM_HWIN hNext;
;;;374          if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
;;;375            pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
;;;376            break;
;;;377          }
;;;378          pNext = WM_H2P(hNext);
;;;379          if (!OnTop) {
;;;380            if (pNext->Status & WM_SF_STAYONTOP) {
;;;381              pi->hNext = hWin;
;;;382              pWin->hNext = hNext;
;;;383              break;
;;;384            }
;;;385          }
;;;386          pi = pNext;
;;;387        }  while (1);
;;;388        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;389          WM__NotifyVisChanged(hWin, &pWin->Rect);
;;;390        #endif
;;;391      }
;;;392    }
0001ea  e8bd87f0          POP      {r4-r10,pc}
                  |L1.494|
0001ee  8ba0              LDRH     r0,[r4,#0x1c]         ;364
0001f0  f0100f08          TST      r0,#8                 ;364
0001f4  d004              BEQ      |L1.512|
0001f6  f8a6901a          STRH     r9,[r6,#0x1a]         ;365
0001fa  832f              STRH     r7,[r5,#0x18]         ;366
0001fc  e8bd87f0          POP      {r4-r10,pc}
                  |L1.512|
000200  f9b4501a          LDRSH    r5,[r4,#0x1a]         ;374
000204  b135              CBZ      r5,|L1.532|
000206  4628              MOV      r0,r5                 ;378
000208  f7fffffe          BL       GUI_ALLOC_h2p
00020c  f1b80f00          CMP      r8,#0                 ;379
000210  d003              BEQ      |L1.538|
000212  e00a              B        |L1.554|
                  |L1.532|
000214  8367              STRH     r7,[r4,#0x1a]         ;375
000216  e8bd87f0          POP      {r4-r10,pc}
                  |L1.538|
00021a  8b81              LDRH     r1,[r0,#0x1c]         ;380
00021c  f0110f08          TST      r1,#8                 ;380
000220  d003              BEQ      |L1.554|
000222  8367              STRH     r7,[r4,#0x1a]         ;381
000224  8375              STRH     r5,[r6,#0x1a]         ;382
000226  e8bd87f0          POP      {r4-r10,pc}
                  |L1.554|
00022a  4604              MOV      r4,r0                 ;386
00022c  e7e8              B        |L1.512|
;;;393    
                          ENDP

                  WM__RemoveWindowFromList PROC
;;;397    */
;;;398    void WM__RemoveWindowFromList(WM_HWIN hWin) {
00022e  b570              PUSH     {r4-r6,lr}
000230  4604              MOV      r4,r0
;;;399      WM_HWIN hi, hParent;
;;;400      WM_Obj * pWin, * pParent, * pi;
;;;401      
;;;402      pWin = WM_H2P(hWin);
000232  4620              MOV      r0,r4
000234  f7fffffe          BL       GUI_ALLOC_h2p
000238  4605              MOV      r5,r0
;;;403      hParent = pWin->hParent;
00023a  f9b50016          LDRSH    r0,[r5,#0x16]
;;;404      if (hParent) {
00023e  2800              CMP      r0,#0
000240  d00a              BEQ      |L1.600|
;;;405        pParent = WM_H2P(hParent);
000242  f7fffffe          BL       GUI_ALLOC_h2p
000246  4606              MOV      r6,r0
;;;406        hi = pParent->hFirstChild;
000248  f9b60018          LDRSH    r0,[r6,#0x18]
;;;407        if (hi == hWin) {
00024c  42a0              CMP      r0,r4
00024e  d104              BNE      |L1.602|
;;;408          pi = WM_H2P(hi);
000250  f7fffffe          BL       GUI_ALLOC_h2p
;;;409          pParent->hFirstChild = pi->hNext;
000254  8b40              LDRH     r0,[r0,#0x1a]
000256  8330              STRH     r0,[r6,#0x18]
                  |L1.600|
;;;410        } else {
;;;411          while (hi) {
;;;412            pi = WM_H2P(hi);
;;;413            if (pi->hNext == hWin) {
;;;414              pi->hNext = pWin->hNext;
;;;415              break;
;;;416            }
;;;417            hi = pi->hNext;
;;;418          }
;;;419        }
;;;420      }
;;;421    }
000258  bd70              POP      {r4-r6,pc}
                  |L1.602|
00025a  2800              CMP      r0,#0                 ;411
00025c  d0fc              BEQ      |L1.600|
                  |L1.606|
00025e  f7fffffe          BL       GUI_ALLOC_h2p
000262  f9b0101a          LDRSH    r1,[r0,#0x1a]         ;413
000266  42a1              CMP      r1,r4                 ;413
000268  d102              BNE      |L1.624|
00026a  8b69              LDRH     r1,[r5,#0x1a]         ;414
00026c  8341              STRH     r1,[r0,#0x1a]         ;414
00026e  bd70              POP      {r4-r6,pc}
                  |L1.624|
000270  4608              MOV      r0,r1                 ;417
000272  2800              CMP      r0,#0                 ;411
000274  d1f3              BNE      |L1.606|
000276  bd70              POP      {r4-r6,pc}
;;;422    
                          ENDP

                  WM_InvalidateWindowAndDescsEx PROC
;;;490    */
;;;491    void WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect) {
000278  b530              PUSH     {r4,r5,lr}
00027a  b083              SUB      sp,sp,#0xc
00027c  4604              MOV      r4,r0
00027e  460d              MOV      r5,r1
;;;492      GUI_RECT Rect;
;;;493      WM_Obj*  pWin;
;;;494      WM_Obj* pChild;
;;;495      WM_HWIN hChild;
;;;496      int Status;
;;;497    
;;;498      if (hWin) {
000280  2c00              CMP      r4,#0
000282  d022              BEQ      |L1.714|
;;;499        pWin = WM_H2P(hWin);
000284  4620              MOV      r0,r4
000286  f7fffffe          BL       GUI_ALLOC_h2p
;;;500        Status  = pWin->Status;
00028a  8b83              LDRH     r3,[r0,#0x1c]
;;;501        if ((Status & WM_SF_ISVIS) == 0) {
00028c  f0130f02          TST      r3,#2
000290  d01b              BEQ      |L1.714|
;;;502          return;                                                            /* Window is not visible... we are done */
;;;503        }
;;;504        if (GUI__IntersectRects(&Rect, pInvalidRect, &pWin->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
000292  4602              MOV      r2,r0
000294  4629              MOV      r1,r5
000296  4668              MOV      r0,sp
000298  f7fffffe          BL       GUI__IntersectRects
00029c  2800              CMP      r0,#0
00029e  d014              BEQ      |L1.714|
;;;505          return;                                                            /* No intersection, nothing to do */
;;;506        }
;;;507        WM__Invalidate1Abs(hWin, &Rect);    /* Invalidate window itself */
0002a0  4669              MOV      r1,sp
0002a2  4620              MOV      r0,r4
0002a4  f7fffffe          BL       WM__Invalidate1Abs
;;;508        for (hChild = WM_GetFirstChild(hWin); hChild; hChild = pChild->hNext) {
0002a8  4620              MOV      r0,r4
0002aa  f7fffffe          BL       WM_GetFirstChild
0002ae  4604              MOV      r4,r0
0002b0  2c00              CMP      r4,#0
0002b2  d00a              BEQ      |L1.714|
                  |L1.692|
;;;509          WM_InvalidateWindowAndDescsEx(hChild, &Rect);
0002b4  4669              MOV      r1,sp
0002b6  4620              MOV      r0,r4
0002b8  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
;;;510          pChild = WM_H2P(hChild);
0002bc  4620              MOV      r0,r4
0002be  f7fffffe          BL       GUI_ALLOC_h2p
0002c2  f9b0401a          LDRSH    r4,[r0,#0x1a]         ;508
0002c6  2c00              CMP      r4,#0                 ;508
0002c8  d1f4              BNE      |L1.692|
                  |L1.714|
;;;511        }
;;;512      }
;;;513    }
0002ca  b003              ADD      sp,sp,#0xc
0002cc  bd30              POP      {r4,r5,pc}
;;;514    
                          ENDP

                  WM__InvalidateRectEx PROC
;;;534    */
;;;535    void WM__InvalidateRectEx(const GUI_RECT* pInvalidRect, WM_HWIN hParent, WM_HWIN hStop) {
0002ce  e92d41f0          PUSH     {r4-r8,lr}
0002d2  b082              SUB      sp,sp,#8
0002d4  4680              MOV      r8,r0
0002d6  460f              MOV      r7,r1
0002d8  4615              MOV      r5,r2
;;;536      GUI_RECT Rect;
;;;537      WM_Obj*  pParent;
;;;538      WM_Obj*  pi;
;;;539      WM_HWIN  hi;
;;;540      int Status;
;;;541    
;;;542      /* Perform some parameter checks and check for "early out" conditions. */
;;;543      if (hParent == 0) {
0002da  2f00              CMP      r7,#0
0002dc  d028              BEQ      |L1.816|
;;;544        return;                                                            /* Desktop window or unattached wind. Nothing to do. */
;;;545      }
;;;546      pParent = WM_H2P(hParent);
0002de  4638              MOV      r0,r7
0002e0  f7fffffe          BL       GUI_ALLOC_h2p
0002e4  4604              MOV      r4,r0
;;;547      Status  = pParent->Status;
0002e6  8ba6              LDRH     r6,[r4,#0x1c]
;;;548      if ((Status & WM_SF_ISVIS) == 0) {
0002e8  f0160f02          TST      r6,#2
0002ec  d020              BEQ      |L1.816|
;;;549        return;                                                            /* Window is not visible... we are done */
;;;550      }
;;;551      if (GUI__IntersectRects(&Rect, pInvalidRect, &pParent->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
0002ee  4622              MOV      r2,r4
0002f0  4641              MOV      r1,r8
0002f2  4668              MOV      r0,sp
0002f4  f7fffffe          BL       GUI__IntersectRects
0002f8  2800              CMP      r0,#0
0002fa  d019              BEQ      |L1.816|
;;;552        return;                                                            /* No intersection, nothing to do */
;;;553      }
;;;554      /* Invalidate the rectangle in the parent */
;;;555      /* If the parent is (partially) transparent, we need to move up in the hierarchy */
;;;556      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
0002fc  f6400001          MOV      r0,#0x801
000300  4030              ANDS     r0,r0,r6
000302  2801              CMP      r0,#1
000304  d017              BEQ      |L1.822|
;;;557        WM__InvalidateRectEx(&Rect, pParent->hParent, pParent->hNext);
;;;558      } else {
;;;559        WM__Invalidate1Abs(hParent, &Rect);
000306  4669              MOV      r1,sp
000308  4638              MOV      r0,r7
00030a  f7fffffe          BL       WM__Invalidate1Abs
                  |L1.782|
;;;560      }
;;;561      /* Invalidate siblings up to hStop */
;;;562      for (hi = pParent->hFirstChild; hi; hi = pi->hNext) {
00030e  f9b44018          LDRSH    r4,[r4,#0x18]
000312  2c00              CMP      r4,#0
000314  d00c              BEQ      |L1.816|
                  |L1.790|
;;;563        if (hi == hStop) {
000316  42ac              CMP      r4,r5
000318  d00a              BEQ      |L1.816|
;;;564          break;
;;;565        }
;;;566        WM_InvalidateWindowAndDescsEx(hi, &Rect);
00031a  4669              MOV      r1,sp
00031c  4620              MOV      r0,r4
00031e  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
;;;567        pi = WM_H2P(hi);
000322  4620              MOV      r0,r4
000324  f7fffffe          BL       GUI_ALLOC_h2p
000328  f9b0401a          LDRSH    r4,[r0,#0x1a]         ;562
00032c  2c00              CMP      r4,#0                 ;562
00032e  d1f2              BNE      |L1.790|
                  |L1.816|
;;;568      }
;;;569    }
000330  b002              ADD      sp,sp,#8
000332  e8bd81f0          POP      {r4-r8,pc}
                  |L1.822|
000336  f9b4201a          LDRSH    r2,[r4,#0x1a]         ;557
00033a  f9b41016          LDRSH    r1,[r4,#0x16]         ;557
00033e  4668              MOV      r0,sp                 ;557
000340  f7fffffe          BL       WM__InvalidateRectEx
000344  e7e3              B        |L1.782|
;;;570    
                          ENDP

                  WM__DetachWindow PROC
;;;430    */
;;;431    void WM__DetachWindow(WM_HWIN hWin) {
000346  b570              PUSH     {r4-r6,lr}
000348  4605              MOV      r5,r0
;;;432      WM_Obj* pWin;
;;;433      WM_HWIN hParent;
;;;434      pWin = WM_H2P(hWin);
00034a  4628              MOV      r0,r5
00034c  f7fffffe          BL       GUI_ALLOC_h2p
000350  4604              MOV      r4,r0
;;;435      hParent = pWin->hParent;
000352  f9b41016          LDRSH    r1,[r4,#0x16]
;;;436      if (hParent) {
000356  2900              CMP      r1,#0
000358  d009              BEQ      |L1.878|
;;;437        WM__InvalidateRectEx(&pWin->Rect, pWin->hParent, pWin->hNext);
00035a  f9b4201a          LDRSH    r2,[r4,#0x1a]
00035e  4620              MOV      r0,r4
000360  f7fffffe          BL       WM__InvalidateRectEx
;;;438        WM__RemoveWindowFromList(hWin);
000364  4628              MOV      r0,r5
000366  f7fffffe          BL       WM__RemoveWindowFromList
;;;439        pWin->hParent = 0;
00036a  2000              MOVS     r0,#0
00036c  82e0              STRH     r0,[r4,#0x16]
                  |L1.878|
;;;440      }
;;;441    }
00036e  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP

                  WM_SelectWindow PROC
;;;1001   */
;;;1002   WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
000370  b570              PUSH     {r4-r6,lr}
000372  4604              MOV      r4,r0
;;;1003     WM_HWIN hWinPrev;
;;;1004     WM_Obj* pObj;
;;;1005   
;;;1006     WM_ASSERT_NOT_IN_PAINT();
;;;1007     WM_LOCK();
000374  f7fffffe          BL       GUI_Lock
;;;1008     hWinPrev = GUI_Context.hAWin;
000378  4d1e              LDR      r5,|L1.1012|
00037a  f9b56040          LDRSH    r6,[r5,#0x40]  ; GUI_Context
;;;1009     if (hWin == 0) {
00037e  b914              CBNZ     r4,|L1.902|
;;;1010       hWin = WM__FirstWin;
000380  481a              LDR      r0,|L1.1004|
000382  f9b04008          LDRSH    r4,[r0,#8]  ; WM__FirstWin
                  |L1.902|
;;;1011     }
;;;1012     /* Select new window */
;;;1013     GUI_Context.hAWin = hWin;
000386  f8a54040          STRH     r4,[r5,#0x40]
;;;1014     #if GUI_NUM_LAYERS > 1
;;;1015     {
;;;1016       WM_HWIN hTop;
;;;1017       int LayerIndex;
;;;1018       hTop = _GetTopLevelWindow(hWin);
;;;1019       LayerIndex = _DesktopHandle2Index(hTop);
;;;1020       if (LayerIndex >= 0) {
;;;1021         GUI_SelectLayer(LayerIndex);
;;;1022       }
;;;1023     }
;;;1024     #endif
;;;1025     pObj = WM_H2P(hWin);
00038a  4620              MOV      r0,r4
00038c  f7fffffe          BL       GUI_ALLOC_h2p
000390  4604              MOV      r4,r0
;;;1026     LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
000392  f7fffffe          BL       LCD_SetClipRectMax
;;;1027     GUI_Context.xOff = pObj->Rect.x0;
000396  f9b40000          LDRSH    r0,[r4,#0]
00039a  6468              STR      r0,[r5,#0x44]  ; GUI_Context
;;;1028     GUI_Context.yOff = pObj->Rect.y0;
00039c  f9b40002          LDRSH    r0,[r4,#2]
0003a0  64a8              STR      r0,[r5,#0x48]  ; GUI_Context
;;;1029     WM_UNLOCK();
0003a2  f7fffffe          BL       GUI_Unlock
;;;1030     return hWinPrev;
0003a6  4630              MOV      r0,r6
;;;1031   }
0003a8  bd70              POP      {r4-r6,pc}
;;;1032   
                          ENDP

                  WM__RemoveFromLinList PROC
;;;574    */
;;;575    void WM__RemoveFromLinList(WM_HWIN hWin) {
0003aa  b570              PUSH     {r4-r6,lr}
0003ac  4604              MOV      r4,r0
;;;576      WM_Obj* piWin;
;;;577      WM_HWIN hiWin;
;;;578      WM_HWIN hNext;
;;;579      for (hiWin = WM__FirstWin; hiWin; ) {
0003ae  480f              LDR      r0,|L1.1004|
0003b0  f9b00008          LDRSH    r0,[r0,#8]  ; WM__FirstWin
0003b4  2800              CMP      r0,#0
0003b6  d00b              BEQ      |L1.976|
                  |L1.952|
;;;580        piWin = WM_H2P(hiWin);
0003b8  f7fffffe          BL       GUI_ALLOC_h2p
0003bc  4605              MOV      r5,r0
;;;581        hNext = piWin->hNextLin;
0003be  f9b50014          LDRSH    r0,[r5,#0x14]
;;;582        if (hNext == hWin) {
0003c2  42a0              CMP      r0,r4
0003c4  d105              BNE      |L1.978|
;;;583          piWin->hNextLin = WM_H2P(hWin)->hNextLin;
0003c6  4620              MOV      r0,r4
0003c8  f7fffffe          BL       GUI_ALLOC_h2p
0003cc  8a80              LDRH     r0,[r0,#0x14]
0003ce  82a8              STRH     r0,[r5,#0x14]
                  |L1.976|
;;;584          break;
;;;585        }
;;;586        hiWin = hNext;
;;;587      }
;;;588    }
0003d0  bd70              POP      {r4-r6,pc}
                  |L1.978|
0003d2  2800              CMP      r0,#0                 ;579
0003d4  d1f0              BNE      |L1.952|
0003d6  bd70              POP      {r4-r6,pc}
;;;589    
                          ENDP

                  WM__SendMsgNoData PROC
;;;753    */
;;;754    void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
0003d8  b500              PUSH     {lr}
0003da  b083              SUB      sp,sp,#0xc
;;;755      WM_MESSAGE Msg;
;;;756      Msg.hWin  = hWin;
0003dc  f8ad0004          STRH     r0,[sp,#4]
;;;757      Msg.MsgId = MsgId;
0003e0  9100              STR      r1,[sp,#0]
;;;758      WM__SendMessage(hWin, &Msg);
0003e2  4669              MOV      r1,sp
0003e4  f7fffffe          BL       WM__SendMessage
;;;759    }
0003e8  b003              ADD      sp,sp,#0xc
0003ea  bd00              POP      {pc}
                  |L1.1004|
                          DCD      ||.data||
                  |L1.1008|
                          DCD      ||.data||+0xa
                  |L1.1012|
                          DCD      GUI_Context
                  |L1.1016|
                          DCD      ||area_number.4||+0x8
                          ENDP

                  WM__IsWindow PROC
;;;470    */
;;;471    int WM__IsWindow(WM_HWIN hWin) {
0003fc  b510              PUSH     {r4,lr}
0003fe  4604              MOV      r4,r0
;;;472      WM_HWIN iWin;
;;;473      for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
000400  48ff              LDR      r0,|L1.2048|
000402  f9b00008          LDRSH    r0,[r0,#8]  ; WM__FirstWin
000406  b148              CBZ      r0,|L1.1052|
                  |L1.1032|
;;;474        if (iWin == hWin) {
000408  42a0              CMP      r0,r4
00040a  d101              BNE      |L1.1040|
;;;475          return 1;
00040c  2001              MOVS     r0,#1
;;;476        }
;;;477      }
;;;478      return 0;
;;;479    }
00040e  bd10              POP      {r4,pc}
                  |L1.1040|
000410  f7fffffe          BL       GUI_ALLOC_h2p
000414  f9b00014          LDRSH    r0,[r0,#0x14]         ;473
000418  2800              CMP      r0,#0                 ;473
00041a  d1f5              BNE      |L1.1032|
                  |L1.1052|
00041c  2000              MOVS     r0,#0                 ;478
00041e  bd10              POP      {r4,pc}
;;;480    
                          ENDP

                  WM_DeleteWindow PROC
;;;942    */
;;;943    void WM_DeleteWindow (WM_HWIN hWin) {
000420  b570              PUSH     {r4-r6,lr}
000422  4604              MOV      r4,r0
;;;944      WM_Obj* pWin;
;;;945      if (!hWin) {
000424  2c00              CMP      r4,#0
000426  d046              BEQ      |L1.1206|
;;;946        return;
;;;947      }
;;;948      WM_ASSERT_NOT_IN_PAINT();
;;;949      WM_LOCK();
000428  f7fffffe          BL       GUI_Lock
;;;950      if (WM__IsWindow(hWin)) {
00042c  4620              MOV      r0,r4
00042e  f7fffffe          BL       WM__IsWindow
000432  b3e0              CBZ      r0,|L1.1198|
;;;951        pWin = WM_H2P(hWin);
000434  4620              MOV      r0,r4
000436  f7fffffe          BL       GUI_ALLOC_h2p
00043a  4606              MOV      r6,r0
;;;952        ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
00043c  f7fffffe          BL       ResetNextDrawWin
;;;953      /* Make sure that focus is set to an existing window */
;;;954        if (WM__hWinFocus == hWin) {
000440  4def              LDR      r5,|L1.2048|
000442  2000              MOVS     r0,#0                 ;943
000444  f9b51010          LDRSH    r1,[r5,#0x10]  ; WM__hWinFocus
000448  42a1              CMP      r1,r4
00044a  d100              BNE      |L1.1102|
;;;955          WM__hWinFocus = 0;
00044c  8228              STRH     r0,[r5,#0x10]
                  |L1.1102|
;;;956        }
;;;957        if (WM__hCapture == hWin) {
00044e  f9b5100e          LDRSH    r1,[r5,#0xe]  ; WM__hCapture
000452  42a1              CMP      r1,r4
000454  d100              BNE      |L1.1112|
;;;958          WM__hCapture = 0;
000456  81e8              STRH     r0,[r5,#0xe]
                  |L1.1112|
;;;959        }
;;;960        /* check if critical handles are affected. If so, reset the window handle to 0 */
;;;961        _CheckCriticalHandles(hWin);
000458  4620              MOV      r0,r4
00045a  f7fffffe          BL       _CheckCriticalHandles
;;;962        /* Inform parent */
;;;963        WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
00045e  2107              MOVS     r1,#7
000460  4620              MOV      r0,r4
000462  f7fffffe          BL       WM_NotifyParent
;;;964        /* Delete all children */
;;;965        _DeleteAllChildren(pWin);
000466  4630              MOV      r0,r6
000468  f7fffffe          BL       _DeleteAllChildren
;;;966        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;967          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;968        #endif
;;;969        /* Send WM_DELETE message to window in order to inform window itself */
;;;970        WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
00046c  210b              MOVS     r1,#0xb
00046e  4620              MOV      r0,r4
000470  f7fffffe          BL       WM__SendMsgNoData
;;;971        WM__DetachWindow(hWin);
000474  4620              MOV      r0,r4
000476  f7fffffe          BL       WM__DetachWindow
;;;972        /* Remove window from window stack */
;;;973        WM__RemoveFromLinList(hWin);
00047a  4620              MOV      r0,r4
00047c  f7fffffe          BL       WM__RemoveFromLinList
;;;974        /* Handle transparency counter if necessary */
;;;975        #if WM_SUPPORT_TRANSPARENCY
;;;976          if (pWin->Status & WM_SF_HASTRANS) {
000480  8bb0              LDRH     r0,[r6,#0x1c]
000482  f0100f01          TST      r0,#1
000486  d002              BEQ      |L1.1166|
;;;977            WM__TransWindowCnt--;
000488  6a69              LDR      r1,[r5,#0x24]  ; WM__TransWindowCnt
00048a  1e49              SUBS     r1,r1,#1
00048c  6269              STR      r1,[r5,#0x24]  ; WM__TransWindowCnt
                  |L1.1166|
;;;978          }
;;;979        #endif
;;;980        /* Make sure window is no longer counted as invalid */
;;;981        if (pWin->Status & WM_SF_INVALID) {
00048e  f0100f20          TST      r0,#0x20
000492  d002              BEQ      |L1.1178|
;;;982          WM__NumInvalidWindows--;
000494  88e8              LDRH     r0,[r5,#6]  ; WM__NumInvalidWindows
000496  1e40              SUBS     r0,r0,#1
000498  80e8              STRH     r0,[r5,#6]
                  |L1.1178|
;;;983        }
;;;984      /* Free window memory */
;;;985        WM__NumWindows--;
00049a  88a8              LDRH     r0,[r5,#4]  ; WM__NumWindows
00049c  1e40              SUBS     r0,r0,#1
00049e  80a8              STRH     r0,[r5,#4]
;;;986        GUI_ALLOC_Free(hWin);
0004a0  4620              MOV      r0,r4
0004a2  f7fffffe          BL       GUI_ALLOC_Free
;;;987      /* Select a valid window */
;;;988        WM_SelectWindow(WM__FirstWin);
0004a6  f9b50008          LDRSH    r0,[r5,#8]  ; WM__FirstWin
0004aa  f7fffffe          BL       WM_SelectWindow
                  |L1.1198|
;;;989      } else {
;;;990        GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
;;;991      }
;;;992      WM_UNLOCK();
0004ae  e8bd4070          POP      {r4-r6,lr}
0004b2  f7ffbffe          B.W      GUI_Unlock
                  |L1.1206|
;;;993    }
0004b6  bd70              POP      {r4-r6,pc}
;;;994    
                          ENDP

                  _DeleteAllChildren PROC
;;;446    */
;;;447    static void _DeleteAllChildren(WM_Obj * pParent) {
0004b8  b510              PUSH     {r4,lr}
0004ba  4604              MOV      r4,r0
                  |L1.1212|
;;;448      do {
;;;449        WM_DeleteWindow(pParent->hFirstChild);
0004bc  f9b40018          LDRSH    r0,[r4,#0x18]
0004c0  f7fffffe          BL       WM_DeleteWindow
;;;450      } while (pParent->hFirstChild);
0004c4  8b20              LDRH     r0,[r4,#0x18]
0004c6  2800              CMP      r0,#0
0004c8  d1f8              BNE      |L1.1212|
;;;451    }
0004ca  bd10              POP      {r4,pc}
;;;452    
                          ENDP

                  _AddToLinList PROC
;;;593    */
;;;594    static void _AddToLinList(WM_HWIN hNew) {
0004cc  b570              PUSH     {r4-r6,lr}
0004ce  4604              MOV      r4,r0
;;;595      WM_Obj* pFirst;
;;;596      WM_Obj* pNew;
;;;597      if (WM__FirstWin) {
0004d0  49cb              LDR      r1,|L1.2048|
0004d2  f9b10008          LDRSH    r0,[r1,#8]  ; WM__FirstWin
0004d6  b150              CBZ      r0,|L1.1262|
;;;598        pFirst = WM_H2P(WM__FirstWin);
0004d8  f7fffffe          BL       GUI_ALLOC_h2p
0004dc  4605              MOV      r5,r0
;;;599        pNew   = WM_H2P(hNew);
0004de  4620              MOV      r0,r4
0004e0  f7fffffe          BL       GUI_ALLOC_h2p
0004e4  4601              MOV      r1,r0
;;;600        pNew->hNextLin = pFirst->hNextLin;
0004e6  8aa8              LDRH     r0,[r5,#0x14]
0004e8  8288              STRH     r0,[r1,#0x14]
;;;601        pFirst->hNextLin = hNew;
0004ea  82ac              STRH     r4,[r5,#0x14]
;;;602      } else {
;;;603        WM__FirstWin = hNew;
;;;604      }
;;;605    }
0004ec  bd70              POP      {r4-r6,pc}
                  |L1.1262|
0004ee  810c              STRH     r4,[r1,#8]            ;603
0004f0  bd70              POP      {r4-r6,pc}
;;;606    
                          ENDP

                  _Findy1 PROC
;;;626    */
;;;627    static void _Findy1(WM_HWIN iWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
0004f2  e92d41f0          PUSH     {r4-r8,lr}
0004f6  b082              SUB      sp,sp,#8
0004f8  460d              MOV      r5,r1
0004fa  4690              MOV      r8,r2
;;;628      WM_Obj* pWin;
;;;629      for (; iWin; iWin = pWin->hNext) { 
0004fc  2800              CMP      r0,#0
0004fe  d02f              BEQ      |L1.1376|
                  |L1.1280|
;;;630        int Status = (pWin = WM_H2P(iWin))->Status;
000500  f7fffffe          BL       GUI_ALLOC_h2p
000504  8b84              LDRH     r4,[r0,#0x1c]
000506  4606              MOV      r6,r0
;;;631        /* Check if this window affects us at all */    
;;;632        if (Status & WM_SF_ISVIS) {
000508  f0140f02          TST      r4,#2
00050c  d024              BEQ      |L1.1368|
;;;633          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;634          if (pParentRect) {
00050e  f1b80f00          CMP      r8,#0
000512  d005              BEQ      |L1.1312|
;;;635            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000514  4642              MOV      r2,r8
000516  4631              MOV      r1,r6
000518  4668              MOV      r0,sp
00051a  f7fffffe          BL       GUI__IntersectRects
00051e  e003              B        |L1.1320|
                  |L1.1312|
;;;636          } else {
;;;637            rWinClipped = pWin->Rect;
000520  6871              LDR      r1,[r6,#4]
000522  6830              LDR      r0,[r6,#0]
000524  9101              STR      r1,[sp,#4]
000526  9000              STR      r0,[sp,#0]
                  |L1.1320|
;;;638          }
;;;639          /* Check if this window affects us at all */    
;;;640          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000528  4669              MOV      r1,sp
00052a  4628              MOV      r0,r5
00052c  f7fffffe          BL       GUI_RectsIntersect
000530  b190              CBZ      r0,|L1.1368|
;;;641            if ((Status & WM_SF_HASTRANS) == 0) {
000532  f0140f01          TST      r4,#1
000536  d016              BEQ      |L1.1382|
;;;642              if (pWin->Rect.y0 > pRect->y0) {
;;;643                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
;;;644              } else {
;;;645                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
;;;646              }
;;;647            } else {
;;;648              /* Check all children*/ 
;;;649              WM_HWIN hChild;
;;;650              WM_Obj* pChild;
;;;651              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000538  f9b64018          LDRSH    r4,[r6,#0x18]
00053c  b164              CBZ      r4,|L1.1368|
                  |L1.1342|
;;;652                pChild = WM_H2P(hChild);
00053e  4620              MOV      r0,r4
000540  f7fffffe          BL       GUI_ALLOC_h2p
000544  4607              MOV      r7,r0
;;;653                _Findy1(hChild, pRect, &rWinClipped);
000546  466a              MOV      r2,sp
000548  4629              MOV      r1,r5
00054a  4620              MOV      r0,r4
00054c  f7fffffe          BL       _Findy1
000550  f9b7401a          LDRSH    r4,[r7,#0x1a]         ;651
000554  2c00              CMP      r4,#0                 ;651
000556  d1f2              BNE      |L1.1342|
                  |L1.1368|
000558  f9b6001a          LDRSH    r0,[r6,#0x1a]         ;629
00055c  2800              CMP      r0,#0                 ;629
00055e  d1cf              BNE      |L1.1280|
                  |L1.1376|
;;;654              }
;;;655            }
;;;656          }
;;;657        }
;;;658      }
;;;659    }
000560  b002              ADD      sp,sp,#8
000562  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1382|
000566  f9b60002          LDRSH    r0,[r6,#2]            ;642
00056a  f9b51002          LDRSH    r1,[r5,#2]            ;642
00056e  4288              CMP      r0,r1                 ;642
000570  dd08              BLE      |L1.1412|
000572  f9bd0002          LDRSH    r0,[sp,#2]            ;643
000576  f9b51006          LDRSH    r1,[r5,#6]            ;643
00057a  1e40              SUBS     r0,r0,#1              ;643
00057c  4288              CMP      r0,r1                 ;643
00057e  daeb              BGE      |L1.1368|
000580  80e8              STRH     r0,[r5,#6]            ;643
000582  e7e9              B        |L1.1368|
                  |L1.1412|
000584  f9bd0006          LDRSH    r0,[sp,#6]            ;645
000588  f9b51006          LDRSH    r1,[r5,#6]            ;645
00058c  4288              CMP      r0,r1                 ;645
00058e  dae3              BGE      |L1.1368|
000590  80e8              STRH     r0,[r5,#6]            ;645
000592  e7e1              B        |L1.1368|
;;;660    
                          ENDP

                  _Findx0 PROC
;;;664    */
;;;665    static int _Findx0(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000594  e92d43f0          PUSH     {r4-r9,lr}
000598  b083              SUB      sp,sp,#0xc
00059a  4688              MOV      r8,r1
00059c  4691              MOV      r9,r2
;;;666      WM_Obj* pWin;
;;;667      int r = 0;
00059e  2600              MOVS     r6,#0
;;;668      for (; hWin; hWin = pWin->hNext) { 
0005a0  b388              CBZ      r0,|L1.1542|
                  |L1.1442|
;;;669        int Status = (pWin = WM_H2P(hWin))->Status;
0005a2  f7fffffe          BL       GUI_ALLOC_h2p
0005a6  8b84              LDRH     r4,[r0,#0x1c]
0005a8  4607              MOV      r7,r0
;;;670        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
0005aa  f0140f02          TST      r4,#2
0005ae  d026              BEQ      |L1.1534|
;;;671          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;672          if (pParentRect) {
0005b0  f1b90f00          CMP      r9,#0
0005b4  d005              BEQ      |L1.1474|
;;;673            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
0005b6  464a              MOV      r2,r9
0005b8  4639              MOV      r1,r7
0005ba  4668              MOV      r0,sp
0005bc  f7fffffe          BL       GUI__IntersectRects
0005c0  e003              B        |L1.1482|
                  |L1.1474|
;;;674          } else {
;;;675            rWinClipped = pWin->Rect;
0005c2  6879              LDR      r1,[r7,#4]
0005c4  6838              LDR      r0,[r7,#0]
0005c6  9101              STR      r1,[sp,#4]
0005c8  9000              STR      r0,[sp,#0]
                  |L1.1482|
;;;676          }
;;;677          /* Check if this window affects us at all */    
;;;678          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
0005ca  4669              MOV      r1,sp
0005cc  4640              MOV      r0,r8
0005ce  f7fffffe          BL       GUI_RectsIntersect
0005d2  b1a0              CBZ      r0,|L1.1534|
;;;679            if ((Status & WM_SF_HASTRANS) == 0) {
0005d4  f0140f01          TST      r4,#1
0005d8  d019              BEQ      |L1.1550|
;;;680              pRect->x0 = rWinClipped.x1+1;
;;;681              r = 1;
;;;682            } else {
;;;683              /* Check all children */
;;;684              WM_HWIN hChild;
;;;685              WM_Obj* pChild;
;;;686              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
0005da  f9b74018          LDRSH    r4,[r7,#0x18]
0005de  b174              CBZ      r4,|L1.1534|
                  |L1.1504|
;;;687                pChild = WM_H2P(hChild);
0005e0  4620              MOV      r0,r4
0005e2  f7fffffe          BL       GUI_ALLOC_h2p
0005e6  4605              MOV      r5,r0
;;;688                if (_Findx0(hChild, pRect, &rWinClipped)) {
0005e8  466a              MOV      r2,sp
0005ea  4641              MOV      r1,r8
0005ec  4620              MOV      r0,r4
0005ee  f7fffffe          BL       _Findx0
0005f2  b100              CBZ      r0,|L1.1526|
;;;689                  r = 1;
0005f4  2601              MOVS     r6,#1
                  |L1.1526|
0005f6  f9b5401a          LDRSH    r4,[r5,#0x1a]         ;686
0005fa  2c00              CMP      r4,#0                 ;686
0005fc  d1f0              BNE      |L1.1504|
                  |L1.1534|
0005fe  f9b7001a          LDRSH    r0,[r7,#0x1a]         ;668
000602  2800              CMP      r0,#0                 ;668
000604  d1cd              BNE      |L1.1442|
                  |L1.1542|
;;;690                }
;;;691              }
;;;692            }
;;;693          }
;;;694        }
;;;695      }
;;;696      return r;
;;;697    }
000606  b003              ADD      sp,sp,#0xc
000608  4630              MOV      r0,r6                 ;696
00060a  e8bd83f0          POP      {r4-r9,pc}
                  |L1.1550|
00060e  f8bd0004          LDRH     r0,[sp,#4]            ;680
000612  1c40              ADDS     r0,r0,#1              ;680
000614  f8a80000          STRH     r0,[r8,#0]            ;680
000618  2601              MOVS     r6,#1                 ;681
00061a  e7f0              B        |L1.1534|
;;;698    
                          ENDP

                  _Findx1 PROC
;;;702    */
;;;703    static void _Findx1(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
00061c  e92d41f0          PUSH     {r4-r8,lr}
000620  b082              SUB      sp,sp,#8
000622  460f              MOV      r7,r1
000624  4690              MOV      r8,r2
;;;704      WM_Obj* pWin;
;;;705      for (; hWin; hWin = pWin->hNext) { 
000626  2800              CMP      r0,#0
000628  d02f              BEQ      |L1.1674|
                  |L1.1578|
;;;706        int Status = (pWin = WM_H2P(hWin))->Status;
00062a  f7fffffe          BL       GUI_ALLOC_h2p
00062e  8b84              LDRH     r4,[r0,#0x1c]
000630  4606              MOV      r6,r0
;;;707        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
000632  f0140f02          TST      r4,#2
000636  d024              BEQ      |L1.1666|
;;;708          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;709          if (pParentRect) {
000638  f1b80f00          CMP      r8,#0
00063c  d005              BEQ      |L1.1610|
;;;710            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
00063e  4642              MOV      r2,r8
000640  4631              MOV      r1,r6
000642  4668              MOV      r0,sp
000644  f7fffffe          BL       GUI__IntersectRects
000648  e003              B        |L1.1618|
                  |L1.1610|
;;;711          } else {
;;;712            rWinClipped = pWin->Rect;
00064a  6871              LDR      r1,[r6,#4]
00064c  6830              LDR      r0,[r6,#0]
00064e  9101              STR      r1,[sp,#4]
000650  9000              STR      r0,[sp,#0]
                  |L1.1618|
;;;713          }
;;;714          /* Check if this window affects us at all */    
;;;715          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000652  4669              MOV      r1,sp
000654  4638              MOV      r0,r7
000656  f7fffffe          BL       GUI_RectsIntersect
00065a  b190              CBZ      r0,|L1.1666|
;;;716            if ((Status & WM_SF_HASTRANS) == 0) {
00065c  f0140f01          TST      r4,#1
000660  d016              BEQ      |L1.1680|
;;;717              pRect->x1 = rWinClipped.x0-1;
;;;718            } else {
;;;719              /* Check all children */
;;;720              WM_HWIN hChild;
;;;721              WM_Obj* pChild;
;;;722              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000662  f9b64018          LDRSH    r4,[r6,#0x18]
000666  b164              CBZ      r4,|L1.1666|
                  |L1.1640|
;;;723                pChild = WM_H2P(hChild);
000668  4620              MOV      r0,r4
00066a  f7fffffe          BL       GUI_ALLOC_h2p
00066e  4605              MOV      r5,r0
;;;724                _Findx1(hChild, pRect, &rWinClipped);
000670  466a              MOV      r2,sp
000672  4639              MOV      r1,r7
000674  4620              MOV      r0,r4
000676  f7fffffe          BL       _Findx1
00067a  f9b5401a          LDRSH    r4,[r5,#0x1a]         ;722
00067e  2c00              CMP      r4,#0                 ;722
000680  d1f2              BNE      |L1.1640|
                  |L1.1666|
000682  f9b6001a          LDRSH    r0,[r6,#0x1a]         ;705
000686  2800              CMP      r0,#0                 ;705
000688  d1cf              BNE      |L1.1578|
                  |L1.1674|
;;;725              }
;;;726            }
;;;727          }
;;;728        }
;;;729      }
;;;730    }
00068a  b002              ADD      sp,sp,#8
00068c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1680|
000690  f8bd0000          LDRH     r0,[sp,#0]            ;717
000694  1e40              SUBS     r0,r0,#1              ;717
000696  80b8              STRH     r0,[r7,#4]            ;717
000698  e7f3              B        |L1.1666|
;;;731    
                          ENDP

                  WM_SendMessage PROC
;;;741    */
;;;742    void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00069a  b570              PUSH     {r4-r6,lr}
00069c  4604              MOV      r4,r0
00069e  460d              MOV      r5,r1
;;;743      if (hWin) {
0006a0  2c00              CMP      r4,#0
0006a2  d009              BEQ      |L1.1720|
;;;744        WM_LOCK();
0006a4  f7fffffe          BL       GUI_Lock
;;;745        WM__SendMessage(hWin, pMsg);
0006a8  4629              MOV      r1,r5
0006aa  4620              MOV      r0,r4
0006ac  f7fffffe          BL       WM__SendMessage
;;;746        WM_UNLOCK();
0006b0  e8bd4070          POP      {r4-r6,lr}
0006b4  f7ffbffe          B.W      GUI_Unlock
                  |L1.1720|
;;;747      }  
;;;748    }
0006b8  bd70              POP      {r4-r6,pc}
;;;749    
                          ENDP

                  WM__GetClientRectWin PROC
;;;767    */
;;;768    void WM__GetClientRectWin(const WM_Obj* pWin, GUI_RECT* pRect) {
0006ba  2200              MOVS     r2,#0
;;;769      pRect->x0 = pRect->y0 = 0;
0006bc  804a              STRH     r2,[r1,#2]
0006be  800a              STRH     r2,[r1,#0]
;;;770      pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
0006c0  8882              LDRH     r2,[r0,#4]
0006c2  8803              LDRH     r3,[r0,#0]
0006c4  1ad2              SUBS     r2,r2,r3
0006c6  808a              STRH     r2,[r1,#4]
;;;771      pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
0006c8  88c2              LDRH     r2,[r0,#6]
0006ca  8840              LDRH     r0,[r0,#2]
0006cc  1a10              SUBS     r0,r2,r0
0006ce  80c8              STRH     r0,[r1,#6]
;;;772    }
0006d0  4770              BX       lr
;;;773    
                          ENDP

                  WM__GetInvalidRectAbs PROC
;;;777    */
;;;778    static void WM__GetInvalidRectAbs(WM_Obj* pWin, GUI_RECT* pRect) {
0006d2  6882              LDR      r2,[r0,#8]
;;;779      *pRect = pWin->InvalidRect;
0006d4  600a              STR      r2,[r1,#0]
0006d6  68c0              LDR      r0,[r0,#0xc]
0006d8  6048              STR      r0,[r1,#4]
;;;780    }
0006da  4770              BX       lr
;;;781    
                          ENDP

                  WM_InvalidateRect PROC
;;;795    */
;;;796    void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT*pRect) {
0006dc  b5f0              PUSH     {r4-r7,lr}
0006de  b085              SUB      sp,sp,#0x14
0006e0  4607              MOV      r7,r0
0006e2  460e              MOV      r6,r1
;;;797      GUI_RECT r;
;;;798      WM_Obj* pWin;
;;;799      int Status;
;;;800      if (hWin) {
0006e4  2f00              CMP      r7,#0
0006e6  d02a              BEQ      |L1.1854|
;;;801        WM_LOCK();
0006e8  f7fffffe          BL       GUI_Lock
;;;802        pWin = WM_H2P(hWin);
0006ec  4638              MOV      r0,r7
0006ee  f7fffffe          BL       GUI_ALLOC_h2p
0006f2  4604              MOV      r4,r0
;;;803        Status = pWin->Status;
0006f4  8ba5              LDRH     r5,[r4,#0x1c]
;;;804        if (Status & WM_SF_ISVIS) {
0006f6  f0150f02          TST      r5,#2
0006fa  d01e              BEQ      |L1.1850|
;;;805          r = pWin->Rect;
0006fc  6861              LDR      r1,[r4,#4]
0006fe  6820              LDR      r0,[r4,#0]
000700  9103              STR      r1,[sp,#0xc]
000702  9002              STR      r0,[sp,#8]
;;;806          if (pRect) {
000704  b15e              CBZ      r6,|L1.1822|
;;;807            GUI_RECT rPara;
;;;808            rPara = *pRect;
000706  6830              LDR      r0,[r6,#0]
000708  9000              STR      r0,[sp,#0]
00070a  6870              LDR      r0,[r6,#4]
00070c  9001              STR      r0,[sp,#4]
;;;809            WM__Client2Screen(pWin, &rPara);
00070e  4669              MOV      r1,sp
000710  4620              MOV      r0,r4
000712  f7fffffe          BL       WM__Client2Screen
;;;810            GUI__IntersectRect(&r, &rPara);
000716  4669              MOV      r1,sp
000718  a802              ADD      r0,sp,#8
00071a  f7fffffe          BL       GUI__IntersectRect
                  |L1.1822|
;;;811          }
;;;812          if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
00071e  4639              MOV      r1,r7
000720  a802              ADD      r0,sp,#8
000722  f7fffffe          BL       WM__ClipAtParentBorders
000726  b140              CBZ      r0,|L1.1850|
;;;813            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
000728  f6400001          MOV      r0,#0x801
00072c  4028              ANDS     r0,r0,r5
00072e  2801              CMP      r0,#1
000730  d007              BEQ      |L1.1858|
;;;814              WM__InvalidateRectEx(&r, pWin->hParent, pWin->hNext);
;;;815            } else {
;;;816              WM__Invalidate1Abs(hWin, &r);
000732  a902              ADD      r1,sp,#8
000734  4638              MOV      r0,r7
000736  f7fffffe          BL       WM__Invalidate1Abs
                  |L1.1850|
;;;817            }
;;;818          }
;;;819        }
;;;820        WM_UNLOCK();
00073a  f7fffffe          BL       GUI_Unlock
                  |L1.1854|
;;;821      }
;;;822    }
00073e  b005              ADD      sp,sp,#0x14
000740  bdf0              POP      {r4-r7,pc}
                  |L1.1858|
000742  f9b4201a          LDRSH    r2,[r4,#0x1a]         ;814
000746  f9b41016          LDRSH    r1,[r4,#0x16]         ;814
00074a  a802              ADD      r0,sp,#8              ;814
00074c  f7fffffe          BL       WM__InvalidateRectEx
000750  e7f3              B        |L1.1850|
;;;823    
                          ENDP

                  WM_InvalidateWindow PROC
;;;829    */
;;;830    void WM_InvalidateWindow(WM_HWIN hWin) {
000752  2100              MOVS     r1,#0
;;;831      WM_InvalidateRect(hWin, NULL);
000754  e7fe              B        WM_InvalidateRect
;;;832    }
;;;833    
                          ENDP

                  WM_CreateWindowAsChild PROC
;;;843    */
;;;844    WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
000756  e92d4ff8          PUSH     {r3-r11,lr}
;;;845                                   ,WM_HWIN hParent, U16 Style, WM_CALLBACK* cb
;;;846                                   ,int NumExtraBytes) {
00075a  4607              MOV      r7,r0
00075c  4688              MOV      r8,r1
00075e  4691              MOV      r9,r2
000760  469a              MOV      r10,r3
000762  f8ddb030          LDR      r11,[sp,#0x30]
000766  9e0b              LDR      r6,[sp,#0x2c]
000768  9d0a              LDR      r5,[sp,#0x28]
00076a  9c0d              LDR      r4,[sp,#0x34]
;;;847      WM_Obj* pWin;
;;;848      WM_HWIN hWin;
;;;849      WM_ASSERT_NOT_IN_PAINT();
;;;850      WM_LOCK();
00076c  f7fffffe          BL       GUI_Lock
;;;851      Style |= WM__CreateFlags;
000770  4823              LDR      r0,|L1.2048|
000772  8980              LDRH     r0,[r0,#0xc]  ; WM__CreateFlags
000774  4306              ORRS     r6,r6,r0
;;;852      /* Default parent is Desktop 0 */
;;;853      if (!hParent) {
000776  b92d              CBNZ     r5,|L1.1924|
;;;854        if (WM__NumWindows) {
000778  4821              LDR      r0,|L1.2048|
00077a  8880              LDRH     r0,[r0,#4]  ; WM__NumWindows
00077c  b110              CBZ      r0,|L1.1924|
;;;855        #if GUI_NUM_LAYERS == 1
;;;856          hParent = WM__ahDesktopWin[0];
00077e  4821              LDR      r0,|L1.2052|
000780  f9b05000          LDRSH    r5,[r0,#0]  ; WM__ahDesktopWin
                  |L1.1924|
;;;857        #else
;;;858          hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
;;;859        #endif
;;;860        }
;;;861      }
;;;862      if (hParent == WM_UNATTACHED) {
000784  1c68              ADDS     r0,r5,#1
000786  d100              BNE      |L1.1930|
;;;863        hParent = WM_HWIN_NULL;
000788  2500              MOVS     r5,#0
                  |L1.1930|
;;;864      }  
;;;865      if (hParent) {
00078a  b1c5              CBZ      r5,|L1.1982|
;;;866        WM_Obj* pParent = WM_H2P(hParent);
00078c  4628              MOV      r0,r5
00078e  f7fffffe          BL       GUI_ALLOC_h2p
;;;867        x0 += pParent->Rect.x0;
000792  f9b02000          LDRSH    r2,[r0,#0]
000796  4417              ADD      r7,r7,r2
;;;868        y0 += pParent->Rect.y0;
000798  f9b01002          LDRSH    r1,[r0,#2]
00079c  4488              ADD      r8,r8,r1
;;;869        if (width==0) {
00079e  f1b90f00          CMP      r9,#0
0007a2  d104              BNE      |L1.1966|
;;;870          width = pParent->Rect.x1 - pParent->Rect.x0+1;
0007a4  f9b03004          LDRSH    r3,[r0,#4]
0007a8  1a9a              SUBS     r2,r3,r2
0007aa  f1020901          ADD      r9,r2,#1
                  |L1.1966|
;;;871        }
;;;872        if (height==0) {
0007ae  f1ba0f00          CMP      r10,#0
0007b2  d104              BNE      |L1.1982|
;;;873          height = pParent->Rect.y1 - pParent->Rect.y0+1;
0007b4  f9b00006          LDRSH    r0,[r0,#6]
0007b8  1a40              SUBS     r0,r0,r1
0007ba  f1000a01          ADD      r10,r0,#1
                  |L1.1982|
;;;874        }
;;;875      }
;;;876      if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
0007be  f1040020          ADD      r0,r4,#0x20
0007c2  b200              SXTH     r0,r0
0007c4  f7fffffe          BL       GUI_ALLOC_AllocZero
0007c8  9000              STR      r0,[sp,#0]
0007ca  b3f0              CBZ      r0,|L1.2122|
;;;877        GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
;;;878      } else {
;;;879        WM__NumWindows++;
0007cc  480c              LDR      r0,|L1.2048|
0007ce  8881              LDRH     r1,[r0,#4]  ; WM__NumWindows
0007d0  1c49              ADDS     r1,r1,#1
0007d2  8081              STRH     r1,[r0,#4]
;;;880        pWin = WM_H2P(hWin);
0007d4  9800              LDR      r0,[sp,#0]
0007d6  f7fffffe          BL       GUI_ALLOC_h2p
0007da  4604              MOV      r4,r0
;;;881        pWin->Rect.x0 = x0;
0007dc  8027              STRH     r7,[r4,#0]
;;;882        pWin->Rect.y0 = y0;
0007de  f8a48002          STRH     r8,[r4,#2]
;;;883        pWin->Rect.x1 = x0 + width - 1;
0007e2  eb070009          ADD      r0,r7,r9
0007e6  1e40              SUBS     r0,r0,#1
0007e8  80a0              STRH     r0,[r4,#4]
;;;884        pWin->Rect.y1 = y0 + height - 1;
0007ea  eb08000a          ADD      r0,r8,r10
0007ee  1e40              SUBS     r0,r0,#1
0007f0  80e0              STRH     r0,[r4,#6]
;;;885        pWin->cb = cb;
0007f2  f8c4b010          STR      r11,[r4,#0x10]
;;;886        /* Copy the flags which can simply be accepted */
;;;887        pWin->Status |= (Style & (WM_CF_SHOW |
0007f6  8ba0              LDRH     r0,[r4,#0x1c]
0007f8  f0260160          BIC      r1,r6,#0x60
0007fc  e004              B        |L1.2056|
0007fe  0000              DCW      0x0000
                  |L1.2048|
                          DCD      ||.data||
                  |L1.2052|
                          DCD      ||.data||+0xa
                  |L1.2056|
000808  f4214140          BIC      r1,r1,#0xc000
00080c  4308              ORRS     r0,r0,r1
00080e  83a0              STRH     r0,[r4,#0x1c]
;;;888                                  WM_SF_MEMDEV |
;;;889                                  WM_CF_MEMDEV_ON_REDRAW |
;;;890                                  WM_SF_STAYONTOP |
;;;891                                  WM_CF_DISABLED |
;;;892                                  WM_SF_CONST_OUTLINE |
;;;893                                  WM_SF_HASTRANS |
;;;894                                  WM_CF_ANCHOR_RIGHT |
;;;895                                  WM_CF_ANCHOR_BOTTOM |
;;;896                                  WM_CF_ANCHOR_LEFT |
;;;897                                  WM_CF_ANCHOR_TOP |
;;;898                                  WM_CF_LATE_CLIP));
;;;899        /* Add to linked lists */
;;;900        _AddToLinList(hWin);
000810  9800              LDR      r0,[sp,#0]
000812  f7fffffe          BL       _AddToLinList
;;;901        WM__InsertWindowIntoList(hWin, hParent);
000816  4629              MOV      r1,r5
000818  9800              LDR      r0,[sp,#0]
00081a  f7fffffe          BL       WM__InsertWindowIntoList
;;;902        /* Activate window if WM_CF_ACTIVATE is specified */
;;;903        if (Style & WM_CF_ACTIVATE) {
00081e  f0160f20          TST      r6,#0x20
000822  d002              BEQ      |L1.2090|
;;;904          WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
000824  9800              LDR      r0,[sp,#0]
000826  f7fffffe          BL       WM_SelectWindow
                  |L1.2090|
;;;905        }
;;;906        /* Handle the Style flags, one at a time */
;;;907        #if WM_SUPPORT_TRANSPARENCY
;;;908          if (Style & WM_SF_HASTRANS) {
00082a  f0160f01          TST      r6,#1
00082e  d003              BEQ      |L1.2104|
;;;909            WM__TransWindowCnt++;          /* Increment counter for transparency windows */
000830  48ff              LDR      r0,|L1.3120|
000832  6a41              LDR      r1,[r0,#0x24]  ; WM__TransWindowCnt
000834  1c49              ADDS     r1,r1,#1
000836  6241              STR      r1,[r0,#0x24]  ; WM__TransWindowCnt
                  |L1.2104|
;;;910          }
;;;911        #endif
;;;912        if (Style & WM_CF_BGND) {
000838  f0160f40          TST      r6,#0x40
00083c  d002              BEQ      |L1.2116|
;;;913          WM_BringToBottom(hWin);
00083e  9800              LDR      r0,[sp,#0]
000840  f7fffffe          BL       WM_BringToBottom
                  |L1.2116|
;;;914        }
;;;915        if (Style & WM_CF_SHOW) {
000844  f0160f02          TST      r6,#2
000848  e000              B        |L1.2124|
                  |L1.2122|
00084a  e00b              B        |L1.2148|
                  |L1.2124|
00084c  d006              BEQ      |L1.2140|
;;;916          pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
00084e  8ba0              LDRH     r0,[r4,#0x1c]
000850  f0400002          ORR      r0,r0,#2
000854  83a0              STRH     r0,[r4,#0x1c]
;;;917          WM_InvalidateWindow(hWin);    /* Mark content as invalid */
000856  9800              LDR      r0,[sp,#0]
000858  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2140|
;;;918        }
;;;919        WM__SendMsgNoData(hWin, WM_CREATE);
00085c  2101              MOVS     r1,#1
00085e  9800              LDR      r0,[sp,#0]
000860  f7fffffe          BL       WM__SendMsgNoData
                  |L1.2148|
;;;920      }
;;;921      WM_UNLOCK();
000864  f7fffffe          BL       GUI_Unlock
;;;922      return hWin;
000868  9800              LDR      r0,[sp,#0]
;;;923    }
00086a  e8bd8ff8          POP      {r3-r11,pc}
;;;924    
                          ENDP

                  WM_CreateWindow PROC
;;;928    */
;;;929    WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U16 Style, WM_CALLBACK* cb, int NumExtraBytes) {
00086e  b570              PUSH     {r4-r6,lr}
000870  b084              SUB      sp,sp,#0x10
000872  460c              MOV      r4,r1
000874  4615              MOV      r5,r2
000876  461e              MOV      r6,r3
000878  9b0a              LDR      r3,[sp,#0x28]
00087a  9a09              LDR      r2,[sp,#0x24]
00087c  9908              LDR      r1,[sp,#0x20]
00087e  4684              MOV      r12,r0
;;;930      return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
000880  2000              MOVS     r0,#0
000882  e88d000f          STM      sp,{r0-r3}
000886  4633              MOV      r3,r6
000888  462a              MOV      r2,r5
00088a  4621              MOV      r1,r4
00088c  4660              MOV      r0,r12
00088e  f7fffffe          BL       WM_CreateWindowAsChild
;;;931    }
000892  b004              ADD      sp,sp,#0x10
000894  bd70              POP      {r4-r6,pc}
;;;932    
                          ENDP

                  WM_GetActiveWindow PROC
;;;1036   */
;;;1037   WM_HWIN WM_GetActiveWindow(void) {
000896  48e7              LDR      r0,|L1.3124|
;;;1038     return GUI_Context.hAWin;
000898  f9b00040          LDRSH    r0,[r0,#0x40]  ; GUI_Context
;;;1039   }
00089c  4770              BX       lr
;;;1040   
                          ENDP

                  _FindNext_IVR PROC
;;;1071   #if WM_SUPPORT_OBSTRUCT
;;;1072   static int _FindNext_IVR(void) {
00089e  b5f0              PUSH     {r4-r7,lr}
0008a0  b083              SUB      sp,sp,#0xc
;;;1073     WM_HMEM hParent;
;;;1074     GUI_RECT r;
;;;1075     WM_Obj* pAWin;
;;;1076     WM_Obj* pParent;
;;;1077     r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
0008a2  4ee5              LDR      r6,|L1.3128|
0008a4  68f1              LDR      r1,[r6,#0xc]  ; _ClipContext
0008a6  68b0              LDR      r0,[r6,#8]  ; _ClipContext
0008a8  9101              STR      r1,[sp,#4]
0008aa  9000              STR      r0,[sp,#0]
;;;1078     /*
;;;1079        STEP 1:
;;;1080          Set the next position which could be part of the next IVR
;;;1081          This will be the first unhandle pixel in reading order, i.e. next one to the right
;;;1082          or next one down if we are at the right border.
;;;1083     */
;;;1084     if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
0008ac  6930              LDR      r0,[r6,#0x10]  ; _ClipContext
0008ae  b1d8              CBZ      r0,|L1.2280|
;;;1085       r.x0 = _ClipContext.ClientRect.x0;
;;;1086       r.y0 = _ClipContext.ClientRect.y0;
;;;1087     } else {
;;;1088       r.x0 = _ClipContext.CurRect.x1+1;
0008b0  89b0              LDRH     r0,[r6,#0xc]  ; _ClipContext
0008b2  1c40              ADDS     r0,r0,#1
0008b4  b200              SXTH     r0,r0
0008b6  f8ad0000          STRH     r0,[sp,#0]
;;;1089       r.y0 = _ClipContext.CurRect.y0;
0008ba  8971              LDRH     r1,[r6,#0xa]  ; _ClipContext
0008bc  f8ad1002          STRH     r1,[sp,#2]
;;;1090       if (r.x0 > _ClipContext.ClientRect.x1) {
0008c0  f9b61004          LDRSH    r1,[r6,#4]  ; _ClipContext
0008c4  4288              CMP      r0,r1
0008c6  dd06              BLE      |L1.2262|
                  |L1.2248|
;;;1091   NextStripe:  /* go down to next stripe */
;;;1092         r.x0 = _ClipContext.ClientRect.x0;
0008c8  8830              LDRH     r0,[r6,#0]  ; _ClipContext
0008ca  f8ad0000          STRH     r0,[sp,#0]
;;;1093         r.y0 = _ClipContext.CurRect.y1+1;
0008ce  89f0              LDRH     r0,[r6,#0xe]  ; _ClipContext
0008d0  1c40              ADDS     r0,r0,#1
0008d2  f8ad0002          STRH     r0,[sp,#2]
                  |L1.2262|
;;;1094       }
;;;1095     }
;;;1096     /*
;;;1097        STEP 2:
;;;1098          Check if we are done completely.
;;;1099     */
;;;1100     if (r.y0 >_ClipContext.ClientRect.y1) {
0008d6  f9bd0002          LDRSH    r0,[sp,#2]
0008da  f9b61006          LDRSH    r1,[r6,#6]  ; _ClipContext
0008de  4288              CMP      r0,r1
0008e0  dd09              BLE      |L1.2294|
;;;1101       return 0;
;;;1102     }
;;;1103     /* STEP 3:
;;;1104          Find out the max. height (r.y1) if we are at the left border.
;;;1105          Since we are using the same height for all IVRs at the same y0,
;;;1106          we do this only for the leftmost one.
;;;1107     */
;;;1108     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1109     if (r.x0 == _ClipContext.ClientRect.x0) {
;;;1110       r.y1 = _ClipContext.ClientRect.y1;
;;;1111       r.x1 = _ClipContext.ClientRect.x1;
;;;1112       /* Iterate over all windows which are above */
;;;1113       /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1114       for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
;;;1115         pParent = WM_H2P(hParent);
;;;1116         _Findy1(pParent->hNext, &r, NULL);
;;;1117       }
;;;1118       /* Check all children */
;;;1119       _Findy1(pAWin->hFirstChild, &r, NULL);
;;;1120     }
;;;1121     /* 
;;;1122       STEP 4
;;;1123         Find out x0 for the given y0, y1 by iterating over windows above.
;;;1124         if we find one that intersects, adjust x0 to the right.
;;;1125     */
;;;1126   Find_x0:
;;;1127     r.x1 = r.x0;
;;;1128     /* Iterate over all windows which are above */
;;;1129     /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
;;;1130     #if 0   /* This is a planned, but not yet released optimization */
;;;1131       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1132       {
;;;1133         hParent = pAWin->hParent;
;;;1134       } else
;;;1135     #endif
;;;1136     {
;;;1137       hParent = GUI_Context.hAWin;
;;;1138     }
;;;1139     for (; hParent; hParent = pParent->hParent) {
;;;1140       pParent = WM_H2P(hParent);
;;;1141       if (_Findx0(pParent->hNext, &r, NULL)) {
;;;1142         goto Find_x0;
;;;1143       }
;;;1144     }
;;;1145     /* Check all children */
;;;1146     if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
;;;1147       goto Find_x0;
;;;1148     }
;;;1149     /* 
;;;1150      STEP 5:
;;;1151        If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
;;;1152        Find out x1 for the given x0, y0, y1
;;;1153     */
;;;1154     r.x1 = _ClipContext.ClientRect.x1;
;;;1155     if (r.x1 < r.x0) {/* horizontal border reached ? */
;;;1156       _ClipContext.CurRect = r;
;;;1157       goto NextStripe;
;;;1158     }    
;;;1159     /* 
;;;1160      STEP 6:
;;;1161        Find r.x1. We have to Iterate over all windows which are above
;;;1162     */
;;;1163     /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1164     #if 0   /* This is a planned, but not yet released optimization */
;;;1165       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1166       {
;;;1167         hParent = pAWin->hParent;
;;;1168       } else
;;;1169     #endif
;;;1170     {
;;;1171       hParent = GUI_Context.hAWin;
;;;1172     }
;;;1173     for (; hParent; hParent = pParent->hParent) {
;;;1174       pParent = WM_H2P(hParent);
;;;1175       _Findx1(pParent->hNext, &r, NULL);
;;;1176     }
;;;1177     /* Check all children */
;;;1178     _Findx1(pAWin->hFirstChild, &r, NULL);
;;;1179     /* We are done. Return the rectangle we found in the _ClipContext. */
;;;1180     if (_ClipContext.Cnt >200) {
;;;1181       return 0;  /* error !!! This should not happen !*/
;;;1182     }
;;;1183     _ClipContext.CurRect = r;
;;;1184     return 1;  /* IVR is valid ! */
;;;1185   }
0008e2  b003              ADD      sp,sp,#0xc
0008e4  2000              MOVS     r0,#0                 ;1101
0008e6  bdf0              POP      {r4-r7,pc}
                  |L1.2280|
0008e8  8830              LDRH     r0,[r6,#0]            ;1085  ; _ClipContext
0008ea  f8ad0000          STRH     r0,[sp,#0]            ;1085
0008ee  8870              LDRH     r0,[r6,#2]            ;1086  ; _ClipContext
0008f0  f8ad0002          STRH     r0,[sp,#2]            ;1086
0008f4  e7ef              B        |L1.2262|
                  |L1.2294|
0008f6  4fcf              LDR      r7,|L1.3124|
0008f8  f9b70040          LDRSH    r0,[r7,#0x40]         ;1108  ; GUI_Context
0008fc  f7fffffe          BL       GUI_ALLOC_h2p
000900  4605              MOV      r5,r0                 ;1108
000902  f9bd0000          LDRSH    r0,[sp,#0]            ;1109
000906  f9b61000          LDRSH    r1,[r6,#0]            ;1109  ; _ClipContext
00090a  4288              CMP      r0,r1                 ;1109
00090c  d11b              BNE      |L1.2374|
00090e  88f0              LDRH     r0,[r6,#6]            ;1110  ; _ClipContext
000910  f8ad0006          STRH     r0,[sp,#6]            ;1110
000914  88b0              LDRH     r0,[r6,#4]            ;1111  ; _ClipContext
000916  f8ad0004          STRH     r0,[sp,#4]            ;1111
00091a  f9b70040          LDRSH    r0,[r7,#0x40]         ;1114  ; GUI_Context
00091e  b160              CBZ      r0,|L1.2362|
                  |L1.2336|
000920  f7fffffe          BL       GUI_ALLOC_h2p
000924  4604              MOV      r4,r0                 ;1115
000926  2200              MOVS     r2,#0                 ;1116
000928  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1116
00092c  4669              MOV      r1,sp                 ;1116
00092e  f7fffffe          BL       _Findy1
000932  f9b40016          LDRSH    r0,[r4,#0x16]         ;1114
000936  2800              CMP      r0,#0                 ;1114
000938  d1f2              BNE      |L1.2336|
                  |L1.2362|
00093a  f9b50018          LDRSH    r0,[r5,#0x18]         ;1119
00093e  2200              MOVS     r2,#0                 ;1119
000940  4669              MOV      r1,sp                 ;1119
000942  f7fffffe          BL       _Findy1
                  |L1.2374|
000946  f8bd0000          LDRH     r0,[sp,#0]            ;1127
00094a  f8ad0004          STRH     r0,[sp,#4]            ;1127
00094e  f9b70040          LDRSH    r0,[r7,#0x40]         ;1137  ; GUI_Context
000952  b170              CBZ      r0,|L1.2418|
                  |L1.2388|
000954  f7fffffe          BL       GUI_ALLOC_h2p
000958  4604              MOV      r4,r0                 ;1140
00095a  2200              MOVS     r2,#0                 ;1141
00095c  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1141
000960  4669              MOV      r1,sp                 ;1141
000962  f7fffffe          BL       _Findx0
000966  2800              CMP      r0,#0                 ;1141
000968  d1ed              BNE      |L1.2374|
00096a  f9b40016          LDRSH    r0,[r4,#0x16]         ;1139
00096e  2800              CMP      r0,#0                 ;1139
000970  d1f0              BNE      |L1.2388|
                  |L1.2418|
000972  f9b50018          LDRSH    r0,[r5,#0x18]         ;1146
000976  2200              MOVS     r2,#0                 ;1146
000978  4669              MOV      r1,sp                 ;1146
00097a  f7fffffe          BL       _Findx0
00097e  2800              CMP      r0,#0                 ;1146
000980  d1e1              BNE      |L1.2374|
000982  f9b60004          LDRSH    r0,[r6,#4]            ;1154  ; _ClipContext
000986  f8ad0004          STRH     r0,[sp,#4]            ;1154
00098a  f9bd1000          LDRSH    r1,[sp,#0]            ;1155
00098e  4288              CMP      r0,r1                 ;1155
000990  da04              BGE      |L1.2460|
000992  9901              LDR      r1,[sp,#4]            ;1156
000994  9800              LDR      r0,[sp,#0]            ;1156
000996  60f1              STR      r1,[r6,#0xc]          ;1156  ; _ClipContext
000998  60b0              STR      r0,[r6,#8]            ;1156  ; _ClipContext
00099a  e795              B        |L1.2248|
                  |L1.2460|
00099c  f9b70040          LDRSH    r0,[r7,#0x40]         ;1171  ; GUI_Context
0009a0  b160              CBZ      r0,|L1.2492|
                  |L1.2466|
0009a2  f7fffffe          BL       GUI_ALLOC_h2p
0009a6  4604              MOV      r4,r0                 ;1174
0009a8  2200              MOVS     r2,#0                 ;1175
0009aa  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1175
0009ae  4669              MOV      r1,sp                 ;1175
0009b0  f7fffffe          BL       _Findx1
0009b4  f9b40016          LDRSH    r0,[r4,#0x16]         ;1173
0009b8  2800              CMP      r0,#0                 ;1173
0009ba  d1f2              BNE      |L1.2466|
                  |L1.2492|
0009bc  f9b50018          LDRSH    r0,[r5,#0x18]         ;1178
0009c0  2200              MOVS     r2,#0                 ;1178
0009c2  4669              MOV      r1,sp                 ;1178
0009c4  f7fffffe          BL       _Findx1
0009c8  6930              LDR      r0,[r6,#0x10]         ;1180  ; _ClipContext
0009ca  28c8              CMP      r0,#0xc8              ;1180
0009cc  dd02              BLE      |L1.2516|
0009ce  b003              ADD      sp,sp,#0xc
0009d0  2000              MOVS     r0,#0                 ;1181
0009d2  bdf0              POP      {r4-r7,pc}
                  |L1.2516|
0009d4  9901              LDR      r1,[sp,#4]            ;1183
0009d6  9800              LDR      r0,[sp,#0]            ;1183
0009d8  60f1              STR      r1,[r6,#0xc]          ;1183  ; _ClipContext
0009da  60b0              STR      r0,[r6,#8]            ;1183  ; _ClipContext
0009dc  b003              ADD      sp,sp,#0xc
0009de  2001              MOVS     r0,#1                 ;1184
0009e0  bdf0              POP      {r4-r7,pc}
;;;1186   
                          ENDP

                  WM__GetNextIVR PROC
;;;1210   */
;;;1211   int  WM__GetNextIVR(void) {
0009e2  b510              PUSH     {r4,lr}
;;;1212     #if GUI_SUPPORT_CURSOR
;;;1213       static char _CursorHidden;
;;;1214     #endif
;;;1215     /* If WM is not active, we have no rectangles to return */
;;;1216     if (WM_IsActive==0) {
0009e4  4892              LDR      r0,|L1.3120|
0009e6  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
0009e8  b138              CBZ      r0,|L1.2554|
;;;1217       return 0;
;;;1218     }
;;;1219     if (_ClipContext.EntranceCnt > 1) {
0009ea  4c93              LDR      r4,|L1.3128|
0009ec  6960              LDR      r0,[r4,#0x14]  ; _ClipContext
0009ee  2801              CMP      r0,#1
0009f0  dd05              BLE      |L1.2558|
;;;1220       _ClipContext.EntranceCnt--;
0009f2  1e40              SUBS     r0,r0,#1
0009f4  6160              STR      r0,[r4,#0x14]  ; _ClipContext
;;;1221       return 0;
0009f6  2000              MOVS     r0,#0
;;;1222     }
;;;1223     #if GUI_SUPPORT_CURSOR
;;;1224       if (_CursorHidden) {
;;;1225         _CursorHidden = 0;
;;;1226         (*GUI_CURSOR_pfTempUnhide) ();
;;;1227       }
;;;1228     #endif
;;;1229     ++_ClipContext.Cnt;
;;;1230     /* Find next rectangle and use it as ClipRect */
;;;1231     if (!_FindNext_IVR()) {
;;;1232       _ClipContext.EntranceCnt--;  /* This search is over ! */
;;;1233       return 0;        /* Could not find an other one ! */
;;;1234     }
;;;1235     WM__ActivateClipRect();
;;;1236     /* Hide cursor if necessary */
;;;1237     #if GUI_SUPPORT_CURSOR
;;;1238       if (GUI_CURSOR_pfTempHide) {
;;;1239         _CursorHidden = (*GUI_CURSOR_pfTempHide) ( &_ClipContext.CurRect);
;;;1240       }
;;;1241     #endif
;;;1242     return 1;
;;;1243   }
0009f8  bd10              POP      {r4,pc}
                  |L1.2554|
0009fa  2000              MOVS     r0,#0                 ;1217
0009fc  bd10              POP      {r4,pc}
                  |L1.2558|
0009fe  6920              LDR      r0,[r4,#0x10]         ;1229  ; _ClipContext
000a00  1c40              ADDS     r0,r0,#1              ;1229
000a02  6120              STR      r0,[r4,#0x10]         ;1229  ; _ClipContext
000a04  f7fffffe          BL       _FindNext_IVR
000a08  b118              CBZ      r0,|L1.2578|
000a0a  f7fffffe          BL       WM__ActivateClipRect
000a0e  2001              MOVS     r0,#1                 ;1242
000a10  bd10              POP      {r4,pc}
                  |L1.2578|
000a12  6960              LDR      r0,[r4,#0x14]         ;1232  ; _ClipContext
000a14  1e40              SUBS     r0,r0,#1              ;1232
000a16  6160              STR      r0,[r4,#0x14]         ;1232  ; _ClipContext
000a18  2000              MOVS     r0,#0                 ;1233
000a1a  bd10              POP      {r4,pc}
;;;1244   
                          ENDP

                  WM__InitIVRSearch PROC
;;;1256   */
;;;1257   int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
000a1c  e92d41f0          PUSH     {r4-r8,lr}
000a20  b084              SUB      sp,sp,#0x10
000a22  4680              MOV      r8,r0
;;;1258     GUI_RECT r;
;;;1259     WM_Obj* pAWin;
;;;1260     GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
;;;1261      /* If WM is not active -> nothing to do, leave cliprect alone */
;;;1262     if (WM_IsActive==0) {
000a24  4f82              LDR      r7,|L1.3120|
000a26  7838              LDRB     r0,[r7,#0]  ; WM_IsActive
000a28  b148              CBZ      r0,|L1.2622|
;;;1263       WM__ActivateClipRect();
;;;1264       return 1;
;;;1265     }
;;;1266     /* If we entered multiple times, leave Cliprect alone */
;;;1267     if (++_ClipContext.EntranceCnt > 1)
000a2a  4d83              LDR      r5,|L1.3128|
000a2c  6968              LDR      r0,[r5,#0x14]  ; _ClipContext
000a2e  1c40              ADDS     r0,r0,#1
000a30  6168              STR      r0,[r5,#0x14]  ; _ClipContext
000a32  2801              CMP      r0,#1
000a34  dd09              BLE      |L1.2634|
;;;1268       return 1;
;;;1269     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1270     _ClipContext.Cnt        = -1;
;;;1271    /* When using callback mechanism, it is legal to reduce drawing
;;;1272       area to the invalid area ! */
;;;1273     if (WM__PaintCallbackCnt) {
;;;1274       WM__GetInvalidRectAbs(pAWin, &r);
;;;1275     } else {  /* Not using callback mechanism, therefor allow entire rectangle */
;;;1276       if (pAWin->Status & WM_SF_ISVIS) {
;;;1277         r = pAWin->Rect;
;;;1278       } else {
;;;1279         --_ClipContext.EntranceCnt;
;;;1280         return 0;  /* window is not even visible ! */
;;;1281       }
;;;1282     }
;;;1283     /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
;;;1284     if (pMaxRect) {
;;;1285       GUI__IntersectRect(&r, pMaxRect);
;;;1286     }
;;;1287     /* If user has reduced the cliprect size, reduce the rectangle */
;;;1288     if (GUI_Context.WM__pUserClipRect) {
;;;1289       WM_Obj* pWin = pAWin;
;;;1290       GUI_RECT rUser = *(GUI_Context.WM__pUserClipRect);
;;;1291       #if WM_SUPPORT_TRANSPARENCY
;;;1292         if (WM__hATransWindow) {
;;;1293           pWin = WM_H2P(WM__hATransWindow);
;;;1294         }   
;;;1295       #endif
;;;1296       WM__Client2Screen(pWin, &rUser);
;;;1297       GUI__IntersectRect(&r, &rUser);
;;;1298     }
;;;1299     /* For transparent windows, we need to further reduce the rectangle */
;;;1300     #if WM_SUPPORT_TRANSPARENCY
;;;1301       if (WM__hATransWindow) {
;;;1302         if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
;;;1303           --_ClipContext.EntranceCnt;
;;;1304           return 0;           /* Nothing to draw */
;;;1305         }
;;;1306       }
;;;1307     #endif
;;;1308     /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
;;;1309     if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
;;;1310       --_ClipContext.EntranceCnt;
;;;1311       return 0;           /* Nothing to draw */
;;;1312     }
;;;1313     /* Store the rectangle and find the first rectangle of the area */
;;;1314     _ClipContext.ClientRect = r;
;;;1315     return WM__GetNextIVR();
;;;1316   }
000a36  b004              ADD      sp,sp,#0x10
000a38  2001              MOVS     r0,#1                 ;1268
000a3a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2622|
000a3e  f7fffffe          BL       WM__ActivateClipRect
000a42  b004              ADD      sp,sp,#0x10
000a44  2001              MOVS     r0,#1                 ;1264
000a46  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2634|
000a4a  4e7a              LDR      r6,|L1.3124|
000a4c  f9b60040          LDRSH    r0,[r6,#0x40]         ;1269  ; GUI_Context
000a50  f7fffffe          BL       GUI_ALLOC_h2p
000a54  4604              MOV      r4,r0                 ;1269
000a56  f04f30ff          MOV      r0,#0xffffffff        ;1270
000a5a  6128              STR      r0,[r5,#0x10]         ;1270  ; _ClipContext
000a5c  7878              LDRB     r0,[r7,#1]            ;1273  ; WM__PaintCallbackCnt
000a5e  b120              CBZ      r0,|L1.2666|
000a60  a902              ADD      r1,sp,#8              ;1274
000a62  4620              MOV      r0,r4                 ;1274
000a64  f7fffffe          BL       WM__GetInvalidRectAbs
000a68  e007              B        |L1.2682|
                  |L1.2666|
000a6a  8ba0              LDRH     r0,[r4,#0x1c]         ;1276
000a6c  f0100f02          TST      r0,#2                 ;1276
000a70  d034              BEQ      |L1.2780|
000a72  6861              LDR      r1,[r4,#4]            ;1277
000a74  6820              LDR      r0,[r4,#0]            ;1277
000a76  9103              STR      r1,[sp,#0xc]          ;1277
000a78  9002              STR      r0,[sp,#8]            ;1277
                  |L1.2682|
000a7a  f1b80f00          CMP      r8,#0                 ;1284
000a7e  d003              BEQ      |L1.2696|
000a80  4641              MOV      r1,r8                 ;1285
000a82  a802              ADD      r0,sp,#8              ;1285
000a84  f7fffffe          BL       GUI__IntersectRect
                  |L1.2696|
000a88  6bf0              LDR      r0,[r6,#0x3c]         ;1288  ; GUI_Context
000a8a  b188              CBZ      r0,|L1.2736|
000a8c  6801              LDR      r1,[r0,#0]            ;1290
000a8e  9100              STR      r1,[sp,#0]            ;1290
000a90  6840              LDR      r0,[r0,#4]            ;1290
000a92  9001              STR      r0,[sp,#4]            ;1290
000a94  f9b70012          LDRSH    r0,[r7,#0x12]         ;1292  ; WM__hATransWindow
000a98  b110              CBZ      r0,|L1.2720|
000a9a  f7fffffe          BL       GUI_ALLOC_h2p
000a9e  4604              MOV      r4,r0                 ;1293
                  |L1.2720|
000aa0  4669              MOV      r1,sp                 ;1296
000aa2  4620              MOV      r0,r4                 ;1296
000aa4  f7fffffe          BL       WM__Client2Screen
000aa8  4669              MOV      r1,sp                 ;1297
000aaa  a802              ADD      r0,sp,#8              ;1297
000aac  f7fffffe          BL       GUI__IntersectRect
                  |L1.2736|
000ab0  f9b71012          LDRSH    r1,[r7,#0x12]         ;1301  ; WM__hATransWindow
000ab4  b119              CBZ      r1,|L1.2750|
000ab6  a802              ADD      r0,sp,#8              ;1302
000ab8  f7fffffe          BL       WM__ClipAtParentBorders
000abc  b1a8              CBZ      r0,|L1.2794|
                  |L1.2750|
000abe  f9b61040          LDRSH    r1,[r6,#0x40]         ;1309  ; GUI_Context
000ac2  a802              ADD      r0,sp,#8              ;1309
000ac4  f7fffffe          BL       WM__ClipAtParentBorders
000ac8  b1b0              CBZ      r0,|L1.2808|
000aca  9903              LDR      r1,[sp,#0xc]          ;1314
000acc  9802              LDR      r0,[sp,#8]            ;1314
000ace  6069              STR      r1,[r5,#4]            ;1314  ; _ClipContext
000ad0  6028              STR      r0,[r5,#0]            ;1314  ; _ClipContext
000ad2  f7fffffe          BL       WM__GetNextIVR
000ad6  b004              ADD      sp,sp,#0x10
000ad8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2780|
000adc  6968              LDR      r0,[r5,#0x14]         ;1279  ; _ClipContext
000ade  1e40              SUBS     r0,r0,#1              ;1279
000ae0  6168              STR      r0,[r5,#0x14]         ;1279  ; _ClipContext
000ae2  b004              ADD      sp,sp,#0x10
000ae4  2000              MOVS     r0,#0                 ;1280
000ae6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2794|
000aea  6968              LDR      r0,[r5,#0x14]         ;1303  ; _ClipContext
000aec  1e40              SUBS     r0,r0,#1              ;1303
000aee  6168              STR      r0,[r5,#0x14]         ;1303  ; _ClipContext
000af0  b004              ADD      sp,sp,#0x10
000af2  2000              MOVS     r0,#0                 ;1304
000af4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2808|
000af8  6968              LDR      r0,[r5,#0x14]         ;1310  ; _ClipContext
000afa  1e40              SUBS     r0,r0,#1              ;1310
000afc  6168              STR      r0,[r5,#0x14]         ;1310  ; _ClipContext
000afe  b004              ADD      sp,sp,#0x10
000b00  2000              MOVS     r0,#0                 ;1311
000b02  e8bd81f0          POP      {r4-r8,pc}
;;;1317   
                          ENDP

                  WM_SetDefault PROC
;;;1326   */
;;;1327   void WM_SetDefault(void) {
000b06  b510              PUSH     {r4,lr}
;;;1328     GL_SetDefault();
000b08  f7fffffe          BL       GL_SetDefault
;;;1329     GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
000b0c  4949              LDR      r1,|L1.3124|
000b0e  2000              MOVS     r0,#0
000b10  63c8              STR      r0,[r1,#0x3c]  ; GUI_Context
;;;1330   }
000b12  bd10              POP      {r4,pc}
;;;1331   
                          ENDP

                  _Paint1 PROC
;;;1335   */
;;;1336   static void _Paint1(WM_HWIN hWin, WM_Obj* pWin) {
000b14  b5f0              PUSH     {r4-r7,lr}
000b16  b083              SUB      sp,sp,#0xc
000b18  4605              MOV      r5,r0
;;;1337     int Status = pWin->Status;
000b1a  8b88              LDRH     r0,[r1,#0x1c]
;;;1338     /* Send WM_PAINT if window is visible and a callback is defined */
;;;1339     if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
000b1c  690a              LDR      r2,[r1,#0x10]
000b1e  2a00              CMP      r2,#0
000b20  d02e              BEQ      |L1.2944|
000b22  f0100f02          TST      r0,#2
000b26  d02b              BEQ      |L1.2944|
;;;1340       WM_MESSAGE Msg;
;;;1341       WM__PaintCallbackCnt++;
000b28  4f41              LDR      r7,|L1.3120|
000b2a  787a              LDRB     r2,[r7,#1]  ; WM__PaintCallbackCnt
000b2c  1c52              ADDS     r2,r2,#1
000b2e  707a              STRB     r2,[r7,#1]
;;;1342       if (Status & WM_SF_LATE_CLIP) {
000b30  f4105f80          TST      r0,#0x1000
;;;1343         Msg.hWin   = hWin;
;;;1344         Msg.MsgId  = WM_PAINT;
000b34  f04f060f          MOV      r6,#0xf
;;;1345         Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000b38  f1010408          ADD      r4,r1,#8
000b3c  d00a              BEQ      |L1.2900|
000b3e  f8ad5004          STRH     r5,[sp,#4]            ;1343
000b42  9600              STR      r6,[sp,#0]            ;1344
000b44  9402              STR      r4,[sp,#8]
;;;1346         WM_SetDefault();
000b46  f7fffffe          BL       WM_SetDefault
;;;1347         WM__SendMessage(hWin, &Msg);
000b4a  4669              MOV      r1,sp
000b4c  4628              MOV      r0,r5
000b4e  f7fffffe          BL       WM__SendMessage
000b52  e012              B        |L1.2938|
                  |L1.2900|
;;;1348       } else {
;;;1349         WM_ITERATE_START(&pWin->InvalidRect) {
000b54  f1010008          ADD      r0,r1,#8
000b58  f7fffffe          BL       WM__InitIVRSearch
000b5c  b168              CBZ      r0,|L1.2938|
                  |L1.2910|
;;;1350           Msg.hWin   = hWin;
000b5e  f8ad5004          STRH     r5,[sp,#4]
;;;1351           Msg.MsgId  = WM_PAINT;
000b62  9600              STR      r6,[sp,#0]
;;;1352           Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000b64  9402              STR      r4,[sp,#8]
;;;1353           WM_SetDefault();
000b66  f7fffffe          BL       WM_SetDefault
;;;1354           WM__SendMessage(hWin, &Msg);
000b6a  4669              MOV      r1,sp
000b6c  4628              MOV      r0,r5
000b6e  f7fffffe          BL       WM__SendMessage
;;;1355         } WM_ITERATE_END();
000b72  f7fffffe          BL       WM__GetNextIVR
000b76  2800              CMP      r0,#0
000b78  d1f1              BNE      |L1.2910|
                  |L1.2938|
;;;1356       }
;;;1357       WM__PaintCallbackCnt--;
000b7a  7878              LDRB     r0,[r7,#1]  ; WM__PaintCallbackCnt
000b7c  1e40              SUBS     r0,r0,#1
000b7e  7078              STRB     r0,[r7,#1]
                  |L1.2944|
;;;1358     }
;;;1359   }
000b80  b003              ADD      sp,sp,#0xc
000b82  bdf0              POP      {r4-r7,pc}
;;;1360   /*********************************************************************
                          ENDP

                  _Paint1Trans PROC
;;;1382   #if WM_SUPPORT_TRANSPARENCY
;;;1383   static int _Paint1Trans(WM_HWIN hWin, WM_Obj* pWin) {
000b84  e92d47f0          PUSH     {r4-r10,lr}
000b88  4681              MOV      r9,r0
000b8a  460c              MOV      r4,r1
;;;1384     int xPrev, yPrev;
;;;1385     WM_Obj* pAWin = WM_H2P(GUI_Context.hAWin);
000b8c  4d29              LDR      r5,|L1.3124|
000b8e  f9b50040          LDRSH    r0,[r5,#0x40]  ; GUI_Context
000b92  f7fffffe          BL       GUI_ALLOC_h2p
000b96  4606              MOV      r6,r0
;;;1386     /* Check if we need to do any drawing */
;;;1387     if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
000b98  4621              MOV      r1,r4
000b9a  f1060008          ADD      r0,r6,#8
000b9e  f7fffffe          BL       GUI_RectsIntersect
000ba2  b1f0              CBZ      r0,|L1.3042|
;;;1388       /* Save old values */
;;;1389       xPrev = GUI_Context.xOff;
000ba4  6c6f              LDR      r7,[r5,#0x44]  ; GUI_Context
;;;1390       yPrev = GUI_Context.yOff;
000ba6  f8d58048          LDR      r8,[r5,#0x48]  ; GUI_Context
;;;1391       /* Set values for the current (transparent) window, rather than the one below */
;;;1392       GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
000baa  f1060208          ADD      r2,r6,#8
000bae  4621              MOV      r1,r4
000bb0  f1040008          ADD      r0,r4,#8
000bb4  f7fffffe          BL       GUI__IntersectRects
;;;1393       WM__hATransWindow = hWin;
000bb8  4e1d              LDR      r6,|L1.3120|
000bba  f8a69012          STRH     r9,[r6,#0x12]
;;;1394       GUI_Context.xOff = pWin->Rect.x0;
000bbe  f9b40000          LDRSH    r0,[r4,#0]
000bc2  6468              STR      r0,[r5,#0x44]  ; GUI_Context
;;;1395       GUI_Context.yOff = pWin->Rect.y0;
000bc4  f9b40002          LDRSH    r0,[r4,#2]
000bc8  64a8              STR      r0,[r5,#0x48]  ; GUI_Context
;;;1396       /* Do the actual drawing ... */
;;;1397       _Paint1(hWin, pWin);
000bca  4621              MOV      r1,r4
000bcc  4648              MOV      r0,r9
000bce  f7fffffe          BL       _Paint1
;;;1398       /* Restore settings */
;;;1399       WM__hATransWindow = 0;
000bd2  2000              MOVS     r0,#0
000bd4  8270              STRH     r0,[r6,#0x12]
;;;1400       GUI_Context.xOff = xPrev;
000bd6  646f              STR      r7,[r5,#0x44]  ; GUI_Context
;;;1401       GUI_Context.yOff = yPrev;
000bd8  f8c58048          STR      r8,[r5,#0x48]  ; GUI_Context
;;;1402       return 1;                       /* Some drawing took place */
000bdc  2001              MOVS     r0,#1
;;;1403     }
;;;1404     return 0;                         /* No invalid area, so nothing was drawn */
;;;1405   }
000bde  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3042|
000be2  2000              MOVS     r0,#0                 ;1404
000be4  e8bd87f0          POP      {r4-r10,pc}
;;;1406   #endif
                          ENDP

                  _PaintTransChildren PROC
;;;1419   #if WM_SUPPORT_TRANSPARENCY
;;;1420   static void _PaintTransChildren(WM_HWIN hWin, WM_Obj* pWin) {
000be8  e92d41f0          PUSH     {r4-r8,lr}
000bec  b082              SUB      sp,sp,#8
000bee  4680              MOV      r8,r0
000bf0  460c              MOV      r4,r1
;;;1421     WM_HWIN hChild;
;;;1422     WM_Obj* pChild;
;;;1423     if (pWin->Status & WM_SF_ISVIS) {
000bf2  8ba0              LDRH     r0,[r4,#0x1c]
000bf4  f0100f02          TST      r0,#2
000bf8  d03a              BEQ      |L1.3184|
;;;1424       for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000bfa  f9b45018          LDRSH    r5,[r4,#0x18]
000bfe  2d00              CMP      r5,#0
000c00  d036              BEQ      |L1.3184|
;;;1425         pChild = WM_H2P(hChild);
;;;1426         if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
000c02  2703              MOVS     r7,#3
                  |L1.3076|
000c04  4628              MOV      r0,r5                 ;1425
000c06  f7fffffe          BL       GUI_ALLOC_h2p
000c0a  4606              MOV      r6,r0                 ;1425
000c0c  8bb0              LDRH     r0,[r6,#0x1c]
000c0e  ea370000          BICS     r0,r7,r0
000c12  d129              BNE      |L1.3176|
;;;1427   		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
;;;1428           /* Set invalid area of the window to draw */
;;;1429           if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
000c14  f1040108          ADD      r1,r4,#8
000c18  4630              MOV      r0,r6
000c1a  f7fffffe          BL       GUI_RectsIntersect
000c1e  b318              CBZ      r0,|L1.3176|
;;;1430             GUI_RECT InvalidRectPrev;
;;;1431             InvalidRectPrev = pWin->InvalidRect;
000c20  68e1              LDR      r1,[r4,#0xc]
000c22  68a0              LDR      r0,[r4,#8]
000c24  9101              STR      r1,[sp,#4]
000c26  9000              STR      r0,[sp,#0]
;;;1432             if(_Paint1Trans(hChild, pChild)) {
000c28  4631              MOV      r1,r6
000c2a  4628              MOV      r0,r5
000c2c  e006              B        |L1.3132|
000c2e  0000              DCW      0x0000
                  |L1.3120|
                          DCD      ||.data||
                  |L1.3124|
                          DCD      GUI_Context
                  |L1.3128|
                          DCD      ||area_number.4||
                  |L1.3132|
000c3c  f7fffffe          BL       _Paint1Trans
000c40  b170              CBZ      r0,|L1.3168|
;;;1433               #if GUI_SUPPORT_MEMDEV
;;;1434                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1435                    So the pointer(s) could be invalid after the last function call and needs
;;;1436                    to be restored.
;;;1437                 */
;;;1438                 pChild = WM_H2P(hChild);
000c42  4628              MOV      r0,r5
000c44  f7fffffe          BL       GUI_ALLOC_h2p
;;;1439               #endif
;;;1440               _PaintTransChildren(hChild, pChild);
000c48  4601              MOV      r1,r0
000c4a  4628              MOV      r0,r5
000c4c  f7fffffe          BL       _PaintTransChildren
;;;1441               #if GUI_SUPPORT_MEMDEV
;;;1442                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1443                    So the pointer(s) could be invalid after the last function call and needs
;;;1444                    to be restored.
;;;1445                 */
;;;1446                 pChild = WM_H2P(hChild);
000c50  4628              MOV      r0,r5
000c52  f7fffffe          BL       GUI_ALLOC_h2p
000c56  4606              MOV      r6,r0
;;;1447                 pWin   = WM_H2P(hWin);
000c58  4640              MOV      r0,r8
000c5a  f7fffffe          BL       GUI_ALLOC_h2p
000c5e  4604              MOV      r4,r0
                  |L1.3168|
;;;1448               #endif
;;;1449             }
;;;1450             pWin->InvalidRect = InvalidRectPrev;
000c60  9901              LDR      r1,[sp,#4]
000c62  9800              LDR      r0,[sp,#0]
000c64  60e1              STR      r1,[r4,#0xc]
000c66  60a0              STR      r0,[r4,#8]
                  |L1.3176|
000c68  f9b6501a          LDRSH    r5,[r6,#0x1a]         ;1424
000c6c  2d00              CMP      r5,#0                 ;1424
000c6e  d1c9              BNE      |L1.3076|
                  |L1.3184|
;;;1451           }
;;;1452         }
;;;1453       }
;;;1454     }
;;;1455   }
000c70  b002              ADD      sp,sp,#8
000c72  e8bd81f0          POP      {r4-r8,pc}
;;;1456   #endif
                          ENDP

                  _PaintTransTopSiblings PROC
;;;1469   #if WM_SUPPORT_TRANSPARENCY
;;;1470   static void _PaintTransTopSiblings(WM_HWIN hWin, WM_Obj* pWin) {
000c76  e92d41f0          PUSH     {r4-r8,lr}
;;;1471     WM_HWIN hParent;
;;;1472     WM_Obj* pParent;
;;;1473     hParent = pWin->hParent;
000c7a  f9b17016          LDRSH    r7,[r1,#0x16]
;;;1474     hWin = pWin->hNext;
000c7e  f9b1401a          LDRSH    r4,[r1,#0x1a]
;;;1475     while (hParent) { /* Go hierarchy up to desktop window */
000c82  2f00              CMP      r7,#0
000c84  d022              BEQ      |L1.3276|
;;;1476       for (; hWin; hWin = pWin->hNext) {
;;;1477         pWin = WM_H2P(hWin);
;;;1478         /* paint window if it is transparent & visible */
;;;1479         if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_ISVIS)) ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
000c86  2603              MOVS     r6,#3
                  |L1.3208|
000c88  b1bc              CBZ      r4,|L1.3258|
                  |L1.3210|
000c8a  4620              MOV      r0,r4                 ;1477
000c8c  f7fffffe          BL       GUI_ALLOC_h2p
000c90  4605              MOV      r5,r0                 ;1477
000c92  8ba8              LDRH     r0,[r5,#0x1c]
000c94  ea360000          BICS     r0,r6,r0
000c98  d107              BNE      |L1.3242|
;;;1480           _Paint1Trans(hWin, pWin);
000c9a  4629              MOV      r1,r5
000c9c  4620              MOV      r0,r4
000c9e  f7fffffe          BL       _Paint1Trans
;;;1481           #if GUI_SUPPORT_MEMDEV
;;;1482             /* Within the paint event the application is alowed to deal with memory devices.
;;;1483                So the pointer(s) could be invalid after the last function call and needs
;;;1484                to be restored.
;;;1485             */
;;;1486             pWin   = WM_H2P(hWin);
000ca2  4620              MOV      r0,r4
000ca4  f7fffffe          BL       GUI_ALLOC_h2p
000ca8  4605              MOV      r5,r0
                  |L1.3242|
;;;1487           #endif
;;;1488         }
;;;1489         /* paint transparent & visible children */
;;;1490         _PaintTransChildren(hWin, pWin);
000caa  4629              MOV      r1,r5
000cac  4620              MOV      r0,r4
000cae  f7fffffe          BL       _PaintTransChildren
000cb2  f9b5401a          LDRSH    r4,[r5,#0x1a]         ;1476
000cb6  2c00              CMP      r4,#0                 ;1476
000cb8  d1e7              BNE      |L1.3210|
                  |L1.3258|
;;;1491       }
;;;1492       pParent = WM_H2P(hParent);
000cba  4638              MOV      r0,r7
000cbc  f7fffffe          BL       GUI_ALLOC_h2p
;;;1493       hWin = pParent->hNext;
000cc0  f9b0401a          LDRSH    r4,[r0,#0x1a]
;;;1494       hParent = pParent->hParent;
000cc4  f9b07016          LDRSH    r7,[r0,#0x16]
000cc8  2f00              CMP      r7,#0                 ;1475
000cca  d1dd              BNE      |L1.3208|
                  |L1.3276|
;;;1495     }
;;;1496   }
000ccc  e8bd81f0          POP      {r4-r8,pc}
;;;1497   #endif
                          ENDP

                  WM__PaintWinAndOverlays PROC
;;;1518   */
;;;1519   void WM__PaintWinAndOverlays(WM_PAINTINFO* pInfo) {
000cd0  b510              PUSH     {r4,lr}
;;;1520     WM_HWIN hWin;
;;;1521     WM_Obj* pWin;
;;;1522     hWin = pInfo->hWin;
000cd2  f9b04000          LDRSH    r4,[r0,#0]
;;;1523     pWin = pInfo->pWin;
000cd6  6841              LDR      r1,[r0,#4]
;;;1524     if (!pWin) {
000cd8  b919              CBNZ     r1,|L1.3298|
;;;1525       pWin = WM_H2P(hWin);
000cda  4620              MOV      r0,r4
000cdc  f7fffffe          BL       GUI_ALLOC_h2p
000ce0  4601              MOV      r1,r0
                  |L1.3298|
;;;1526     }
;;;1527     #if WM_SUPPORT_TRANSPARENCY
;;;1528       /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
;;;1529       if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
000ce2  8b88              LDRH     r0,[r1,#0x1c]
000ce4  f42070ff          BIC      r0,r0,#0x1fe
000ce8  f4204076          BIC      r0,r0,#0xf600
000cec  2801              CMP      r0,#1
000cee  d006              BEQ      |L1.3326|
;;;1530     #endif
;;;1531     _Paint1(hWin, pWin);    /* Draw the window itself */
000cf0  4620              MOV      r0,r4
000cf2  f7fffffe          BL       _Paint1
;;;1532     #if GUI_SUPPORT_MEMDEV
;;;1533       /* Within the paint event the application is alowed to deal with memory devices.
;;;1534          So the pointer(s) could be invalid after the last function call and needs
;;;1535          to be restored.
;;;1536       */
;;;1537       pWin = WM_H2P(hWin);
000cf6  4620              MOV      r0,r4
000cf8  f7fffffe          BL       GUI_ALLOC_h2p
000cfc  4601              MOV      r1,r0
                  |L1.3326|
;;;1538     #endif
;;;1539     #if WM_SUPPORT_TRANSPARENCY
;;;1540       }
;;;1541       if (WM__TransWindowCnt != 0) {
000cfe  48a7              LDR      r0,|L1.3996|
000d00  6a40              LDR      r0,[r0,#0x24]  ; WM__TransWindowCnt
000d02  2800              CMP      r0,#0
000d04  d00a              BEQ      |L1.3356|
;;;1542         _PaintTransChildren(hWin, pWin);             /* Draw all transparent children */
000d06  4620              MOV      r0,r4
000d08  f7fffffe          BL       _PaintTransChildren
;;;1543         #if GUI_SUPPORT_MEMDEV
;;;1544           /* Within the paint event the application is alowed to deal with memory devices.
;;;1545              So the pointer(s) could be invalid after the last function call and needs
;;;1546              to be restored.
;;;1547           */
;;;1548           pWin = WM_H2P(hWin);
000d0c  4620              MOV      r0,r4
000d0e  f7fffffe          BL       GUI_ALLOC_h2p
;;;1549         #endif
;;;1550         _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
000d12  4601              MOV      r1,r0
000d14  4620              MOV      r0,r4
000d16  e8bd4010          POP      {r4,lr}
000d1a  e7fe              B        _PaintTransTopSiblings
                  |L1.3356|
;;;1551       }
;;;1552     #endif
;;;1553   }
000d1c  bd10              POP      {r4,pc}
;;;1554   
                          ENDP

                  _cbPaintMemDev PROC
;;;1567   #if GUI_SUPPORT_MEMDEV
;;;1568   static void _cbPaintMemDev(void* p) {
000d1e  b570              PUSH     {r4-r6,lr}
000d20  b082              SUB      sp,sp,#8
000d22  4606              MOV      r6,r0
;;;1569     GUI_RECT Rect;
;;;1570     WM_Obj* pWin = WM_H2P(GUI_Context.hAWin);
000d24  4d9e              LDR      r5,|L1.4000|
000d26  f9b50040          LDRSH    r0,[r5,#0x40]  ; GUI_Context
000d2a  f7fffffe          BL       GUI_ALLOC_h2p
000d2e  4604              MOV      r4,r0
;;;1571     Rect = pWin->InvalidRect;
000d30  68e1              LDR      r1,[r4,#0xc]
000d32  68a0              LDR      r0,[r4,#8]
000d34  9101              STR      r1,[sp,#4]
000d36  9000              STR      r0,[sp,#0]
;;;1572     pWin->InvalidRect = GUI_Context.ClipRect;
000d38  68e9              LDR      r1,[r5,#0xc]  ; GUI_Context
000d3a  68a8              LDR      r0,[r5,#8]  ; GUI_Context
000d3c  60e1              STR      r1,[r4,#0xc]
000d3e  60a0              STR      r0,[r4,#8]
;;;1573     WM__PaintWinAndOverlays((WM_PAINTINFO*)p);
000d40  4630              MOV      r0,r6
000d42  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1574     pWin->InvalidRect = Rect;
000d46  9901              LDR      r1,[sp,#4]
000d48  9800              LDR      r0,[sp,#0]
000d4a  60e1              STR      r1,[r4,#0xc]
000d4c  60a0              STR      r0,[r4,#8]
;;;1575   }
000d4e  b002              ADD      sp,sp,#8
000d50  bd70              POP      {r4-r6,pc}
;;;1576   #endif
                          ENDP

                  WM__Paint PROC
;;;1584   */
;;;1585   int WM__Paint(WM_HWIN hWin, WM_Obj* pWin) {
000d52  b570              PUSH     {r4-r6,lr}
000d54  b086              SUB      sp,sp,#0x18
000d56  4606              MOV      r6,r0
000d58  460c              MOV      r4,r1
;;;1586     int Ret = 0;
000d5a  2500              MOVS     r5,#0
;;;1587     if (pWin->Status & WM_SF_INVALID) {
000d5c  8ba0              LDRH     r0,[r4,#0x1c]
000d5e  f0100f20          TST      r0,#0x20
000d62  d038              BEQ      |L1.3542|
;;;1588       if (pWin->cb) {
000d64  6920              LDR      r0,[r4,#0x10]
000d66  b310              CBZ      r0,|L1.3502|
;;;1589         if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
000d68  4631              MOV      r1,r6
000d6a  f1040008          ADD      r0,r4,#8
000d6e  f7fffffe          BL       WM__ClipAtParentBorders
000d72  b1e0              CBZ      r0,|L1.3502|
;;;1590           WM_PAINTINFO Info;
;;;1591           Info.hWin = hWin;
000d74  f8ad6010          STRH     r6,[sp,#0x10]
;;;1592           WM_SelectWindow(hWin);
000d78  4630              MOV      r0,r6
000d7a  f7fffffe          BL       WM_SelectWindow
;;;1593           #if GUI_SUPPORT_MEMDEV
;;;1594             Info.pWin = NULL; /* 'Invalidate' the window pointer, because it can 
000d7e  2000              MOVS     r0,#0
000d80  9005              STR      r0,[sp,#0x14]
;;;1595                                   become invalid through the creation of a memory device
;;;1596                               */
;;;1597             if (pWin->Status & WM_SF_MEMDEV) {
000d82  8ba0              LDRH     r0,[r4,#0x1c]
000d84  f0100f04          TST      r0,#4
000d88  d012              BEQ      |L1.3504|
;;;1598               int Flags;
;;;1599               GUI_RECT r = pWin->InvalidRect;
000d8a  68e1              LDR      r1,[r4,#0xc]
000d8c  68a0              LDR      r0,[r4,#8]
000d8e  9103              STR      r1,[sp,#0xc]
000d90  9002              STR      r0,[sp,#8]
;;;1600               Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
000d92  8ba0              LDRH     r0,[r4,#0x1c]
000d94  2101              MOVS     r1,#1
000d96  ea210300          BIC      r3,r1,r0
;;;1601               /*
;;;1602                * Currently we treat a desktop window as transparent, because per default it does not repaint itself.
;;;1603                */
;;;1604               if (pWin->hParent == 0) {
000d9a  8ae0              LDRH     r0,[r4,#0x16]
000d9c  b900              CBNZ     r0,|L1.3488|
;;;1605                 Flags = GUI_MEMDEV_HASTRANS;
000d9e  2300              MOVS     r3,#0
                  |L1.3488|
;;;1606               }
;;;1607               GUI_MEMDEV_Draw(&r, _cbPaintMemDev, &Info, 0, Flags);
000da0  9300              STR      r3,[sp,#0]
000da2  2300              MOVS     r3,#0
000da4  aa04              ADD      r2,sp,#0x10
000da6  497f              LDR      r1,|L1.4004|
000da8  a802              ADD      r0,sp,#8
000daa  f7fffffe          BL       GUI_MEMDEV_Draw
                  |L1.3502|
;;;1608             } else
000dae  e004              B        |L1.3514|
                  |L1.3504|
;;;1609           #endif
;;;1610           {
;;;1611             Info.pWin = pWin;
000db0  9405              STR      r4,[sp,#0x14]
;;;1612             WM__PaintWinAndOverlays(&Info);
000db2  a804              ADD      r0,sp,#0x10
000db4  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1613             Ret = 1;    /* Something has been done */
000db8  2501              MOVS     r5,#1
                  |L1.3514|
;;;1614           }
;;;1615         }
;;;1616       }
;;;1617       /* We purposly clear the invalid flag after painting so we can still query the invalid rectangle while painting */
;;;1618       pWin->Status &=  ~WM_SF_INVALID; /* Clear invalid flag */
000dba  8ba0              LDRH     r0,[r4,#0x1c]
000dbc  f0200020          BIC      r0,r0,#0x20
000dc0  83a0              STRH     r0,[r4,#0x1c]
;;;1619       if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
000dc2  f4105f00          TST      r0,#0x2000
000dc6  d002              BEQ      |L1.3534|
;;;1620         pWin->Status |= WM_CF_MEMDEV;
000dc8  f0400004          ORR      r0,r0,#4
000dcc  83a0              STRH     r0,[r4,#0x1c]
                  |L1.3534|
;;;1621       }
;;;1622       WM__NumInvalidWindows--;
000dce  4873              LDR      r0,|L1.3996|
000dd0  88c1              LDRH     r1,[r0,#6]  ; WM__NumInvalidWindows
000dd2  1e49              SUBS     r1,r1,#1
000dd4  80c1              STRH     r1,[r0,#6]
                  |L1.3542|
;;;1623     }
;;;1624     return Ret;      /* Nothing done */
;;;1625   }
000dd6  b006              ADD      sp,sp,#0x18
000dd8  4628              MOV      r0,r5                 ;1624
000dda  bd70              POP      {r4-r6,pc}
;;;1626   
                          ENDP

                  _DrawNext PROC
;;;1630   */
;;;1631   static void _DrawNext(void) {
000ddc  b5f0              PUSH     {r4-r7,lr}
000dde  b099              SUB      sp,sp,#0x64
;;;1632     int UpdateRem = 1;
000de0  2401              MOVS     r4,#1
;;;1633     WM_HWIN iWin = (NextDrawWin == WM_HWIN_NULL) ? WM__FirstWin : NextDrawWin;
000de2  4f6e              LDR      r7,|L1.3996|
000de4  f9b75014          LDRSH    r5,[r7,#0x14]  ; NextDrawWin
000de8  b90d              CBNZ     r5,|L1.3566|
000dea  f9b75008          LDRSH    r5,[r7,#8]  ; WM__FirstWin
                  |L1.3566|
;;;1634     GUI_CONTEXT ContextOld;
;;;1635     GUI_SaveContext(&ContextOld);
000dee  4668              MOV      r0,sp
000df0  f7fffffe          BL       GUI_SaveContext_W_M
;;;1636     /* Make sure the next window to redraw is valid */
;;;1637     for (; iWin && UpdateRem; ) {
000df4  e00b              B        |L1.3598|
                  |L1.3574|
;;;1638       WM_Obj* pWin = WM_H2P(iWin);
000df6  4628              MOV      r0,r5
000df8  f7fffffe          BL       GUI_ALLOC_h2p
000dfc  4606              MOV      r6,r0
;;;1639       if (WM__Paint(iWin, pWin)) {
000dfe  4631              MOV      r1,r6
000e00  4628              MOV      r0,r5
000e02  f7fffffe          BL       WM__Paint
000e06  b100              CBZ      r0,|L1.3594|
;;;1640         UpdateRem--;  /* Only the given number of windows at a time ... */
000e08  1e64              SUBS     r4,r4,#1
                  |L1.3594|
;;;1641       }
;;;1642       iWin = pWin->hNextLin;
000e0a  f9b65014          LDRSH    r5,[r6,#0x14]
                  |L1.3598|
000e0e  b10d              CBZ      r5,|L1.3604|
000e10  2c00              CMP      r4,#0                 ;1637
000e12  d1f0              BNE      |L1.3574|
                  |L1.3604|
;;;1643     }  
;;;1644     NextDrawWin = iWin;   /* Remember the window */
000e14  82bd              STRH     r5,[r7,#0x14]
;;;1645     GUI_RestoreContext(&ContextOld);
000e16  4668              MOV      r0,sp
000e18  f7fffffe          BL       GUI_RestoreContext
;;;1646   }
000e1c  b019              ADD      sp,sp,#0x64
000e1e  bdf0              POP      {r4-r7,pc}
;;;1647   
                          ENDP

                  WM_Exec1 PROC
;;;1651   */
;;;1652   int WM_Exec1(void) {
000e20  b510              PUSH     {r4,lr}
;;;1653     /* Poll PID if necessary */
;;;1654     if (WM_pfPollPID) {
000e22  4c5e              LDR      r4,|L1.3996|
000e24  6a20              LDR      r0,[r4,#0x20]  ; WM_pfPollPID
000e26  b100              CBZ      r0,|L1.3626|
;;;1655       WM_pfPollPID();
000e28  4780              BLX      r0
                  |L1.3626|
;;;1656     }
;;;1657     if (WM_pfHandlePID) {
000e2a  485f              LDR      r0,|L1.4008|
000e2c  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000e2e  b118              CBZ      r0,|L1.3640|
;;;1658       if (WM_pfHandlePID())
000e30  4780              BLX      r0
000e32  b108              CBZ      r0,|L1.3640|
;;;1659         return 1;               /* We have done something ... */
000e34  2001              MOVS     r0,#1
;;;1660     }
;;;1661     if (WM_IsActive) {
;;;1662       if (GUI_PollKeyMsg()) {
;;;1663         return 1;               /* We have done something ... */
;;;1664       }
;;;1665     }
;;;1666   #ifdef WIN32
;;;1667     if (WM_PollSimMsg()) {
;;;1668       return 1;               /* We have done something ... */
;;;1669     }
;;;1670   #endif
;;;1671     if (WM_IsActive && WM__NumInvalidWindows) {
;;;1672       WM_LOCK();
;;;1673       _DrawNext();
;;;1674       WM_UNLOCK();
;;;1675       return 1;               /* We have done something ... */
;;;1676     }
;;;1677     return 0;                  /* There was nothing to do ... */
;;;1678   }
000e36  bd10              POP      {r4,pc}
                  |L1.3640|
000e38  7820              LDRB     r0,[r4,#0]            ;1661  ; WM_IsActive
000e3a  b120              CBZ      r0,|L1.3654|
000e3c  f7fffffe          BL       GUI_PollKeyMsg
000e40  b108              CBZ      r0,|L1.3654|
000e42  2001              MOVS     r0,#1                 ;1663
000e44  bd10              POP      {r4,pc}
                  |L1.3654|
000e46  7820              LDRB     r0,[r4,#0]            ;1671  ; WM_IsActive
000e48  b148              CBZ      r0,|L1.3678|
000e4a  88e0              LDRH     r0,[r4,#6]            ;1671  ; WM__NumInvalidWindows
000e4c  b138              CBZ      r0,|L1.3678|
000e4e  f7fffffe          BL       GUI_Lock
000e52  f7fffffe          BL       _DrawNext
000e56  f7fffffe          BL       GUI_Unlock
000e5a  2001              MOVS     r0,#1                 ;1675
000e5c  bd10              POP      {r4,pc}
                  |L1.3678|
000e5e  2000              MOVS     r0,#0                 ;1677
000e60  bd10              POP      {r4,pc}
;;;1679   
                          ENDP

                  WM_Exec PROC
;;;1683   */
;;;1684   int WM_Exec(void) {
000e62  b510              PUSH     {r4,lr}
;;;1685     int r = 0;
000e64  2400              MOVS     r4,#0
;;;1686     while (WM_Exec1()) {
000e66  f7fffffe          BL       WM_Exec1
000e6a  b120              CBZ      r0,|L1.3702|
                  |L1.3692|
;;;1687       r = 1;                  /* We have done something */
000e6c  2401              MOVS     r4,#1
000e6e  f7fffffe          BL       WM_Exec1
000e72  2800              CMP      r0,#0                 ;1686
000e74  d1fa              BNE      |L1.3692|
                  |L1.3702|
;;;1688     }
;;;1689     return r;
000e76  4620              MOV      r0,r4
;;;1690   }
000e78  bd10              POP      {r4,pc}
;;;1691   
                          ENDP

                  WM_DefaultProc PROC
;;;1755   */
;;;1756   void WM_DefaultProc(WM_MESSAGE* pMsg) {
000e7a  b570              PUSH     {r4-r6,lr}
000e7c  4604              MOV      r4,r0
;;;1757     WM_HWIN hWin = pMsg->hWin;
000e7e  f9b45004          LDRSH    r5,[r4,#4]
;;;1758     const void *p = pMsg->Data.p;
000e82  68a6              LDR      r6,[r4,#8]
;;;1759     WM_Obj* pWin = WM_H2P(hWin);
000e84  4628              MOV      r0,r5
000e86  f7fffffe          BL       GUI_ALLOC_h2p
000e8a  4602              MOV      r2,r0
;;;1760     /* Exec message */
;;;1761     switch (pMsg->MsgId) {
000e8c  6820              LDR      r0,[r4,#0]
000e8e  2817              CMP      r0,#0x17
000e90  d011              BEQ      |L1.3766|
000e92  dc04              BGT      |L1.3742|
000e94  280e              CMP      r0,#0xe
000e96  d010              BEQ      |L1.3770|
000e98  2814              CMP      r0,#0x14
000e9a  d109              BNE      |L1.3760|
000e9c  e004              B        |L1.3752|
                  |L1.3742|
000e9e  2822              CMP      r0,#0x22
000ea0  d011              BEQ      |L1.3782|
000ea2  2828              CMP      r0,#0x28
000ea4  d104              BNE      |L1.3760|
000ea6  e012              B        |L1.3790|
                  |L1.3752|
;;;1762     case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
;;;1763       WM__GetClientRectWin(pWin, (GUI_RECT*)p);
000ea8  4631              MOV      r1,r6
000eaa  4610              MOV      r0,r2
000eac  f7fffffe          BL       WM__GetClientRectWin
                  |L1.3760|
;;;1764       break;
;;;1765     case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
;;;1766       pMsg->Data.v = (int)hWin;
;;;1767       return;                       /* Message handled */
;;;1768     case WM_KEY:
;;;1769       WM_SendToParent(hWin, pMsg);
;;;1770       return;                       /* Message handled */
;;;1771      case WM_GET_BKCOLOR:
;;;1772       pMsg->Data.Color = GUI_INVALID_COLOR;
;;;1773       return;                       /* Message handled */
;;;1774     case WM_NOTIFY_ENABLE:
;;;1775       WM_InvalidateWindow(hWin);    
;;;1776       return;                       /* Message handled */
;;;1777     }
;;;1778     /* Message not handled. If it queries something, we return 0 to be on the safe side. */
;;;1779     pMsg->Data.v = 0;
000eb0  2000              MOVS     r0,#0
000eb2  60a0              STR      r0,[r4,#8]
;;;1780     pMsg->Data.p = 0;
;;;1781   }
000eb4  bd70              POP      {r4-r6,pc}
                  |L1.3766|
000eb6  60a5              STR      r5,[r4,#8]            ;1766
000eb8  bd70              POP      {r4-r6,pc}
                  |L1.3770|
000eba  4621              MOV      r1,r4                 ;1769
000ebc  4628              MOV      r0,r5                 ;1769
000ebe  e8bd4070          POP      {r4-r6,lr}            ;1769
000ec2  f7ffbffe          B.W      WM_SendToParent
                  |L1.3782|
000ec6  f06f4070          MVN      r0,#0xf0000000        ;1772
000eca  60a0              STR      r0,[r4,#8]            ;1772
000ecc  bd70              POP      {r4-r6,pc}
                  |L1.3790|
000ece  4628              MOV      r0,r5                 ;1775
000ed0  e8bd4070          POP      {r4-r6,lr}            ;1775
000ed4  e7fe              B        WM_InvalidateWindow
;;;1782   
                          ENDP

                  cbBackWin PROC
;;;1699   */
;;;1700   static void cbBackWin( WM_MESSAGE* pMsg) {
000ed6  b510              PUSH     {r4,lr}
000ed8  4604              MOV      r4,r0
;;;1701     const WM_KEY_INFO* pKeyInfo;
;;;1702     switch (pMsg->MsgId) {
000eda  6820              LDR      r0,[r4,#0]
000edc  280e              CMP      r0,#0xe
000ede  d002              BEQ      |L1.3814|
000ee0  280f              CMP      r0,#0xf
000ee2  d113              BNE      |L1.3852|
000ee4  e008              B        |L1.3832|
                  |L1.3814|
;;;1703     case WM_KEY:
;;;1704       pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
000ee6  68a0              LDR      r0,[r4,#8]
;;;1705       if (pKeyInfo->PressedCnt == 1) {
000ee8  6841              LDR      r1,[r0,#4]
000eea  2901              CMP      r1,#1
000eec  d112              BNE      |L1.3860|
;;;1706         GUI_StoreKey(pKeyInfo->Key);
000eee  6800              LDR      r0,[r0,#0]
000ef0  e8bd4010          POP      {r4,lr}
000ef4  f7ffbffe          B.W      GUI_StoreKey
                  |L1.3832|
;;;1707       }
;;;1708       break;
;;;1709     case WM_PAINT:
;;;1710       {
;;;1711         int LayerIndex;
;;;1712         #if GUI_NUM_LAYERS > 1
;;;1713           LayerIndex = _DesktopHandle2Index(pMsg->hWin);
;;;1714         #else
;;;1715           LayerIndex = 0;
;;;1716         #endif
;;;1717         if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
000ef8  482c              LDR      r0,|L1.4012|
000efa  f06f4170          MVN      r1,#0xf0000000
000efe  6800              LDR      r0,[r0,#0]
000f00  4288              CMP      r0,r1
000f02  d003              BEQ      |L1.3852|
;;;1718           GUI_SetBkColor(WM__aBkColor[LayerIndex]);
000f04  f7fffffe          BL       GUI_SetBkColor
;;;1719           GUI_Clear();
000f08  f7fffffe          BL       GUI_Clear
                  |L1.3852|
;;;1720         }
;;;1721       }
;;;1722     default:
;;;1723       WM_DefaultProc(pMsg);
000f0c  4620              MOV      r0,r4
000f0e  e8bd4010          POP      {r4,lr}
000f12  e7fe              B        WM_DefaultProc
                  |L1.3860|
;;;1724     }
;;;1725   }
000f14  bd10              POP      {r4,pc}
;;;1726   
                          ENDP

                  WM_Activate PROC
;;;1730   */
;;;1731   void WM_Activate(void) {
000f16  4921              LDR      r1,|L1.3996|
;;;1732     WM_IsActive = 1;       /* Running */
000f18  2001              MOVS     r0,#1
000f1a  7008              STRB     r0,[r1,#0]
;;;1733   }
000f1c  4770              BX       lr
;;;1734   
                          ENDP

                  WM_Deactivate PROC
;;;1738   */
;;;1739   void WM_Deactivate(void) {
000f1e  b510              PUSH     {r4,lr}
;;;1740     WM_IsActive = 0;       /* No clipping performed by WM */
000f20  491e              LDR      r1,|L1.3996|
000f22  2000              MOVS     r0,#0
000f24  7008              STRB     r0,[r1,#0]
;;;1741     WM_LOCK();
000f26  f7fffffe          BL       GUI_Lock
;;;1742     LCD_SetClipRectMax();
000f2a  f7fffffe          BL       LCD_SetClipRectMax
;;;1743     WM_UNLOCK();
000f2e  e8bd4010          POP      {r4,lr}
000f32  f7ffbffe          B.W      GUI_Unlock
;;;1744   }
;;;1745   
                          ENDP

                  WM_Init PROC
;;;1786   */
;;;1787   void WM_Init(void) {
000f36  b530              PUSH     {r4,r5,lr}
000f38  b083              SUB      sp,sp,#0xc
;;;1788   	if (!_IsInited) {
000f3a  4c18              LDR      r4,|L1.3996|
000f3c  78a0              LDRB     r0,[r4,#2]  ; _IsInited
000f3e  2800              CMP      r0,#0
000f40  d12a              BNE      |L1.3992|
;;;1789   	  NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
000f42  8120              STRH     r0,[r4,#8]
000f44  82a0              STRH     r0,[r4,#0x14]
;;;1790   	  GUI_Context.WM__pUserClipRect = NULL;
000f46  4916              LDR      r1,|L1.4000|
000f48  63c8              STR      r0,[r1,#0x3c]  ; GUI_Context
;;;1791   	  WM__NumWindows = WM__NumInvalidWindows =0;
000f4a  80e0              STRH     r0,[r4,#6]
000f4c  80a0              STRH     r0,[r4,#4]
;;;1792   	  /* Make sure we have at least one window. This greatly simplifies the
;;;1793   		  drawing routines as they do not have to check if the window is valid.
;;;1794   	  */
;;;1795       #if GUI_NUM_LAYERS == 1
;;;1796         WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
000f4e  2300              MOVS     r3,#0
000f50  2102              MOVS     r1,#2
000f52  4a17              LDR      r2,|L1.4016|
000f54  9302              STR      r3,[sp,#8]
000f56  9100              STR      r1,[sp,#0]
000f58  9201              STR      r2,[sp,#4]
000f5a  f64073ff          MOV      r3,#0xfff
000f5e  2100              MOVS     r1,#0
000f60  461a              MOV      r2,r3
000f62  4608              MOV      r0,r1
000f64  f7fffffe          BL       WM_CreateWindow
000f68  f104050a          ADD      r5,r4,#0xa
000f6c  8028              STRH     r0,[r5,#0]
;;;1797         WM__aBkColor[0] = GUI_INVALID_COLOR;
000f6e  f104021c          ADD      r2,r4,#0x1c
000f72  f06f4170          MVN      r1,#0xf0000000
000f76  6011              STR      r1,[r2,#0]  ; WM__aBkColor
;;;1798         WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
000f78  f7fffffe          BL       WM_InvalidateWindow
;;;1799       #else
;;;1800       {
;;;1801         int i;
;;;1802         for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;1803           WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
;;;1804           WM__aBkColor[i] = GUI_INVALID_COLOR;
;;;1805           WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
;;;1806         }
;;;1807       }
;;;1808       #endif
;;;1809       /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
;;;1810       WM__AddCriticalHandle(&WM__CHWinModal);
000f7c  480d              LDR      r0,|L1.4020|
000f7e  f7fffffe          BL       WM__AddCriticalHandle
;;;1811       WM__AddCriticalHandle(&WM__CHWinLast);
000f82  480d              LDR      r0,|L1.4024|
000f84  f7fffffe          BL       WM__AddCriticalHandle
;;;1812       #if GUI_SUPPORT_MOUSE
;;;1813         WM__AddCriticalHandle(&WM__CHWinMouseOver);
;;;1814       #endif
;;;1815   
;;;1816       WM_SelectWindow(WM__ahDesktopWin[0]);
000f88  f9b50000          LDRSH    r0,[r5,#0]  ; WM__ahDesktopWin
000f8c  f7fffffe          BL       WM_SelectWindow
;;;1817   	  WM_Activate();
000f90  f7fffffe          BL       WM_Activate
;;;1818       _IsInited =1;
000f94  2001              MOVS     r0,#1
000f96  70a0              STRB     r0,[r4,#2]
                  |L1.3992|
;;;1819   	}
;;;1820   }
000f98  b003              ADD      sp,sp,#0xc
000f9a  bd30              POP      {r4,r5,pc}
;;;1821   
                          ENDP

                  |L1.3996|
                          DCD      ||.data||
                  |L1.4000|
                          DCD      GUI_Context
                  |L1.4004|
                          DCD      _cbPaintMemDev
                  |L1.4008|
                          DCD      WM_pfHandlePID
                  |L1.4012|
                          DCD      ||.data||+0x1c
                  |L1.4016|
                          DCD      cbBackWin
                  |L1.4020|
                          DCD      WM__CHWinModal
                  |L1.4024|
                          DCD      WM__CHWinLast

                          AREA ||.bss||, DATA, NOINIT, ALIGN=6

                  WM_PID__StateLast
                          %        12

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=6

                          EXPORTAS ||area_number.4||, ||.bss||
                  _ClipContext
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  WM_IsActive
000000  00                DCB      0x00
                  WM__PaintCallbackCnt
000001  00                DCB      0x00
                  _IsInited
000002  0000              DCB      0x00,0x00
                  WM__NumWindows
000004  0000              DCB      0x00,0x00
                  WM__NumInvalidWindows
000006  0000              DCB      0x00,0x00
                  WM__FirstWin
000008  0000              DCB      0x00,0x00
                  WM__ahDesktopWin
00000a  0000              DCB      0x00,0x00
                  WM__CreateFlags
00000c  0000              DCB      0x00,0x00
                  WM__hCapture
00000e  0000              DCB      0x00,0x00
                  WM__hWinFocus
000010  0000              DCB      0x00,0x00
                  WM__hATransWindow
000012  0000              DCB      0x00,0x00
                  NextDrawWin
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__pFirstCriticalHandle
                          DCD      0x00000000
                  WM__aBkColor
                          DCD      0x00000000
                  WM_pfPollPID
                          DCD      0x00000000
                  WM__TransWindowCnt
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  WM__CaptureReleaseAuto
000000  00                DCB      0x00
