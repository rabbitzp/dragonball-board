; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\rvmdk\gui__wrap.o --depend=.\rvmdk\gui__wrap.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I..\..\..\..\..\User\inc -I..\..\..\..\..\uCGUI\Config -I..\..\..\..\..\uCGUI\GUIDemo -I..\..\..\..\..\uCGUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\AntiAlias -I..\..\..\..\..\uCGUI\GUI\ConvertColor -I..\..\..\..\..\uCGUI\GUI\ConvertMono -I..\..\..\..\..\uCGUI\GUI\Core -I..\..\..\..\..\uCGUI\GUI\Font -I..\..\..\..\..\uCGUI\GUI\LCDDriver -I..\..\..\..\..\uCGUI\GUI\MemDev -I..\..\..\..\..\uCGUI\GUI\MultiLayer -I..\..\..\..\..\uCGUI\GUI\Widget -I..\..\..\..\..\uCGUI\GUI\WM -Id:\Keil-stm32\ARM\INC -Id:\Keil-stm32\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\rvmdk\gui__wrap.crf ..\..\..\..\..\uCGUI\GUI\Core\GUI__Wrap.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  _IsLineEnd PROC
;;;31     */
;;;32     static int _IsLineEnd(U16 Char) {
000000  b118              CBZ      r0,|L1.10|
;;;33       if (!Char || (Char == '\n')) {
000002  280a              CMP      r0,#0xa
000004  d001              BEQ      |L1.10|
;;;34         return 1;
;;;35       }
;;;36       return 0;
000006  2000              MOVS     r0,#0
;;;37     }
000008  4770              BX       lr
                  |L1.10|
00000a  2001              MOVS     r0,#1                 ;34
00000c  4770              BX       lr
;;;38     
                          ENDP

                  _GetNoWrap PROC
;;;42     */
;;;43     static int _GetNoWrap(const char GUI_UNI_PTR * s) {
00000e  f64771ff          MOV      r1,#0x7fff
;;;44       return GUI__GetLineNumChars(s, 0x7FFF);
000012  f7ffbffe          B.W      GUI__GetLineNumChars
;;;45     }
;;;46     
                          ENDP

                  _GetWordWrap PROC
;;;177    */
;;;178    static int _GetWordWrap(const char GUI_UNI_PTR * s, int xSize, int * pxDist) {
000016  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
00001a  4693              MOV      r11,r2
;;;179      int xDist = 0, NumChars = 0, WordWrap = 0, CharDist = 0;
00001c  f04f0800          MOV      r8,#0
000020  2400              MOVS     r4,#0
000022  2600              MOVS     r6,#0
000024  46a2              MOV      r10,r4
;;;180      U16 Char, PrevChar = 0, FirstChar = 0;
000026  46a1              MOV      r9,r4
000028  2700              MOVS     r7,#0
                  |L1.42|
;;;181      while (1) {
;;;182        Char = GUI_UC__GetCharCodeInc(&s);   /* Similar to:  *s++ */
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       GUI_UC__GetCharCodeInc
000030  4605              MOV      r5,r0
;;;183        if (!FirstChar) {
000032  b907              CBNZ     r7,|L1.54|
;;;184          FirstChar = Char;
000034  462f              MOV      r7,r5
                  |L1.54|
;;;185        }
;;;186        /* Let's first check if the line end is reached. In this case we are done. */
;;;187        if (_IsLineEnd(Char)) {
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       _IsLineEnd
00003c  b108              CBZ      r0,|L1.66|
;;;188          WordWrap = NumChars;
00003e  4626              MOV      r6,r4
;;;189          break;
000040  e01e              B        |L1.128|
                  |L1.66|
;;;190        }
;;;191        /* If the current character is part of leading spaces the position can be used for wrapping */
;;;192        if ((Char != ' ') && (FirstChar == ' ')) {
000042  2d20              CMP      r5,#0x20
000044  d001              BEQ      |L1.74|
000046  2f20              CMP      r7,#0x20
000048  d002              BEQ      |L1.80|
                  |L1.74|
;;;193          FirstChar = 0;
;;;194          WordWrap = NumChars;
;;;195        /* If the current character is a space and the previous character not, we found a wrapping position */
;;;196        } else if ((Char == ' ') && (Char != PrevChar)) {
00004a  2d20              CMP      r5,#0x20
00004c  d003              BEQ      |L1.86|
00004e  e007              B        |L1.96|
                  |L1.80|
000050  2700              MOVS     r7,#0                 ;193
000052  4626              MOV      r6,r4                 ;194
000054  e00a              B        |L1.108|
                  |L1.86|
000056  f1b90f20          CMP      r9,#0x20
00005a  d001              BEQ      |L1.96|
;;;197          WordWrap = NumChars;
00005c  4626              MOV      r6,r4
00005e  e005              B        |L1.108|
                  |L1.96|
;;;198        /* If the current character is a trailing space the position can be used for wrapping */
;;;199        } else if ((Char == ' ') && (PrevChar == ' ')) {
000060  2d20              CMP      r5,#0x20
000062  d103              BNE      |L1.108|
000064  f1b90f20          CMP      r9,#0x20
000068  d100              BNE      |L1.108|
;;;200          WordWrap = NumChars;
00006a  4626              MOV      r6,r4
                  |L1.108|
;;;201        }
;;;202        PrevChar = Char;
00006c  46a9              MOV      r9,r5
;;;203        CharDist = GUI_GetCharDistX(Char);
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       GUI_GetCharDistX
000074  4682              MOV      r10,r0
;;;204        xDist += CharDist;
000076  44d0              ADD      r8,r8,r10
;;;205        if ((xDist <= xSize) || (NumChars == 0)) {
000078  9801              LDR      r0,[sp,#4]
00007a  4580              CMP      r8,r0
00007c  dd02              BLE      |L1.132|
00007e  b10c              CBZ      r4,|L1.132|
                  |L1.128|
;;;206          NumChars++;
;;;207        } else {
;;;208          break;
;;;209        }
;;;210      }
;;;211      if (!WordWrap) {
000080  b116              CBZ      r6,|L1.136|
000082  e002              B        |L1.138|
                  |L1.132|
000084  1c64              ADDS     r4,r4,#1              ;206
000086  e7d0              B        |L1.42|
                  |L1.136|
;;;212        WordWrap = NumChars;
000088  4626              MOV      r6,r4
                  |L1.138|
;;;213      }
;;;214      if (pxDist) {
00008a  f1bb0f00          CMP      r11,#0
00008e  d003              BEQ      |L1.152|
;;;215        xDist -= CharDist;
000090  eba8000a          SUB      r0,r8,r10
;;;216        *pxDist = xDist;
000094  f8cb0000          STR      r0,[r11,#0]
                  |L1.152|
;;;217      }
;;;218      return WordWrap;
;;;219    }
000098  b003              ADD      sp,sp,#0xc
00009a  4630              MOV      r0,r6                 ;218
00009c  e8bd8ff0          POP      {r4-r11,pc}
;;;220    
                          ENDP

                  _GetCharWrap PROC
;;;224    */
;;;225    static int _GetCharWrap(const char GUI_UNI_PTR * s, int xSize) {
0000a0  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
0000a4  460e              MOV      r6,r1
;;;226      int xDist = 0, NumChars = 0;
0000a6  2500              MOVS     r5,#0
0000a8  2400              MOVS     r4,#0
;;;227      U16 Char;
;;;228      while ((Char = GUI_UC__GetCharCodeInc(&s)) != 0) {
0000aa  4668              MOV      r0,sp
0000ac  f7fffffe          BL       GUI_UC__GetCharCodeInc
0000b0  0007              MOVS     r7,r0
0000b2  d00e              BEQ      |L1.210|
                  |L1.180|
;;;229        xDist += GUI_GetCharDistX(Char);
0000b4  4638              MOV      r0,r7
0000b6  f7fffffe          BL       GUI_GetCharDistX
0000ba  4405              ADD      r5,r5,r0
;;;230        if ((NumChars && (xDist > xSize)) || (Char == '\n')) {
0000bc  b10c              CBZ      r4,|L1.194|
0000be  42b5              CMP      r5,r6
0000c0  dc07              BGT      |L1.210|
                  |L1.194|
0000c2  2f0a              CMP      r7,#0xa
0000c4  d005              BEQ      |L1.210|
;;;231          break;
;;;232        }
;;;233        NumChars++;
0000c6  1c64              ADDS     r4,r4,#1
0000c8  4668              MOV      r0,sp                 ;228
0000ca  f7fffffe          BL       GUI_UC__GetCharCodeInc
0000ce  0007              MOVS     r7,r0                 ;228
0000d0  d1f0              BNE      |L1.180|
                  |L1.210|
;;;234      }
;;;235      return NumChars;
;;;236    }
0000d2  b002              ADD      sp,sp,#8
0000d4  4620              MOV      r0,r4                 ;235
0000d6  e8bd81f0          POP      {r4-r8,pc}
;;;237    
                          ENDP

                  _WrapGetNumCharsDisp PROC
;;;243    */
;;;244    static int _WrapGetNumCharsDisp(const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode, int * pxDist) {
0000da  2a01              CMP      r2,#1
;;;245      int r;
;;;246      switch (WrapMode) {
0000dc  d002              BEQ      |L1.228|
0000de  2a02              CMP      r2,#2
0000e0  d002              BEQ      |L1.232|
;;;247      case GUI_WRAPMODE_WORD:
;;;248        r = _GetWordWrap(pText, xSize, pxDist);
;;;249        break;
;;;250      case GUI_WRAPMODE_CHAR:
;;;251        r = _GetCharWrap(pText, xSize);
;;;252        break;
;;;253      default:
;;;254        r = _GetNoWrap(pText);
0000e2  e7fe              B        _GetNoWrap
                  |L1.228|
0000e4  461a              MOV      r2,r3                 ;248
0000e6  e7fe              B        _GetWordWrap
                  |L1.232|
0000e8  e7fe              B        _GetCharWrap
;;;255      }
;;;256      return r;
;;;257    }
;;;258    
                          ENDP

                  GUI__WrapGetNumCharsDisp PROC
;;;273    */
;;;274    int GUI__WrapGetNumCharsDisp(const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode) {
0000ea  2300              MOVS     r3,#0
;;;275      return _WrapGetNumCharsDisp(pText, xSize, WrapMode, 0);
0000ec  e7fe              B        _WrapGetNumCharsDisp
;;;276    }
;;;277    
                          ENDP

                  GUI__WrapGetNumCharsToNextLine PROC
;;;281    */
;;;282    int GUI__WrapGetNumCharsToNextLine(const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode) {
0000ee  b5f7              PUSH     {r0-r2,r4-r7,lr}
0000f0  b082              SUB      sp,sp,#8
0000f2  460e              MOV      r6,r1
0000f4  4617              MOV      r7,r2
;;;283      int NumChars;
;;;284      int xDist;
;;;285      U16 Char;
;;;286      NumChars = _WrapGetNumCharsDisp(pText, xSize, WrapMode, &xDist);
0000f6  ab01              ADD      r3,sp,#4
0000f8  463a              MOV      r2,r7
0000fa  4631              MOV      r1,r6
0000fc  9802              LDR      r0,[sp,#8]
0000fe  f7fffffe          BL       _WrapGetNumCharsDisp
000102  4604              MOV      r4,r0
;;;287      pText   += GUI_UC__NumChars2NumBytes(pText, NumChars);
000104  4621              MOV      r1,r4
000106  9802              LDR      r0,[sp,#8]
000108  f7fffffe          BL       GUI_UC__NumChars2NumBytes
00010c  9902              LDR      r1,[sp,#8]
00010e  4408              ADD      r0,r0,r1
000110  9002              STR      r0,[sp,#8]
;;;288      Char     = GUI_UC__GetCharCodeInc(&pText);
000112  a802              ADD      r0,sp,#8
000114  f7fffffe          BL       GUI_UC__GetCharCodeInc
000118  4605              MOV      r5,r0
;;;289      if (Char == '\n') {
00011a  2d0a              CMP      r5,#0xa
00011c  d002              BEQ      |L1.292|
;;;290        NumChars++;
;;;291      } else {
;;;292        if ((WrapMode == GUI_WRAPMODE_WORD) && (Char == ' ')) {
00011e  2f01              CMP      r7,#1
000120  d002              BEQ      |L1.296|
000122  e014              B        |L1.334|
                  |L1.292|
000124  1c64              ADDS     r4,r4,#1              ;290
000126  e012              B        |L1.334|
                  |L1.296|
000128  2d20              CMP      r5,#0x20
00012a  d110              BNE      |L1.334|
;;;293          int xDistChar = GUI_GetCharDistX(Char);
00012c  4628              MOV      r0,r5
00012e  f7fffffe          BL       GUI_GetCharDistX
000132  4607              MOV      r7,r0
;;;294          while ((Char == ' ') && (xSize >= xDist)) {
000134  e006              B        |L1.324|
                  |L1.310|
;;;295            NumChars++;
000136  1c64              ADDS     r4,r4,#1
;;;296            xDist += xDistChar;
000138  4438              ADD      r0,r0,r7
00013a  9001              STR      r0,[sp,#4]
;;;297            Char = GUI_UC__GetCharCodeInc(&pText);
00013c  a802              ADD      r0,sp,#8
00013e  f7fffffe          BL       GUI_UC__GetCharCodeInc
000142  4605              MOV      r5,r0
                  |L1.324|
000144  2d20              CMP      r5,#0x20              ;294
000146  d102              BNE      |L1.334|
000148  9801              LDR      r0,[sp,#4]            ;294
00014a  4286              CMP      r6,r0                 ;294
00014c  daf3              BGE      |L1.310|
                  |L1.334|
;;;298          }
;;;299        }
;;;300      }
;;;301      return NumChars;
;;;302    }
00014e  b005              ADD      sp,sp,#0x14
000150  4620              MOV      r0,r4                 ;301
000152  bdf0              POP      {r4-r7,pc}
;;;303    
                          ENDP

                  GUI__WrapGetNumBytesToNextLine PROC
;;;307    */
;;;308    int GUI__WrapGetNumBytesToNextLine(const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode) {
000154  b510              PUSH     {r4,lr}
000156  4604              MOV      r4,r0
;;;309      int NumChars, NumBytes;
;;;310      NumChars = GUI__WrapGetNumCharsToNextLine(pText, xSize, WrapMode);
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       GUI__WrapGetNumCharsToNextLine
;;;311      NumBytes = GUI_UC__NumChars2NumBytes(pText, NumChars);
00015e  4601              MOV      r1,r0
000160  4620              MOV      r0,r4
000162  e8bd4010          POP      {r4,lr}
000166  f7ffbffe          B.W      GUI_UC__NumChars2NumBytes
;;;312      return NumBytes;
;;;313    }
;;;314    
                          ENDP

